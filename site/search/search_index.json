{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenido a StatCamp \u00b6 En este sitio web subir\u00e9 todo el contenido e informaci\u00f3n de diversos programas de software estad\u00edstico m\u00e1s comunes en estad\u00edstica y ciencias de datos. SAS \u00b6 Para ir al blog de SAS haz click aqu\u00ed . En este blog conoceras todo lo relacionado a: SAS/BASE - Contiene todo lo esencial para leer, manipular datos as\u00ed como otras funciones b\u00e1sicas de SAS. SAS/STAT - Tiene muchos m\u00e9todos estad\u00edsticos y otros an\u00e1lisis de datos. SAS/IML - Es un lenguaje espec\u00edfico para lenguaje de matrices y funciones matem\u00e1ticas y estad\u00edsticas avanzadas. OTROS - Conexi\u00f3n de SAS con otros lenguajes de programaci\u00f3n y sus configuraciones. R \u00b6 Visita mi blog sobre R . En este blog encontrar\u00e1s todo lo relacionada al lenguaje R. Variables Funciones Matrices Gr\u00e1ficas Data sets Entre otras cosas m\u00e1s. Python \u00b6 Click aqu\u00ed para ir a mi blog de Python. Aqu\u00ed encontrar\u00e1s todo lo relacionado con librer\u00edas que se usan en ciencia de datos. Julia \u00a1NUEVO! \u00b6 Click aqu\u00ed para ir a mi blog de Julia. Jupyter Notebooks \u00b6 PROXIMAMENTE \u2026 Sobre el sitio \u00b6 Este sitio es una gu\u00eda para iniciarse en el mundo de la programaci\u00f3n en diversos lengajes estad\u00edsticos y bajo ning\u00fan motivo el autor es responsable de los da\u00f1os ocasionados por resultados inesperados. Los softwares usados son SAS R Python Julia Los programas son mostrados con fines educativos. S\u00edguenos en nuestras redes sociales Github LinkedIn","title":"Bienvenido a StatCamp"},{"location":"#bienvenido-a-statcamp","text":"En este sitio web subir\u00e9 todo el contenido e informaci\u00f3n de diversos programas de software estad\u00edstico m\u00e1s comunes en estad\u00edstica y ciencias de datos.","title":"Bienvenido a StatCamp"},{"location":"#sas","text":"Para ir al blog de SAS haz click aqu\u00ed . En este blog conoceras todo lo relacionado a: SAS/BASE - Contiene todo lo esencial para leer, manipular datos as\u00ed como otras funciones b\u00e1sicas de SAS. SAS/STAT - Tiene muchos m\u00e9todos estad\u00edsticos y otros an\u00e1lisis de datos. SAS/IML - Es un lenguaje espec\u00edfico para lenguaje de matrices y funciones matem\u00e1ticas y estad\u00edsticas avanzadas. OTROS - Conexi\u00f3n de SAS con otros lenguajes de programaci\u00f3n y sus configuraciones.","title":"SAS"},{"location":"#r","text":"Visita mi blog sobre R . En este blog encontrar\u00e1s todo lo relacionada al lenguaje R. Variables Funciones Matrices Gr\u00e1ficas Data sets Entre otras cosas m\u00e1s.","title":"R"},{"location":"#python","text":"Click aqu\u00ed para ir a mi blog de Python. Aqu\u00ed encontrar\u00e1s todo lo relacionado con librer\u00edas que se usan en ciencia de datos.","title":"Python"},{"location":"#julia-nuevo","text":"Click aqu\u00ed para ir a mi blog de Julia.","title":"Julia \u00a1NUEVO!"},{"location":"#jupyter-notebooks","text":"PROXIMAMENTE \u2026","title":"Jupyter Notebooks"},{"location":"#sobre-el-sitio","text":"Este sitio es una gu\u00eda para iniciarse en el mundo de la programaci\u00f3n en diversos lengajes estad\u00edsticos y bajo ning\u00fan motivo el autor es responsable de los da\u00f1os ocasionados por resultados inesperados. Los softwares usados son SAS R Python Julia Los programas son mostrados con fines educativos. S\u00edguenos en nuestras redes sociales Github LinkedIn","title":"Sobre el sitio"},{"location":"julia/intro_julia/","text":"Inicio \u00b6 Julia es un poderoso lenguaje de programaci\u00f3n enfocado en la potencia y velocidad. Al iniciar Julia se muestra una pantalla en que es la consola de Julia. Variables \u00b6 Julia tiene varios tipos de variables, por ejemplo tipo num\u00e9rico (entero y flotante) booleano o caracter. Para conocer todos los tipos de variables que existen, consulte la documentaci\u00f3n . Se puede definir una variable usando el operador de asignaci\u00f3n = como se muestra en el siguiente ejemplo. x = 1 y = 1.25 z = x + y a = \"abc\" si = true Para saber de que tipo es, se puede usar la funci\u00f3n typeof() , el resultado se muestra typeof(x) Int64 Vectores \u00b6 La forma de definir vectores es mediante el uso de corchetes cuadrados [] , por ejemplo: a = [1,2,3] b = [2,4,5] No confundir con tuplas La forma de definir una tupla es mediante un par\u00e9ntesis () . Al igual que otros lenguajes de programaci\u00f3n, la forma de acceder a sus elementos es mediante el operador [] y tambi\u00e9n con : se puede definir una secuencia. a[2] b[1:2] Operadores aritm\u00e9ticos \u00b6 Julia soporta diversos operadores aritm\u00e9ticos, la siguiente tabla muestra los principales operadores. Expresi\u00f3n Nombre Descripci\u00f3n x + y suma realiza adici\u00f3n x - y resta realiza substracci\u00f3n x * y producto realiza multiplicaci\u00f3n x / y divisi\u00f3n realiza divisi\u00f3n x \u00f7 y divisi\u00f3n entera similar a x/y , pero truncado a un entero x \\ y divisi\u00f3n inversa equivalente a y/x x ^ y potencia eleva x a la potencia y x % y resto equivalente to rem(x,y) Para una mayor referencia visita la secci\u00f3n operadores aritm\u00e9ticos . Control de flujo \u00b6 Julia posee estructuras para control de flujo. Se puede realizar un ciclo usando el siguiente c\u00f3digo for x in 1:10 println(x) end Nota La funci\u00f3n print() imprimir\u00eda los valores consecutivamente sin espacio, mientras que println() los imprime en una l\u00ednea nueva. Se debe tomar en cuenta que la palabra for debe cerrarse con un end para delimitar el bloque. Para usar el ciclo while, se usa el siguiente c\u00f3digo x = 0 while x <= 5 println(x) x = x + 1 end Ciclo infinito No olvides aumentar el contador con el fin de que se cumpla la condici\u00f3n, de otro modo se entrar\u00eda en un ciclo infinito. Funciones \u00b6 Para definir una funci\u00f3n, se usa la palabra function seguido del nombre de la funci\u00f3n y entre par\u00e9ntesis los argumentos. Se debe especificar la paabra clave return , de otro modo retornar\u00eda el \u00faltimo valor calculado. La funci\u00f3n termina con un end e inmediatamente se compila. function signo(x) if x < 0 resp = \"Negativo\" elseif x > 0 resp = \"Positivo\" else resp = \"Es Cero\" end return resp end una vez compilada, se puede usar. signo(-5) El resultado ser\u00eda el siguiente \u201cNegativo\u201d","title":"Introducci\u00f3n a Julia"},{"location":"julia/intro_julia/#inicio","text":"Julia es un poderoso lenguaje de programaci\u00f3n enfocado en la potencia y velocidad. Al iniciar Julia se muestra una pantalla en que es la consola de Julia.","title":"Inicio"},{"location":"julia/intro_julia/#variables","text":"Julia tiene varios tipos de variables, por ejemplo tipo num\u00e9rico (entero y flotante) booleano o caracter. Para conocer todos los tipos de variables que existen, consulte la documentaci\u00f3n . Se puede definir una variable usando el operador de asignaci\u00f3n = como se muestra en el siguiente ejemplo. x = 1 y = 1.25 z = x + y a = \"abc\" si = true Para saber de que tipo es, se puede usar la funci\u00f3n typeof() , el resultado se muestra typeof(x) Int64","title":"Variables"},{"location":"julia/intro_julia/#vectores","text":"La forma de definir vectores es mediante el uso de corchetes cuadrados [] , por ejemplo: a = [1,2,3] b = [2,4,5] No confundir con tuplas La forma de definir una tupla es mediante un par\u00e9ntesis () . Al igual que otros lenguajes de programaci\u00f3n, la forma de acceder a sus elementos es mediante el operador [] y tambi\u00e9n con : se puede definir una secuencia. a[2] b[1:2]","title":"Vectores"},{"location":"julia/intro_julia/#operadores-aritmeticos","text":"Julia soporta diversos operadores aritm\u00e9ticos, la siguiente tabla muestra los principales operadores. Expresi\u00f3n Nombre Descripci\u00f3n x + y suma realiza adici\u00f3n x - y resta realiza substracci\u00f3n x * y producto realiza multiplicaci\u00f3n x / y divisi\u00f3n realiza divisi\u00f3n x \u00f7 y divisi\u00f3n entera similar a x/y , pero truncado a un entero x \\ y divisi\u00f3n inversa equivalente a y/x x ^ y potencia eleva x a la potencia y x % y resto equivalente to rem(x,y) Para una mayor referencia visita la secci\u00f3n operadores aritm\u00e9ticos .","title":"Operadores aritm\u00e9ticos"},{"location":"julia/intro_julia/#control-de-flujo","text":"Julia posee estructuras para control de flujo. Se puede realizar un ciclo usando el siguiente c\u00f3digo for x in 1:10 println(x) end Nota La funci\u00f3n print() imprimir\u00eda los valores consecutivamente sin espacio, mientras que println() los imprime en una l\u00ednea nueva. Se debe tomar en cuenta que la palabra for debe cerrarse con un end para delimitar el bloque. Para usar el ciclo while, se usa el siguiente c\u00f3digo x = 0 while x <= 5 println(x) x = x + 1 end Ciclo infinito No olvides aumentar el contador con el fin de que se cumpla la condici\u00f3n, de otro modo se entrar\u00eda en un ciclo infinito.","title":"Control de flujo"},{"location":"julia/intro_julia/#funciones","text":"Para definir una funci\u00f3n, se usa la palabra function seguido del nombre de la funci\u00f3n y entre par\u00e9ntesis los argumentos. Se debe especificar la paabra clave return , de otro modo retornar\u00eda el \u00faltimo valor calculado. La funci\u00f3n termina con un end e inmediatamente se compila. function signo(x) if x < 0 resp = \"Negativo\" elseif x > 0 resp = \"Positivo\" else resp = \"Es Cero\" end return resp end una vez compilada, se puede usar. signo(-5) El resultado ser\u00eda el siguiente \u201cNegativo\u201d","title":"Funciones"},{"location":"python/basico/","text":"Librer\u00edas \u00b6 El primer paso es llamar las librer\u00edas que se utilizar\u00e1n en la sesi\u00f3n. Usaremos pandas y numpy y otra librer\u00eda adicional llamada os . import pandas as pd import numpy as np import os Nota En ocasiones es preferible usar nombres m\u00e1s cortos para referirnos a los nombres de las librer\u00edas. Por ejemplo, a pandas le llamaremos pd y np para referirnos a numpy . Ahora llamaremos a la funci\u00f3n para leer los datos. datos = pd.read_csv(\"census.csv\") Como puede observarse, datos es un objeto DataFrame que se define gracias a la funci\u00f3n read_csv() de pandas. Se puede obtener informaci\u00f3n del objeto usando el siguiente comando. datos.info() Para ver un resumen de los datos se puede usar datos.describe() Para visualizar los primeros 5 datos se puede usar este c\u00f3digo datos.head(n=5)","title":"Python nivel b\u00e1sico"},{"location":"python/basico/#librerias","text":"El primer paso es llamar las librer\u00edas que se utilizar\u00e1n en la sesi\u00f3n. Usaremos pandas y numpy y otra librer\u00eda adicional llamada os . import pandas as pd import numpy as np import os Nota En ocasiones es preferible usar nombres m\u00e1s cortos para referirnos a los nombres de las librer\u00edas. Por ejemplo, a pandas le llamaremos pd y np para referirnos a numpy . Ahora llamaremos a la funci\u00f3n para leer los datos. datos = pd.read_csv(\"census.csv\") Como puede observarse, datos es un objeto DataFrame que se define gracias a la funci\u00f3n read_csv() de pandas. Se puede obtener informaci\u00f3n del objeto usando el siguiente comando. datos.info() Para ver un resumen de los datos se puede usar datos.describe() Para visualizar los primeros 5 datos se puede usar este c\u00f3digo datos.head(n=5)","title":"Librer\u00edas"},{"location":"python/intro_python/","text":"Esta es un tutorial r\u00e1pido sobre el programa. Instalaci\u00f3n \u00b6 El sitio oficial de Python es python.org , sin embargo se recomienda instalar Anaconda , una distribuci\u00f3n de Pthon que contiene muchos m\u00f3dulos y software adicional para trabajar con Python. Anaconda \u00b6 Usted puede descargar el software gratuitamente. Visite la p\u00e1gina de Anaconda para m\u00e1s informaci\u00f3n. Interfaces gr\u00e1ficas \u00b6 Consola \u00b6 Python corre desde la consola de windows (cmd o powershell), aunque puede ser llamada desde Anaconda Prompt o Anaconda Powershell Prompt . Spyder \u00b6 Es otra interfaz gr\u00e1fica destinada a desarrollar c\u00f3digo eficientemente, ya que cuenta con varias opciones de configuraci\u00f3n y ventanas con varias funciones. Esta interfaz gr\u00e1fica ya viene incluida en Anaconda. Jupyter Notebooks \u00b6 Python tiene unos cuadernos interactivos para correr c\u00f3digo interactivamente. Jupyter Notebooks se instala junto con Anaconda.","title":"Introducci\u00f3n a Python"},{"location":"python/intro_python/#instalacion","text":"El sitio oficial de Python es python.org , sin embargo se recomienda instalar Anaconda , una distribuci\u00f3n de Pthon que contiene muchos m\u00f3dulos y software adicional para trabajar con Python.","title":"Instalaci\u00f3n"},{"location":"python/intro_python/#anaconda","text":"Usted puede descargar el software gratuitamente. Visite la p\u00e1gina de Anaconda para m\u00e1s informaci\u00f3n.","title":"Anaconda"},{"location":"python/intro_python/#interfaces-graficas","text":"","title":"Interfaces gr\u00e1ficas"},{"location":"python/intro_python/#consola","text":"Python corre desde la consola de windows (cmd o powershell), aunque puede ser llamada desde Anaconda Prompt o Anaconda Powershell Prompt .","title":"Consola"},{"location":"python/intro_python/#spyder","text":"Es otra interfaz gr\u00e1fica destinada a desarrollar c\u00f3digo eficientemente, ya que cuenta con varias opciones de configuraci\u00f3n y ventanas con varias funciones. Esta interfaz gr\u00e1fica ya viene incluida en Anaconda.","title":"Spyder"},{"location":"python/intro_python/#jupyter-notebooks","text":"Python tiene unos cuadernos interactivos para correr c\u00f3digo interactivamente. Jupyter Notebooks se instala junto con Anaconda.","title":"Jupyter Notebooks"},{"location":"r/basico_r/","text":"Conociendo R \u00b6","title":"R nivel b\u00e1sico"},{"location":"r/basico_r/#conociendo-r","text":"","title":"Conociendo R"},{"location":"r/intro_r/","text":"Este es un tutorial b\u00e1sico sobre el programa. Visite la p\u00e1gina de R para m\u00e1s informaci\u00f3n. Objetos de R \u00b6 R es un lenguaje de programaci\u00f3n que usa objetos. Estos objetos tienen identidad, atributos y propiedades. Tambien puede considerarse como un int\u00e9rprete, es decir que espera acciones del usuario. Cuando el usuario ejecuta comandos, R los ejecuta l\u00ednea por l\u00ednea. Los comandos o expresiones m\u00e1s comunes son las asignaciones, es decir se asigna un valor a una variables. Cada comando suele escribirse en una sola l\u00ednea o terminar con punto y coma. R es un lenguaje sensible a may\u00fasculas y min\u00fasculas, esto es un factor a tomar en cuenta para evitar errores. Interaz gr\u00e1fica R tiene una interfaz gr\u00e1fica para crear c\u00f3digo de forma m\u00e1s amigable. Visite R Studio para m\u00e1s informaci\u00f3n. Cuando se inicia una sesi\u00f3n, se asigna un espacio de trabajo (workspace) en memoria y un directorio de trabajo (working directory). El espacio de trabajo sirve para almacenar objetos creados, tales como vectores, funciones entre otros. Para conocer el directorio de trabajo puede escribir en consola: getwd() Para cambiar use la funci\u00f3n setwd(\"dir\") , donde dir es el nuevo directorio. Barras verticales R no reconoce una sola barra / en los directorios de windows. Use doble barra // o una barra invertida \\ . Vectores \u00b6 Un vector es un objeto con uno o m\u00e1s elementos. Puede contener elementos num\u00e9ricos o caracteres. Se pueden crear vectores con la funci\u00f3n c() , por ejemplo: x = c(2,1,5) z = c(\"ABC\",\"AEI\",\"XYZ\") Los vectores permiten algunas operaciones, las m\u00e1s comunes son la suma + , resta - , multiplicaci\u00f3n * , divisi\u00f3n. / y potencia ^ , as\u00ed como valores booleanos. y = m*x+n xy = x > y Operaci\u00f3n entre vectores Las operaciones entre vectores son elemento a elemento. Si los elementos no tuvieran el mismo tama\u00f1o, el de menor tama\u00f1o se recicla (repite sus elementos) hasta tener el mismo n\u00famero de elementos. Por ejemplo, la operaci\u00f3n nx = n + x dar\u00e1 como resultado: [1] 7 6 10 Los vectores tienen una dimensi\u00f3n y para conocerla se puede usar la funci\u00f3n length() . Por ejemplo length(x) nos dar\u00eda como resultado: [1] 3 ya que sus elementos son: [1] 2 1 5 Tambi\u00e9n se puede acceder a sus elementos mediante el operador [] , por ejemplo para conocer el segundo elemento de x se puede usar x[2] y el resultado es: [1] 1 Para acceder a m\u00e1s de un elemento, es posible apuntar a la posici\u00f3n del elemento, por ejemplo x[c(1,2)] o x[1:2] . En ambos, el resultado ser\u00eda: [1] 2 1 El operador : sirve para indicar una secuencia consecutiva. Por ejemplo i = 1:10 crear\u00eda un vector de 10 elementos del 1 al 10, esto es \u00fatil para crear sucesiones o \u00edndices. Para crear secuencias m\u00e1s complejas se puede usar la funci\u00f3n seq() . Por ejemplo con seq(from = 1,to = 10,by = 1) se crea una secuencia del 1 al 10 incrementando el valor en 1 y se obtiene el mismo resultado que con 1:10 . Otra forma de crear un vector es mediante la funci\u00f3n rep() . Por ejemplo la siguiente expresion: u = rep(x = x,each = 2,times = 3) Crea un el vector u que contiene cada elemento del vector x 2 veces y esta secuencia se recrea 3 veces. [1] 2 2 1 1 5 5 2 2 1 1 5 5 2 2 1 1 5 5 Nombres de vector \u00b6 Una propiedad de los vectores es que sus elementos pueden tener un nombre. Se puede usar la funci\u00f3n names() para consultar o asignar nombres a un vector. El siguiente c\u00f3digo asignar\u00e1 nombres a los elementos del vector a1 . nombres <- c(\"uno\",\"dos\",\"tres\") names(a1)<-nombres Los nombres tambi\u00e9n pueden ser usados para acceder a los elementos de un vector, por ejemplo para acceder al segundo elemento, se puede usar su nombre correspondiente, es decir a1[\"dos\"] . Escalares \u00b6 Un escalar es un vector con un solo elemento. Se pueden crear escalares con el s\u00edmbolo de asignaci\u00f3n <- o = . n <- 5 m = n + 1 a = \"Hola mundo!\" Los escalares son \u00fatiles para guardar alg\u00fan valor. Pueden ser considerados como una variable. Tambi\u00e9n puede haber escalares l\u00f3gicos o booleanos, por ejemplo si se construye nm = n>m su valor ser\u00eda: [1] FALSE Matrices \u00b6 Una matriz es una arreglo de dos dimensiones (renglones y columnas) que contiene valores, especialmente num\u00e9ricos. Tiene n renglones y p columnas, es decir tiene np elementos. Para crea una matriz, se usa la funci\u00f3n matrix() cuya sintaxis es la siguiente: matrix( data = objeto, nrow = valor, ncol = valor <, byrow = FALSE> ) donde data representa un vector o una expresi\u00f3n, nrow el n\u00famero de renglones que se desean, ncol el n\u00famero de columnas y el argumento opcional byrow indica si se deber\u00edan llenar por columnas. Si se ejecuta el siguiente comando: A1 = matrix(data = u) el resultado ser\u00eda una matriz de 18 renglones y una columna. Si se desea una matriz de otra dimensi\u00f3n se puede usar este c\u00f3digo. A1 = matrix(data = u,nrow = 6,byrow = TRUE) Tambi\u00e9n pueden crearse matrices a partir de vectores, mediante las funciones cbind() y rbind() . La primera permite concatenar columas y la segunda concatena renglones, por ejemplo a1 = c(1,2,3) a2 = c(4,5,6) a3 = c(7,8) A = rbind(cbind(a1,a2),a3) El resultado es el siguiente: Elementos de una matriz \u00b6 Para acceder a los elementos de una matriz, podemos referirnos por medio de su posici\u00f3n [row,column] , por ejemplo para acceder al elemento ubicado en el rengl\u00f3n 1 de la columna 1 se usa: A[1,1] Tambi\u00e9n se puede usar el n\u00famero de elemento, empezando de izquierda a derecha por columna, en este caso A[1] . Para obtener todo el rengl\u00f3n o toda la columna, \u00fanicamente se escribe el elemento que se quiere obtener, pero se debe dejar la coma, por ejemplo A[1,] A[,2] Traer\u00edan el primer rengl\u00f3n y la segunda columna respectivamente. Al igual que en el caso de los vectores para trae un rango espec\u00edfico se puede usar el operador : o un vector indicando los elemento deseados. A[1:2,2] A[c(1,3),1] Nombres de una matriz \u00b6 De la misma forma que los vectores, las matrices pueden tener nombres en sus elementos. Adem\u00e1s se puede consultar y asignar un nombre a sus columnas y renglones usando las funciones colnames() y rownames() . De la misma forma, se pueden usar estos nombre para acceder a sus elementos. Data Frames \u00b6 Listas \u00b6 Paquetes \u00b6 R dispone de miles de paquetes que pueden descargarse libremente para enriquecerse son nuevas caracter\u00edsticas. Estos paquetes est\u00e1n almacenados en el CRAN y pueden instalarse f\u00e1cilmente desde la consola con el siguiente comando install.packages() Por ejemplo, si se desea instalar el paquete ggplot2 se puede usar el siguiente comando. install.packages(\"ggplot2\") R almacenar\u00e1 los archivos en la carpeta personal llamada biblioteca del usuario o User library . Frecuentemente al instalar un paquete R descarga otros paquetes relacionados llamados dependencias que sirven para que las funciones del paquete trabajen adecuadamente. Sin embargo, a\u00fan no podr\u00e1 usarse debido a que es necesario cargarla mediante el comando library() , por ejemplo, para cargar el paquete ggplot2 se debe ejecutar library(ggplot2) Con esto, todas las funciones y objetos del paquete estar\u00e1n definidos y listos para usarse. Ayuda \u00b6 R dispone de un comando especial para obtener ayuda desde la consola. Por ejemplo para buscar ayuda sobre matrices, se puede escribir desde la consola el comando ?matrix o bien con help(topic = \"matrix\") y con eso se abrir\u00e1 un documento de ayuda. Para realizar una b\u00fasqueda m\u00e1s general simplemente se deben escribir doble signo de interrogaci\u00f3n. ??matrix El sistema de ayuda nos mostrar\u00e1 los t\u00e9rminos relacionados en todos los paquetes que encuentre. Tambi\u00e9n se puede obtener ayuda acerca de una paquete en espec\u00edfico, por ejemplo help(package = \"ggplot2\") y con ello se obtendr\u00e1 la documentaci\u00f3n del paquete en espec\u00edfico.","title":"Introducci\u00f3n a R"},{"location":"r/intro_r/#objetos-de-r","text":"R es un lenguaje de programaci\u00f3n que usa objetos. Estos objetos tienen identidad, atributos y propiedades. Tambien puede considerarse como un int\u00e9rprete, es decir que espera acciones del usuario. Cuando el usuario ejecuta comandos, R los ejecuta l\u00ednea por l\u00ednea. Los comandos o expresiones m\u00e1s comunes son las asignaciones, es decir se asigna un valor a una variables. Cada comando suele escribirse en una sola l\u00ednea o terminar con punto y coma. R es un lenguaje sensible a may\u00fasculas y min\u00fasculas, esto es un factor a tomar en cuenta para evitar errores. Interaz gr\u00e1fica R tiene una interfaz gr\u00e1fica para crear c\u00f3digo de forma m\u00e1s amigable. Visite R Studio para m\u00e1s informaci\u00f3n. Cuando se inicia una sesi\u00f3n, se asigna un espacio de trabajo (workspace) en memoria y un directorio de trabajo (working directory). El espacio de trabajo sirve para almacenar objetos creados, tales como vectores, funciones entre otros. Para conocer el directorio de trabajo puede escribir en consola: getwd() Para cambiar use la funci\u00f3n setwd(\"dir\") , donde dir es el nuevo directorio. Barras verticales R no reconoce una sola barra / en los directorios de windows. Use doble barra // o una barra invertida \\ .","title":"Objetos de R"},{"location":"r/intro_r/#vectores","text":"Un vector es un objeto con uno o m\u00e1s elementos. Puede contener elementos num\u00e9ricos o caracteres. Se pueden crear vectores con la funci\u00f3n c() , por ejemplo: x = c(2,1,5) z = c(\"ABC\",\"AEI\",\"XYZ\") Los vectores permiten algunas operaciones, las m\u00e1s comunes son la suma + , resta - , multiplicaci\u00f3n * , divisi\u00f3n. / y potencia ^ , as\u00ed como valores booleanos. y = m*x+n xy = x > y Operaci\u00f3n entre vectores Las operaciones entre vectores son elemento a elemento. Si los elementos no tuvieran el mismo tama\u00f1o, el de menor tama\u00f1o se recicla (repite sus elementos) hasta tener el mismo n\u00famero de elementos. Por ejemplo, la operaci\u00f3n nx = n + x dar\u00e1 como resultado: [1] 7 6 10 Los vectores tienen una dimensi\u00f3n y para conocerla se puede usar la funci\u00f3n length() . Por ejemplo length(x) nos dar\u00eda como resultado: [1] 3 ya que sus elementos son: [1] 2 1 5 Tambi\u00e9n se puede acceder a sus elementos mediante el operador [] , por ejemplo para conocer el segundo elemento de x se puede usar x[2] y el resultado es: [1] 1 Para acceder a m\u00e1s de un elemento, es posible apuntar a la posici\u00f3n del elemento, por ejemplo x[c(1,2)] o x[1:2] . En ambos, el resultado ser\u00eda: [1] 2 1 El operador : sirve para indicar una secuencia consecutiva. Por ejemplo i = 1:10 crear\u00eda un vector de 10 elementos del 1 al 10, esto es \u00fatil para crear sucesiones o \u00edndices. Para crear secuencias m\u00e1s complejas se puede usar la funci\u00f3n seq() . Por ejemplo con seq(from = 1,to = 10,by = 1) se crea una secuencia del 1 al 10 incrementando el valor en 1 y se obtiene el mismo resultado que con 1:10 . Otra forma de crear un vector es mediante la funci\u00f3n rep() . Por ejemplo la siguiente expresion: u = rep(x = x,each = 2,times = 3) Crea un el vector u que contiene cada elemento del vector x 2 veces y esta secuencia se recrea 3 veces. [1] 2 2 1 1 5 5 2 2 1 1 5 5 2 2 1 1 5 5","title":"Vectores"},{"location":"r/intro_r/#nombres-de-vector","text":"Una propiedad de los vectores es que sus elementos pueden tener un nombre. Se puede usar la funci\u00f3n names() para consultar o asignar nombres a un vector. El siguiente c\u00f3digo asignar\u00e1 nombres a los elementos del vector a1 . nombres <- c(\"uno\",\"dos\",\"tres\") names(a1)<-nombres Los nombres tambi\u00e9n pueden ser usados para acceder a los elementos de un vector, por ejemplo para acceder al segundo elemento, se puede usar su nombre correspondiente, es decir a1[\"dos\"] .","title":"Nombres de vector"},{"location":"r/intro_r/#escalares","text":"Un escalar es un vector con un solo elemento. Se pueden crear escalares con el s\u00edmbolo de asignaci\u00f3n <- o = . n <- 5 m = n + 1 a = \"Hola mundo!\" Los escalares son \u00fatiles para guardar alg\u00fan valor. Pueden ser considerados como una variable. Tambi\u00e9n puede haber escalares l\u00f3gicos o booleanos, por ejemplo si se construye nm = n>m su valor ser\u00eda: [1] FALSE","title":"Escalares"},{"location":"r/intro_r/#matrices","text":"Una matriz es una arreglo de dos dimensiones (renglones y columnas) que contiene valores, especialmente num\u00e9ricos. Tiene n renglones y p columnas, es decir tiene np elementos. Para crea una matriz, se usa la funci\u00f3n matrix() cuya sintaxis es la siguiente: matrix( data = objeto, nrow = valor, ncol = valor <, byrow = FALSE> ) donde data representa un vector o una expresi\u00f3n, nrow el n\u00famero de renglones que se desean, ncol el n\u00famero de columnas y el argumento opcional byrow indica si se deber\u00edan llenar por columnas. Si se ejecuta el siguiente comando: A1 = matrix(data = u) el resultado ser\u00eda una matriz de 18 renglones y una columna. Si se desea una matriz de otra dimensi\u00f3n se puede usar este c\u00f3digo. A1 = matrix(data = u,nrow = 6,byrow = TRUE) Tambi\u00e9n pueden crearse matrices a partir de vectores, mediante las funciones cbind() y rbind() . La primera permite concatenar columas y la segunda concatena renglones, por ejemplo a1 = c(1,2,3) a2 = c(4,5,6) a3 = c(7,8) A = rbind(cbind(a1,a2),a3) El resultado es el siguiente:","title":"Matrices"},{"location":"r/intro_r/#elementos-de-una-matriz","text":"Para acceder a los elementos de una matriz, podemos referirnos por medio de su posici\u00f3n [row,column] , por ejemplo para acceder al elemento ubicado en el rengl\u00f3n 1 de la columna 1 se usa: A[1,1] Tambi\u00e9n se puede usar el n\u00famero de elemento, empezando de izquierda a derecha por columna, en este caso A[1] . Para obtener todo el rengl\u00f3n o toda la columna, \u00fanicamente se escribe el elemento que se quiere obtener, pero se debe dejar la coma, por ejemplo A[1,] A[,2] Traer\u00edan el primer rengl\u00f3n y la segunda columna respectivamente. Al igual que en el caso de los vectores para trae un rango espec\u00edfico se puede usar el operador : o un vector indicando los elemento deseados. A[1:2,2] A[c(1,3),1]","title":"Elementos de una matriz"},{"location":"r/intro_r/#nombres-de-una-matriz","text":"De la misma forma que los vectores, las matrices pueden tener nombres en sus elementos. Adem\u00e1s se puede consultar y asignar un nombre a sus columnas y renglones usando las funciones colnames() y rownames() . De la misma forma, se pueden usar estos nombre para acceder a sus elementos.","title":"Nombres de una matriz"},{"location":"r/intro_r/#data-frames","text":"","title":"Data Frames"},{"location":"r/intro_r/#listas","text":"","title":"Listas"},{"location":"r/intro_r/#paquetes","text":"R dispone de miles de paquetes que pueden descargarse libremente para enriquecerse son nuevas caracter\u00edsticas. Estos paquetes est\u00e1n almacenados en el CRAN y pueden instalarse f\u00e1cilmente desde la consola con el siguiente comando install.packages() Por ejemplo, si se desea instalar el paquete ggplot2 se puede usar el siguiente comando. install.packages(\"ggplot2\") R almacenar\u00e1 los archivos en la carpeta personal llamada biblioteca del usuario o User library . Frecuentemente al instalar un paquete R descarga otros paquetes relacionados llamados dependencias que sirven para que las funciones del paquete trabajen adecuadamente. Sin embargo, a\u00fan no podr\u00e1 usarse debido a que es necesario cargarla mediante el comando library() , por ejemplo, para cargar el paquete ggplot2 se debe ejecutar library(ggplot2) Con esto, todas las funciones y objetos del paquete estar\u00e1n definidos y listos para usarse.","title":"Paquetes"},{"location":"r/intro_r/#ayuda","text":"R dispone de un comando especial para obtener ayuda desde la consola. Por ejemplo para buscar ayuda sobre matrices, se puede escribir desde la consola el comando ?matrix o bien con help(topic = \"matrix\") y con eso se abrir\u00e1 un documento de ayuda. Para realizar una b\u00fasqueda m\u00e1s general simplemente se deben escribir doble signo de interrogaci\u00f3n. ??matrix El sistema de ayuda nos mostrar\u00e1 los t\u00e9rminos relacionados en todos los paquetes que encuentre. Tambi\u00e9n se puede obtener ayuda acerca de una paquete en espec\u00edfico, por ejemplo help(package = \"ggplot2\") y con ello se obtendr\u00e1 la documentaci\u00f3n del paquete en espec\u00edfico.","title":"Ayuda"},{"location":"sas/basico_sas/","text":"Lectura de datos \u00b6 Los dataset son el insumo principal para analisis de datos en SAS, por ello iniciaremos con una r\u00e1pida exploraci\u00f3n. En esta secci\u00f3n se presentan temas para comenzar con la lectura y escritura de datos. Se explorar\u00e1n distintas formas de leer y escribir datos de distintas fuentes y formatos de archivo. La creaci\u00f3n de un dataset inicia con un bloque DATA y termina con un RUN . Sin embargo, aprenderemos el uso b\u00e1sico de un procedimiento para leer datos de fuentes externas. Creando datasets \u00b6 En esta secci\u00f3n se mostrar\u00e1n las principales formas de crear datasets: Introducci\u00f3n de forma manual Leyendo un archivo de texto externo El uso de PROC IMPORT Se mostrar\u00e1n las ideas y algunos ejemplos. Introducci\u00f3n de valores de forma manual \u00b6 La forma m\u00e1s f\u00e1cil de crear un dataset, es con el uso de la sentencia INPUT y DATALINES con el fin de introducir valores manualmente. Estos datos fueron copiados y pegados directamente de una hoja de excel. El siguiente ejemplo muestra como introducir datos manualmente. DATA EMPLEADOS(LABEL = \"Registro de empleados nuevos\"); ATTRIB NOMBRE LENGTH = $16 LABEL = \"Nombre\" APELLIDO LENGTH = $12 LABEL = \"Apellido\" ID LABEL = \"ID empleado\" GENERO LENGTH = $1. LABEL = \"G\u00e9nero\" FNAC INFORMAT = DDMMYY10. FORMAT = DATE10. LABEL = \"Fecha de nacimiento\" ; INPUT NOMBRE -- FNAC; DATALINES; Bill Cuddy 11171 M 16/10/1986 Susan Krasowski 17023 F 09/07/1959 Andreas Rennie 26148 M 18/07/1934 Lauren Krasowski 46966 F 24/10/1986 Lauren Marx 54655 F 18/08/1969 Tommy Mcdonald 70046 M 20/01/1959 Colin Byarley 70059 M 20/01/1934 Lera Knott 70079 F 11/07/1986 Wilma Yeargan 70100 F 23/06/1984 Patrick Leach 70108 M 14/04/1939 Portia Reynoso 70165 F 11/02/1964 Soberina Berent 70187 F 27/09/1986 Angel Borwick 70201 F 19/12/1969 Alex Santinello 70210 M 22/04/1986 Kenan Talarr 70221 M 10/02/1964 ; RUN; La sentencia DATA especifica el nombre del dataset y entre parentesis est\u00e1n las opciones del dataset, en este caso el dataset empleados tendr\u00e1 una etiqueta para identificarlo. Es recomendable especificar las propiedades de las variables a crear mediante la sentencia ATTRIB en donde se especifican sus propiedades. Declaraci\u00f3n de variables Otra forma de declarar variables es mediante las sentencias LENGTH y FORMAT . Consulte la documentaci\u00f3n para m\u00e1s informaci\u00f3n. N\u00f3tese que para el caso de las variables de tipo caracter se hace uso de la opci\u00f3n LENGTH = seguido del signo de pesos para indicar que es de tipo caracter y la longitud deseada. Para el caso de variables num\u00e9ricas, se debe especificar al menos un atributo, en este caso se recomienda especificar el atributo LABEL = . En el caso de la variable fnac los datos estan almacenados en formato de fecha (ddmmyyyy) por lo que se usa el informato ddmmyy10. para que lo reconozca como fehca de sas, pero se desea visualizar con el formato de fecha (ddmmmyyyy). La sentencia INPUT sirve para indicar el nombre de las variables del dataset. Se puede poner el s\u00edmbolo $ para indicar que la variable es de tipo caracter. Sin embargo en este caso, como ya se han declarado las variables se puede usar una lista, es decir, solo poner el nombre de la primer variable declarada seguido de dos guiones -- y el nombre de la \u00faltima. La sentencia DATALINES indica el inicio de los datos y finaliza con un punto y coma. Con la sentencia RUN se cierra el bloque de instrucciones y comienza a ejecutar el proceso. Lectura de datos desde un archivo externo \u00b6 SAS puede leer datos de archivos de texto almacenados en distintos formatos, por ejemplo de ancho fijo o delimitados. Para acceder a ellos es necesario usar la referencia para apuntar a ellos, algo similar a la declaraci\u00f3n de las librer\u00edas. Se puede hacer mediante la sentencia FILENAME : FILENAME fileref \u2018 nombre-archivo \u2019; donde fileref es un nombre sas que har\u00e1 referencia a un archivo y nombre-archivo es el nombre de un archivo f\u00edsico externo que incluye tanto la ruta como el nombre con su extensi\u00f3n. Por ejemplo la siguiente sentencia asigna con el nombre archivo al archivo \u201cdatos\u201d almacenados en formato .dat que est\u00e1n en la carpeta proyectos. FILENAME archivo \"C:\\Users\\Usuario\\Documents\\Proyectos\\datos.dat\"; Tambi\u00e9n ser\u00e1 necesario usar la sentencia INFILE . Esta sentencia le da las espeficicaciones a SAS sobre c\u00f3mo leer archivos externos. Para una mayor referencia consulte la sentencia INPUT . Lectura de un archivo de ancho fijo \u00b6 En ocasiones se tienen los datos almacenados en formato de texto pero los datos estan alineados de tal forma que es posible saber en que posici\u00f3n inicia cada variable. El ejemplo anterior muestra un ejemplo de un archivo de texto de ancho fijo, obs\u00e9rvese que el id comienza en la columna 1 mientras que el nombre inicia en la columna 8. El siguiente c\u00f3digo muestra c\u00f3mo leer datos de un archivo de ancho fijo. DATA VENTAS; INFILE ARCHIVO; INPUT ID 1 - 7 NOMBRE $ 8 - 18 APELLIDO $ 19-33 POSICION $ 34 - 53 VOLUMEN 54 - 60 PAIS $ 61-62; RUN; La diferencia con ejemplos anteriores es la sentencia INFILE . Esta sentencia especifica que se va leer un archivo externo y se usa junto con la sentencia INPUT . En la sentencia INPUT se declaran las variables que va a contener el dataset VENTAS . SAS leer\u00e1 el archivo l\u00ednea por l\u00ednea y almacenar\u00e1 los valores que encuentre en la variable declarada seg\u00fan la posici\u00f3n indicada, por ejemplo los valores que encuentre de la l\u00ednea 1 a la 7 se guardar\u00e1n en la variable ID , mientras que los valores de la columna 8 a la 18 se almacenar\u00e1n en la variable NOMBRE , n\u00f3tese que despu\u00e9s de NOMBRE hay un signo de pesos, esto es para indicar que la variable es de tipo caracter. Cuidado con las posiciones de columna Se debe ser muy cuidadoso al especificar la posici\u00f3n de las columnas para no mezclar los valores. En el ejemplo anterior, si se hubiera declarado VOLUMEN 54 - 61 , SAS hubiera considerado la columna 61 y nos mostrar\u00eda un mensaje en el log: Debido a que la columna 61 contiene a la letra A, SAS estar\u00eda almacenando una cadena en una variable num\u00e9rica, por lo que lo que nos mostrar\u00eda el error y finalmente le asignar\u00eda un valor missing a volumen . Una forma alternativa de declarar las variables en la sentencia ser\u00eda usar el siguiente c\u00f3digo: DATA VENTAS; INFILE ARCHIVO; INPUT ID NOMBRE $10. APELLIDO $ 19-33 POSICION $ 34 - 53 VOLUMEN PAIS $3.; RUN; Note que en la sentencia INPUT se declaran a las variables de tipo caracter de dos formas: por posici\u00f3n (ejemplo APELLIDO $ 19-33 ) y por formato (ejemplo NOMBRE $10. ). Para una mayor referencia consulte leyendo datos en bruto en la documentaci\u00f3n de SAS. Lectura de un archivo de texto delimitado \u00b6 El delimitador predeterminado es un espacio en blanco. Sin embargo, los archivos de texto delimitados por otros caracteres (por ejemplo una coma, tabulador, o s\u00edmbolos especiales) tambien pueden ser le\u00eddos por SAS. Para especificar el tipo de delimitador, se utiliza la opci\u00f3n DLM = en la sentencia INFILE . Considere el siguiente archivo de texto. Puede notarse que est\u00e1 delimitado por el caracter \u201c/\u201d y adem\u00e1s tiene datos perdidos (resaltados en amarillo). De hecho, los valores perdidos al final de la l\u00ednea podr\u00edan hacer que SAS terminara antes de leer los datos. El siguiente c\u00f3digo puede ser usado para leer esos datos. DATA gerentes; INFILE ARCHIVO DLM = \"/\" DSD TRUNCOVER; ATTRIB id label = \"ID gerente\" nombre LENGTH = $12 LABEL = \"Nombre\" apellido LENGTH = $18 LABEL = \"Apellido\" genero LENGTH = $2 LABEL = \"G\u00e9nero\" ventas LABEL = \"Ventas totales\" posicion LENGTH = $18 LABEL = \"Posici\u00f3n\" pais LENGTH = $2 LABEL = \"Pa\u00eds\" fnac INFORMAT = date12. FORMAT = ddmmyy10. LABEL = \"Fecha de nacimiento\" fingreso INFORMAT = anydtdte12. FORMAT = ddmmyy10. LABEL = \"Fecha de ingreso\" ; INPUT id -- fingreso; RUN; La opci\u00f3n DSD es \u00fatil cuando hay un valor faltante en datos delimitados, de otra forma SAS no reconocer\u00eda dos delimitadores juntos y no leer\u00eda los datos correctamente. La opci\u00f3n MISSOVER evita que SAS salte a una nueva linea cuando no encuentra valores v\u00e1lidos y asigna valores faltantes a las variables que no encuentre. TRUNCOVER funciona de manera similar a MISSOVER pero la diferencia radica en que asignar\u00eda los valores que encuentre pasando el fin de l\u00ednea. Leyendo archivos desde web \u00b6 Para leer datos desde internet (usualmente en formato csv) se debe especificar el nombre del archivo con la sentencia FILENAME con la opci\u00f3n URL . FILENAME fileref URL \u2018 nombre-archivo \u2018 < opciones-url > ; Un ejemplo para descargar datos de covid se encuentran en el siguiente programa de sas: datos_covid_web.sas . Consulte la documentaci\u00f3n de la sentencia FILENAME con el m\u00e9todo de acceso URL para m\u00e1s informaci\u00f3n. Selecci\u00f3n de observaciones \u00b6 Es posible seleccionar las observaciones que se quieren escribir en un dataset, sobre todo aquellas que cumplan ciertas condiciones . Al igual que otros lenguajes de programaci\u00f3n SAS tiene expresiones l\u00f3gicas que eval\u00faan cierta condici\u00f3n. La sintaxis es la siguiente: IF expresi\u00f3n ; Esta sentencia nos permite continuar procesando aquellas observaciones que cumplen la condici\u00f3n, generalmente de comparaci\u00f3n. Una expresi\u00f3n puede ser el nombre de una varible y puede contener alg\u00fan operador l\u00f3gico y un operando. Pueden conectarse mediante conectores l\u00f3gicos, comunmente llamados booleanos. La siguiente tabla resume algunos operadores l\u00f3gicos y conectores. S\u00edmbolo Descripci\u00f3n Ejemplo = o EQ IGUAL A sex EQ \"F\" ^= o \u00ac= o ~= o NE NO IGUAL A sex NE \"F\" > o GT MAYOR QUE age GT 13 < o LT MENOR QUE age LT 13 >= o GE MAYOR O IGUAL A age GE 14 <= o LE MENOR QUE O IGUAL A age LE 14 IN (EST\u00c1) EN age in (12 14 15) o sex in (\"F\" \"M\") & o AND Y sex EQ \"F\" AND age GT 13 ! o OR o O sex EQ \"F\" OR age GT 13 ~ o ^ o \u00ac o NOT NO NOT(sex EQ \"F\" OR age GT 13) Por ejemplo el siguiente c\u00f3digo solo contendr\u00eda a empleados de Australia. DATA VENTAS_AU; INFILE ARCHIVO; IF PAIS EQ \"AU\"; INPUT ID 1 - 7 NOMBRE $ 8 - 18 APELLIDO $ 19-33 POSICION $ 34 - 53 VOLUMEN 54 - 60 PAIS $ 61-62; RUN; Para elegir observaciones que no sean nulas, se puede usar la siguiente sentencia. DATA VENTAS_AU; INFILE ARCHIVO; IF VOLUMEN; INPUT ID 1 - 7 NOMBRE $ 8 - 18 APELLIDO $ 19-33 POSICION $ 34 - 53 VOLUMEN 54 - 60 PAIS $ 61-62; RUN; Usando un procedimiento para leer datos externos \u00b6 La forma m\u00e1s f\u00e1cil de leer archivos externos es mediante el procedimiento IMPORT . PROC IMPORT DATAFILE = \u201cfilename\u201d OUT = dataset; Este procedimiento no solo lee archivos de texto, sino tambien de Excel, SPSS, Stata e incluso tablas de Access. Para una mayor referencia vea el procedimiento IMPORT . El siguiente c\u00f3digo leer\u00e1 un archivo en formato excel. PROC IMPORT OUT = WORK.censo DATAFILE = \"C:\\Users\\Usuario\\census.xlsx\" DBMS = XLSX REPLACE; RUN; N\u00f3tese que se ha especificado la opci\u00f3n DBMS = XLSX para que sas utilice los par\u00e1metros correspondientes para leer un archivo de excel. La opci\u00f3n REPLACE reemplazar\u00eda el dataset que tuviera el mismo nombre, de otro modo SAS mostrar\u00eda un error y no crear\u00eda el dataset. El siguiente c\u00f3digo muestra c\u00f3mo leer un archivo en formato csv. PROC IMPORT OUT = WORK.census DATAFILE = \"C:\\Users\\Usuario\\census.csv\" DBMS = CSV REPLACE; GETNAMES = YES; DATAROW = 2; RUN; En el caso de archivos csv, hay dos sentencias adicionales, la sentencia GETNAMES = YES indica si los nombres de las variables se encuentran al inicio del archivo de texto, mientras que la sentencia DATAROW = 2 indica que los valores incian en el rengl\u00f3n 2. Escritura a un archivo externo \u00b6 SAS tambien puede ser utlizado para escribir archivos externos. En esta secci\u00f3n se mostrar\u00e1 como crear archivos de texto, asi como escribir mensaje del log a archivos externos. Escritura de un archivo delimitado \u00b6 El siguiente c\u00f3digo muestra como crear un archivo de texto. FILENAME archivo \"C:\\Users\\Usuario\\alumnos.dat\"; DATA _NULL_; FILE archivo; SET sashelp.class; PUT name age sex; RUN; Como se puede ver, se ha referenciado con la sentencia FILENAME el archivo con el nombre que en el que se desea escribir. N\u00f3tese que en la sentencia DATA se ha especificado _NULL_ , una palabra reservada para pedir que no cree ning\u00fan dataset. La sentencia FILE da las especificaciones para escribir los archivos de texto. Es muy similar a la sentencia INFILE , para mayor referencia consulte la sentencia FILE . Finalmente, la sentencia PUT indica lo que se va a escribir en el archivo externo, en este caso se especifican la variables de inter\u00e9s. Para una mayor referencia consulte la sentencia PUT . Archivos delimitados por un caracter SAS crea archivos delimitados por un espacio en blanco. Para crear un archivo delimitado por otro caracter (por ejemplo una coma) se puede usar la opci\u00f3n DLM = . Tambien se puede modificar la extensi\u00f3n del archivo con la sentencia FILENAME . El resultado ser\u00eda el siguiente. Escritura de un archivo de texto de ancho fijo \u00b6 Para crear un archivo de texto de ancho fijo, se puede especificar las posiciones en las que se escribiran las observaciones. FILENAME archivo \"C:\\Users\\Usuario\\alumnos.txt\"; DATA _NULL_; FILE archivo; SET sashelp.class; PUT name $8. sex 10-12 age 2. height 16-20 weight 22-25; RUN; N\u00f3tese que se han especificado los formatos de las variables y las columnas en las que se desea escribir el archivo, es algo muy similar cuando se le\u00edan los archivos con la sentencia INPUT . Crear archivos con encabezados \u00b6 Debido a que sas escribe directamente al archivo, es un poco complicado especificarle que en el rengl\u00f3n 1 escriba el nombre de las variables. Sin embargo, el siguiente c\u00f3digo logra especificar el nombre de los archivos en la primer l\u00ednea. FILENAME archivo \"C:\\Users\\Usuario\\alumnos.txt\"; DATA _NULL_; FILE archivo; IF _n_ EQ 1 THEN PUT \"name \" \"sex \" \"age \" \"height \" \"weight \"; SET sashelp.class; PUT name -- weight; RUN; Esto se logra escribiendo la sentencia PUT justo al inicio e inmediatamente despues se carga el dataset que se quiere escribir. Las sentencias de la l\u00ednea 4 se estudiar\u00e1n en la secci\u00f3n filtrado de datos Leer y modificar archivos de texto \u00b6 Es posible manipular archivos de texto mediante SAS. para ellos es necesario leerlos y volver a escribir sobre ellos. El siguiente c\u00f3digo muestra como actualizar ciertas variables. FILENAME ARCHIVO \"C:\\Users\\Usuario\\alumnos.txt\"; DATA _NULL_; INFILE archivo SHAREBUFFERS FIRSTOBS = 2 TRUNCOVER; ATTRIB sex LENGTH = $1 sex2 LENGTH = $1; INPUT sex $ 9; IF sex = \"F\" THEN sex2 = \"M\"; IF sex = \"M\" THEN sex2 = \"H\"; FILE archivo TRUNCOVER PAD; PUT sex2 9 ; RUN; Note que se la sentencia LIBNAME apunta al mismo archivo que se est\u00e1 usando en las sentencias INFILE y FILE . La opci\u00f3n SHAREBUFFERS es \u00fatil para actualizar un archivo externo y solo actualiza ciertos campos. Esta opci\u00f3n se usa junto con las sentencias INFILE , FILE y PUT . La variable sex2 se usa para guardar el valor que se va a escribir en el archivo cuando sex toma cierto valor. Cuidado con las longitudes Se debe tener cuidado cuando se actualiza un archivo de texto. Se debe procurar que la variable que se lee como la que se escribe tengan la misma longitud, de otro modo pueden haber resultados inesperados. El resultado se muestra a continuaci\u00f3n Escritura de datos con el procedimiento EXPORT \u00b6 As\u00ed como es posible leer datos de forma externa con un procedimiento, tambien hay uno para escribir datos a archivos externos. La sintaxis es muy similar. PROC EXPORT OUTFILE = \u201cfilename\u201d DATA = dataset; El siguiente c\u00f3digo muestra la forma de escribir un dataset a un archivo csv. PROC EXPORT DATA= SASHELP.Class OUTFILE= \"C:\\Users\\Usuario\\alumnos.csv\" DBMS = CSV REPLACE; RUN; Para mayores referencias consulte el procedimiento EXPORT .","title":"Lectura y escritura de datos"},{"location":"sas/basico_sas/#lectura-de-datos","text":"Los dataset son el insumo principal para analisis de datos en SAS, por ello iniciaremos con una r\u00e1pida exploraci\u00f3n. En esta secci\u00f3n se presentan temas para comenzar con la lectura y escritura de datos. Se explorar\u00e1n distintas formas de leer y escribir datos de distintas fuentes y formatos de archivo. La creaci\u00f3n de un dataset inicia con un bloque DATA y termina con un RUN . Sin embargo, aprenderemos el uso b\u00e1sico de un procedimiento para leer datos de fuentes externas.","title":"Lectura de datos"},{"location":"sas/basico_sas/#creando-datasets","text":"En esta secci\u00f3n se mostrar\u00e1n las principales formas de crear datasets: Introducci\u00f3n de forma manual Leyendo un archivo de texto externo El uso de PROC IMPORT Se mostrar\u00e1n las ideas y algunos ejemplos.","title":"Creando datasets"},{"location":"sas/basico_sas/#introduccion-de-valores-de-forma-manual","text":"La forma m\u00e1s f\u00e1cil de crear un dataset, es con el uso de la sentencia INPUT y DATALINES con el fin de introducir valores manualmente. Estos datos fueron copiados y pegados directamente de una hoja de excel. El siguiente ejemplo muestra como introducir datos manualmente. DATA EMPLEADOS(LABEL = \"Registro de empleados nuevos\"); ATTRIB NOMBRE LENGTH = $16 LABEL = \"Nombre\" APELLIDO LENGTH = $12 LABEL = \"Apellido\" ID LABEL = \"ID empleado\" GENERO LENGTH = $1. LABEL = \"G\u00e9nero\" FNAC INFORMAT = DDMMYY10. FORMAT = DATE10. LABEL = \"Fecha de nacimiento\" ; INPUT NOMBRE -- FNAC; DATALINES; Bill Cuddy 11171 M 16/10/1986 Susan Krasowski 17023 F 09/07/1959 Andreas Rennie 26148 M 18/07/1934 Lauren Krasowski 46966 F 24/10/1986 Lauren Marx 54655 F 18/08/1969 Tommy Mcdonald 70046 M 20/01/1959 Colin Byarley 70059 M 20/01/1934 Lera Knott 70079 F 11/07/1986 Wilma Yeargan 70100 F 23/06/1984 Patrick Leach 70108 M 14/04/1939 Portia Reynoso 70165 F 11/02/1964 Soberina Berent 70187 F 27/09/1986 Angel Borwick 70201 F 19/12/1969 Alex Santinello 70210 M 22/04/1986 Kenan Talarr 70221 M 10/02/1964 ; RUN; La sentencia DATA especifica el nombre del dataset y entre parentesis est\u00e1n las opciones del dataset, en este caso el dataset empleados tendr\u00e1 una etiqueta para identificarlo. Es recomendable especificar las propiedades de las variables a crear mediante la sentencia ATTRIB en donde se especifican sus propiedades. Declaraci\u00f3n de variables Otra forma de declarar variables es mediante las sentencias LENGTH y FORMAT . Consulte la documentaci\u00f3n para m\u00e1s informaci\u00f3n. N\u00f3tese que para el caso de las variables de tipo caracter se hace uso de la opci\u00f3n LENGTH = seguido del signo de pesos para indicar que es de tipo caracter y la longitud deseada. Para el caso de variables num\u00e9ricas, se debe especificar al menos un atributo, en este caso se recomienda especificar el atributo LABEL = . En el caso de la variable fnac los datos estan almacenados en formato de fecha (ddmmyyyy) por lo que se usa el informato ddmmyy10. para que lo reconozca como fehca de sas, pero se desea visualizar con el formato de fecha (ddmmmyyyy). La sentencia INPUT sirve para indicar el nombre de las variables del dataset. Se puede poner el s\u00edmbolo $ para indicar que la variable es de tipo caracter. Sin embargo en este caso, como ya se han declarado las variables se puede usar una lista, es decir, solo poner el nombre de la primer variable declarada seguido de dos guiones -- y el nombre de la \u00faltima. La sentencia DATALINES indica el inicio de los datos y finaliza con un punto y coma. Con la sentencia RUN se cierra el bloque de instrucciones y comienza a ejecutar el proceso.","title":"Introducci\u00f3n de valores de forma manual"},{"location":"sas/basico_sas/#lectura-de-datos-desde-un-archivo-externo","text":"SAS puede leer datos de archivos de texto almacenados en distintos formatos, por ejemplo de ancho fijo o delimitados. Para acceder a ellos es necesario usar la referencia para apuntar a ellos, algo similar a la declaraci\u00f3n de las librer\u00edas. Se puede hacer mediante la sentencia FILENAME : FILENAME fileref \u2018 nombre-archivo \u2019; donde fileref es un nombre sas que har\u00e1 referencia a un archivo y nombre-archivo es el nombre de un archivo f\u00edsico externo que incluye tanto la ruta como el nombre con su extensi\u00f3n. Por ejemplo la siguiente sentencia asigna con el nombre archivo al archivo \u201cdatos\u201d almacenados en formato .dat que est\u00e1n en la carpeta proyectos. FILENAME archivo \"C:\\Users\\Usuario\\Documents\\Proyectos\\datos.dat\"; Tambi\u00e9n ser\u00e1 necesario usar la sentencia INFILE . Esta sentencia le da las espeficicaciones a SAS sobre c\u00f3mo leer archivos externos. Para una mayor referencia consulte la sentencia INPUT .","title":"Lectura de datos desde un archivo externo"},{"location":"sas/basico_sas/#lectura-de-un-archivo-de-ancho-fijo","text":"En ocasiones se tienen los datos almacenados en formato de texto pero los datos estan alineados de tal forma que es posible saber en que posici\u00f3n inicia cada variable. El ejemplo anterior muestra un ejemplo de un archivo de texto de ancho fijo, obs\u00e9rvese que el id comienza en la columna 1 mientras que el nombre inicia en la columna 8. El siguiente c\u00f3digo muestra c\u00f3mo leer datos de un archivo de ancho fijo. DATA VENTAS; INFILE ARCHIVO; INPUT ID 1 - 7 NOMBRE $ 8 - 18 APELLIDO $ 19-33 POSICION $ 34 - 53 VOLUMEN 54 - 60 PAIS $ 61-62; RUN; La diferencia con ejemplos anteriores es la sentencia INFILE . Esta sentencia especifica que se va leer un archivo externo y se usa junto con la sentencia INPUT . En la sentencia INPUT se declaran las variables que va a contener el dataset VENTAS . SAS leer\u00e1 el archivo l\u00ednea por l\u00ednea y almacenar\u00e1 los valores que encuentre en la variable declarada seg\u00fan la posici\u00f3n indicada, por ejemplo los valores que encuentre de la l\u00ednea 1 a la 7 se guardar\u00e1n en la variable ID , mientras que los valores de la columna 8 a la 18 se almacenar\u00e1n en la variable NOMBRE , n\u00f3tese que despu\u00e9s de NOMBRE hay un signo de pesos, esto es para indicar que la variable es de tipo caracter. Cuidado con las posiciones de columna Se debe ser muy cuidadoso al especificar la posici\u00f3n de las columnas para no mezclar los valores. En el ejemplo anterior, si se hubiera declarado VOLUMEN 54 - 61 , SAS hubiera considerado la columna 61 y nos mostrar\u00eda un mensaje en el log: Debido a que la columna 61 contiene a la letra A, SAS estar\u00eda almacenando una cadena en una variable num\u00e9rica, por lo que lo que nos mostrar\u00eda el error y finalmente le asignar\u00eda un valor missing a volumen . Una forma alternativa de declarar las variables en la sentencia ser\u00eda usar el siguiente c\u00f3digo: DATA VENTAS; INFILE ARCHIVO; INPUT ID NOMBRE $10. APELLIDO $ 19-33 POSICION $ 34 - 53 VOLUMEN PAIS $3.; RUN; Note que en la sentencia INPUT se declaran a las variables de tipo caracter de dos formas: por posici\u00f3n (ejemplo APELLIDO $ 19-33 ) y por formato (ejemplo NOMBRE $10. ). Para una mayor referencia consulte leyendo datos en bruto en la documentaci\u00f3n de SAS.","title":"Lectura de un archivo de ancho fijo"},{"location":"sas/basico_sas/#lectura-de-un-archivo-de-texto-delimitado","text":"El delimitador predeterminado es un espacio en blanco. Sin embargo, los archivos de texto delimitados por otros caracteres (por ejemplo una coma, tabulador, o s\u00edmbolos especiales) tambien pueden ser le\u00eddos por SAS. Para especificar el tipo de delimitador, se utiliza la opci\u00f3n DLM = en la sentencia INFILE . Considere el siguiente archivo de texto. Puede notarse que est\u00e1 delimitado por el caracter \u201c/\u201d y adem\u00e1s tiene datos perdidos (resaltados en amarillo). De hecho, los valores perdidos al final de la l\u00ednea podr\u00edan hacer que SAS terminara antes de leer los datos. El siguiente c\u00f3digo puede ser usado para leer esos datos. DATA gerentes; INFILE ARCHIVO DLM = \"/\" DSD TRUNCOVER; ATTRIB id label = \"ID gerente\" nombre LENGTH = $12 LABEL = \"Nombre\" apellido LENGTH = $18 LABEL = \"Apellido\" genero LENGTH = $2 LABEL = \"G\u00e9nero\" ventas LABEL = \"Ventas totales\" posicion LENGTH = $18 LABEL = \"Posici\u00f3n\" pais LENGTH = $2 LABEL = \"Pa\u00eds\" fnac INFORMAT = date12. FORMAT = ddmmyy10. LABEL = \"Fecha de nacimiento\" fingreso INFORMAT = anydtdte12. FORMAT = ddmmyy10. LABEL = \"Fecha de ingreso\" ; INPUT id -- fingreso; RUN; La opci\u00f3n DSD es \u00fatil cuando hay un valor faltante en datos delimitados, de otra forma SAS no reconocer\u00eda dos delimitadores juntos y no leer\u00eda los datos correctamente. La opci\u00f3n MISSOVER evita que SAS salte a una nueva linea cuando no encuentra valores v\u00e1lidos y asigna valores faltantes a las variables que no encuentre. TRUNCOVER funciona de manera similar a MISSOVER pero la diferencia radica en que asignar\u00eda los valores que encuentre pasando el fin de l\u00ednea.","title":"Lectura de un archivo de texto delimitado"},{"location":"sas/basico_sas/#leyendo-archivos-desde-web","text":"Para leer datos desde internet (usualmente en formato csv) se debe especificar el nombre del archivo con la sentencia FILENAME con la opci\u00f3n URL . FILENAME fileref URL \u2018 nombre-archivo \u2018 < opciones-url > ; Un ejemplo para descargar datos de covid se encuentran en el siguiente programa de sas: datos_covid_web.sas . Consulte la documentaci\u00f3n de la sentencia FILENAME con el m\u00e9todo de acceso URL para m\u00e1s informaci\u00f3n.","title":"Leyendo archivos desde web"},{"location":"sas/basico_sas/#seleccion-de-observaciones","text":"Es posible seleccionar las observaciones que se quieren escribir en un dataset, sobre todo aquellas que cumplan ciertas condiciones . Al igual que otros lenguajes de programaci\u00f3n SAS tiene expresiones l\u00f3gicas que eval\u00faan cierta condici\u00f3n. La sintaxis es la siguiente: IF expresi\u00f3n ; Esta sentencia nos permite continuar procesando aquellas observaciones que cumplen la condici\u00f3n, generalmente de comparaci\u00f3n. Una expresi\u00f3n puede ser el nombre de una varible y puede contener alg\u00fan operador l\u00f3gico y un operando. Pueden conectarse mediante conectores l\u00f3gicos, comunmente llamados booleanos. La siguiente tabla resume algunos operadores l\u00f3gicos y conectores. S\u00edmbolo Descripci\u00f3n Ejemplo = o EQ IGUAL A sex EQ \"F\" ^= o \u00ac= o ~= o NE NO IGUAL A sex NE \"F\" > o GT MAYOR QUE age GT 13 < o LT MENOR QUE age LT 13 >= o GE MAYOR O IGUAL A age GE 14 <= o LE MENOR QUE O IGUAL A age LE 14 IN (EST\u00c1) EN age in (12 14 15) o sex in (\"F\" \"M\") & o AND Y sex EQ \"F\" AND age GT 13 ! o OR o O sex EQ \"F\" OR age GT 13 ~ o ^ o \u00ac o NOT NO NOT(sex EQ \"F\" OR age GT 13) Por ejemplo el siguiente c\u00f3digo solo contendr\u00eda a empleados de Australia. DATA VENTAS_AU; INFILE ARCHIVO; IF PAIS EQ \"AU\"; INPUT ID 1 - 7 NOMBRE $ 8 - 18 APELLIDO $ 19-33 POSICION $ 34 - 53 VOLUMEN 54 - 60 PAIS $ 61-62; RUN; Para elegir observaciones que no sean nulas, se puede usar la siguiente sentencia. DATA VENTAS_AU; INFILE ARCHIVO; IF VOLUMEN; INPUT ID 1 - 7 NOMBRE $ 8 - 18 APELLIDO $ 19-33 POSICION $ 34 - 53 VOLUMEN 54 - 60 PAIS $ 61-62; RUN;","title":"Selecci\u00f3n de observaciones"},{"location":"sas/basico_sas/#usando-un-procedimiento-para-leer-datos-externos","text":"La forma m\u00e1s f\u00e1cil de leer archivos externos es mediante el procedimiento IMPORT . PROC IMPORT DATAFILE = \u201cfilename\u201d OUT = dataset; Este procedimiento no solo lee archivos de texto, sino tambien de Excel, SPSS, Stata e incluso tablas de Access. Para una mayor referencia vea el procedimiento IMPORT . El siguiente c\u00f3digo leer\u00e1 un archivo en formato excel. PROC IMPORT OUT = WORK.censo DATAFILE = \"C:\\Users\\Usuario\\census.xlsx\" DBMS = XLSX REPLACE; RUN; N\u00f3tese que se ha especificado la opci\u00f3n DBMS = XLSX para que sas utilice los par\u00e1metros correspondientes para leer un archivo de excel. La opci\u00f3n REPLACE reemplazar\u00eda el dataset que tuviera el mismo nombre, de otro modo SAS mostrar\u00eda un error y no crear\u00eda el dataset. El siguiente c\u00f3digo muestra c\u00f3mo leer un archivo en formato csv. PROC IMPORT OUT = WORK.census DATAFILE = \"C:\\Users\\Usuario\\census.csv\" DBMS = CSV REPLACE; GETNAMES = YES; DATAROW = 2; RUN; En el caso de archivos csv, hay dos sentencias adicionales, la sentencia GETNAMES = YES indica si los nombres de las variables se encuentran al inicio del archivo de texto, mientras que la sentencia DATAROW = 2 indica que los valores incian en el rengl\u00f3n 2.","title":"Usando un procedimiento para leer datos externos"},{"location":"sas/basico_sas/#escritura-a-un-archivo-externo","text":"SAS tambien puede ser utlizado para escribir archivos externos. En esta secci\u00f3n se mostrar\u00e1 como crear archivos de texto, asi como escribir mensaje del log a archivos externos.","title":"Escritura a un archivo externo"},{"location":"sas/basico_sas/#escritura-de-un-archivo-delimitado","text":"El siguiente c\u00f3digo muestra como crear un archivo de texto. FILENAME archivo \"C:\\Users\\Usuario\\alumnos.dat\"; DATA _NULL_; FILE archivo; SET sashelp.class; PUT name age sex; RUN; Como se puede ver, se ha referenciado con la sentencia FILENAME el archivo con el nombre que en el que se desea escribir. N\u00f3tese que en la sentencia DATA se ha especificado _NULL_ , una palabra reservada para pedir que no cree ning\u00fan dataset. La sentencia FILE da las especificaciones para escribir los archivos de texto. Es muy similar a la sentencia INFILE , para mayor referencia consulte la sentencia FILE . Finalmente, la sentencia PUT indica lo que se va a escribir en el archivo externo, en este caso se especifican la variables de inter\u00e9s. Para una mayor referencia consulte la sentencia PUT . Archivos delimitados por un caracter SAS crea archivos delimitados por un espacio en blanco. Para crear un archivo delimitado por otro caracter (por ejemplo una coma) se puede usar la opci\u00f3n DLM = . Tambien se puede modificar la extensi\u00f3n del archivo con la sentencia FILENAME . El resultado ser\u00eda el siguiente.","title":"Escritura de un archivo delimitado"},{"location":"sas/basico_sas/#escritura-de-un-archivo-de-texto-de-ancho-fijo","text":"Para crear un archivo de texto de ancho fijo, se puede especificar las posiciones en las que se escribiran las observaciones. FILENAME archivo \"C:\\Users\\Usuario\\alumnos.txt\"; DATA _NULL_; FILE archivo; SET sashelp.class; PUT name $8. sex 10-12 age 2. height 16-20 weight 22-25; RUN; N\u00f3tese que se han especificado los formatos de las variables y las columnas en las que se desea escribir el archivo, es algo muy similar cuando se le\u00edan los archivos con la sentencia INPUT .","title":"Escritura de un archivo de texto de ancho fijo"},{"location":"sas/basico_sas/#crear-archivos-con-encabezados","text":"Debido a que sas escribe directamente al archivo, es un poco complicado especificarle que en el rengl\u00f3n 1 escriba el nombre de las variables. Sin embargo, el siguiente c\u00f3digo logra especificar el nombre de los archivos en la primer l\u00ednea. FILENAME archivo \"C:\\Users\\Usuario\\alumnos.txt\"; DATA _NULL_; FILE archivo; IF _n_ EQ 1 THEN PUT \"name \" \"sex \" \"age \" \"height \" \"weight \"; SET sashelp.class; PUT name -- weight; RUN; Esto se logra escribiendo la sentencia PUT justo al inicio e inmediatamente despues se carga el dataset que se quiere escribir. Las sentencias de la l\u00ednea 4 se estudiar\u00e1n en la secci\u00f3n filtrado de datos","title":"Crear archivos con encabezados"},{"location":"sas/basico_sas/#leer-y-modificar-archivos-de-texto","text":"Es posible manipular archivos de texto mediante SAS. para ellos es necesario leerlos y volver a escribir sobre ellos. El siguiente c\u00f3digo muestra como actualizar ciertas variables. FILENAME ARCHIVO \"C:\\Users\\Usuario\\alumnos.txt\"; DATA _NULL_; INFILE archivo SHAREBUFFERS FIRSTOBS = 2 TRUNCOVER; ATTRIB sex LENGTH = $1 sex2 LENGTH = $1; INPUT sex $ 9; IF sex = \"F\" THEN sex2 = \"M\"; IF sex = \"M\" THEN sex2 = \"H\"; FILE archivo TRUNCOVER PAD; PUT sex2 9 ; RUN; Note que se la sentencia LIBNAME apunta al mismo archivo que se est\u00e1 usando en las sentencias INFILE y FILE . La opci\u00f3n SHAREBUFFERS es \u00fatil para actualizar un archivo externo y solo actualiza ciertos campos. Esta opci\u00f3n se usa junto con las sentencias INFILE , FILE y PUT . La variable sex2 se usa para guardar el valor que se va a escribir en el archivo cuando sex toma cierto valor. Cuidado con las longitudes Se debe tener cuidado cuando se actualiza un archivo de texto. Se debe procurar que la variable que se lee como la que se escribe tengan la misma longitud, de otro modo pueden haber resultados inesperados. El resultado se muestra a continuaci\u00f3n","title":"Leer y modificar archivos de texto"},{"location":"sas/basico_sas/#escritura-de-datos-con-el-procedimiento-export","text":"As\u00ed como es posible leer datos de forma externa con un procedimiento, tambien hay uno para escribir datos a archivos externos. La sintaxis es muy similar. PROC EXPORT OUTFILE = \u201cfilename\u201d DATA = dataset; El siguiente c\u00f3digo muestra la forma de escribir un dataset a un archivo csv. PROC EXPORT DATA= SASHELP.Class OUTFILE= \"C:\\Users\\Usuario\\alumnos.csv\" DBMS = CSV REPLACE; RUN; Para mayores referencias consulte el procedimiento EXPORT .","title":"Escritura de datos con el procedimiento EXPORT"},{"location":"sas/intro_sas/","text":"Elementos esenciales \u00b6 Este es un tutorial breve sobre el programa, se muestran los principales conceptos de SAS para iniciarse en SAS. En esta secci\u00f3n se aprender\u00e1n los principios sobre los cuales se basa SAS, as\u00ed como algunas definiciones importantes como datasets o librer\u00edas. Finalmente se muestran algunas pinceladas de lo que se puede hacer con SAS mediante el uso lenguaje m\u00e1s avanzado. Instalaci\u00f3n e interfaces gr\u00e1ficas \u00b6 Consulte el sitio web de sas para m\u00e1s detalles. SAS University Edition SAS no es software libre ni es gratuito, sin embargo usted puede descargar el software gratuitamente. Visite SAS University edition para m\u00e1s informaci\u00f3n. SAS BASE es la interfaz gr\u00e1fica cl\u00e1sica de SAS. Contiene una verntana lateral con una lista de librer\u00edas, mientras que hay una ventana principal de mensajes (log) y otra para escribir c\u00f3digo. Esta interfaz fue de las primeras en desarrollarse y por ello ya no ha sido mejorada por lo que podr\u00eda carecer de nuevas caracter\u00edsticas. Su principal ventaja es que gasta pocos recurso y es bastante r\u00e1pida. SAS Enterprise Guide es la interfaz gr\u00e1fica mas reciente y es constantemente mejorada. Esta versi\u00f3n tiene muchas caracter\u00edsticas y adem\u00e1s permite crear distintos perfiles de usuario. Tiene un panel principal en el cual se muestra el flujo de trabajo. La idea b\u00e1sica es ir trabajando en peque\u00f1os programas y se conectan entre s\u00ed, con el fin de tener una visi\u00f3n m\u00e1s global de lo que se est\u00e1 realizando Conceptos b\u00e1sicos \u00b6 En esta secci\u00f3n se mostrar\u00e1n Procedimientos y pasos DATA \u00b6 SAS se compone de dos grandes bloques: el paso DATA y el paso PROC. El bloque DATA sirve para leer o generar datos, mientras que el bloque PROC generalmente sirve para analizar dichos datos, aunque hay muchos procedimientos. Este sencillo ejemplo muestra el flujo general de los programas de sas. Primero se crear\u00e1 un dataset con el bloque de instrucciones DATA. DATA calificaciones; INPUT nombre $ Grupo $ puntaje; DATALINES; ANGELICA A 10 BRENDA A 9 MARCO B 8 LILIANA B 8 FABIAN C 9 MAURICIO C 7 ; RUN; SAS no muestra directamente los resultados, en su lugar, se escribe un mensaje en la ventana de log. Para visualizar el dataset creado, se debe ejecutar el siguiente c\u00f3digo, que constituye el paso PROC: PROC PRINT DATA = calificaciones; RUN; El resultado se muestra a continuaci\u00f3n Aunque se ha producido un resultado, nuevamente aparece un mensaje en la ventana del log: En el log aparecen las instrucciones que se ejecutaron, seguido de un mensaje indicando que los resultados se estan escribiendo en un archivo html. Finalmente en el log se nos indica el n\u00famero de observaciones le\u00eddas y el tiempo de ejecuci\u00f3n del procedimiento. Como puede verse, el log siempre est\u00e1 activo y registra todas las acciones ejecutadas. Posteriormente se ver\u00e1n como nos puede ayudar a encontrar errores y nos apoyar\u00e1 en la resoluci\u00f3n de estos. Datasets \u00b6 SAS almacena los datos en tablas llamadas datasets, los cuales son archivos que se almacenan en bibliotecas (library). SAS maneja dos tipos de datos: num\u00e9ricos y caracter. Los dataset permiten almacenar un tipo de dato en cada variable. Para crear un dataset, se utiliza el bloque de instrucciones conocido como paso DATA. El paso DATA inicia con la sentencia DATA seguido del nombre del dataset y termina con la palabra clave RUN. Por ejemplo el siguiente c\u00f3digo crea un dataset con 1 observaci\u00f3n y tres variables (2 num\u00e9ricas y otra caracter). DATA EJEMPLO; FORMAT FECHA DATE.; FECHA = TODAY(); INPUT X GRUPO $; DATALINES; 12.5 azul ; RUN; La primer sentencia define el nombre del dataset. La segunda le asigna un formato de fecha a la variable fecha. Esto a se debe a que internamente SAS almacena el resultado como un valor num\u00e9rico, pero quisieramos visualizarlo como una fecha. En la tercer sentencia se define una variable num\u00e9rica mediante una funci\u00f3n, la cual obtiene la fecha de hoy (n\u00famero de d\u00edas transcurridos desde el 1 de enero de 1960). En la siguiente sentencia se declaran 2 variables que sas va a recibir, la segunda se define como caracter al agregarle el signo $ . La sentencia DATALINES le dice al programa que se introducir\u00e1n valores de manera manual (cada rengl\u00f3n representa la primera observaci\u00f3n y cada variable est\u00e1 separada por un espacio). El punto y coma dicta el fin de la introducci\u00f3n de datos. Finalmente la palabra RUN define el fin del paso DATA. Un dataset consiste de dos partes: Una porci\u00f3n descriptora Una porci\u00f3n de datos La porci\u00f3n de datos es una colecci\u00f3n de datos arreglados en una tabla rectangular. Cada rengl\u00f3n o observaci\u00f3n representa mediciones de un individuo. La porci\u00f3n descriptora de un dataset contiene informaci\u00f3n del descriptor, por ejemplo, el nombre, fecha y hora de creaci\u00f3n, n\u00famero de observaciones y n\u00famero de variables. La porci\u00f3n descriptora tambien contiene informaci\u00f3n de los atributos de cada variable en el dataset. Los atributos contienen informaci\u00f3n como el nombre de la variable, el tipo, longitud, formato, informato y etiqueta. El siguiente cuadro resume los atributos de las variables. Atributo Valor Ejemplo Requerido Nota Nombre Nombre SAS _nombre_alumno2 S\u00ed Hasta 32 car\u00e1cteres, iniciando con _ o una letras, puede contener valores num\u00e9ricos. Tipo char o num num S\u00ed Los valores perdidos (missing) para variables num\u00e9ricas se representan con . o con \"\" para caracter. Longitud Hasta 32,767 bytes para caracter, 8 para variables num\u00e9ricas 8 S\u00ed Las variables num\u00e9ricas se almacenan como valores de punto flotante en 8 bytes de longitud. Formato Nombre de formato date10. No Consulte Formatos de SAS para una referencia completa Informato Nombre de Informato dollar10. No Consulte Informatos de SAS para una referencia completa Etiqueta Una cadena de hasta 256 caracteres \u201cSegundo nombre del alumno\u201d No Algunos procedimientos o reportes usan la etiqueta en lugar del nombre de la variable. Es posible conocer las propiedades de un dataset usando el PROCEDIMIENTO CONTENTS para conocer la porci\u00f3n descriptora de un dataset. El siguiente c\u00f3digo nos muestra c\u00f3mo saber las propiedades de un dataset almacenado en sas. PROC CONTENTS DATA = SASHELP.HEART VARNUM; RUN; El resultado se muestra a continuaci\u00f3n Librer\u00edas \u00b6 Las librer\u00edas o bibliotecas son rutas donde se almacenan los datasets. Librer\u00eda Una librer\u00eda de SAS es una colecci\u00f3n de archivos de SAS. Es el nivel m\u00e1s alto de organizaci\u00f3n para la informaci\u00f3n dentro de SAS. En el sistema operativo Windows o UNIX, una librer\u00eda es t\u00edpicamente un grupo de archivos de SAS en el mismo folder o directorio. Si no se define una librer\u00eda, sas define una librer\u00eda temporal llamada WORK, la cual eliminar\u00e1 todos los datasets al finalizar la sesi\u00f3n. Para definir una librer\u00eda, se puede asignar una librer\u00eda a un ruta de la forma: LIBNAME libref \u2018 sas-library \u2019; donde libref es el nombre de la librer\u00eda (un nombre de sas de 1 a 8 caracteres que inicia con una letra o gui\u00f3n bajo y contiene solo letras, n\u00fameros o gui\u00f3n bajo) y sas-library es la ruta donde se almacenar\u00e1n los dataset, por ejemplo: LIBNAME TAREAS \"C:\\Users\\Default\\Documents\"; asignar\u00eda dicho directorio a la librer\u00eda TAREAS . Para referirse a un dataset almacenado en dicha librer\u00eda, se utiliza el siguiente nombre LIBRARY.DATASET , por ejemplo TAREAS.TABLA . Macros y variables macro \u00b6 Adem\u00e1s de los pasos PROC y DATA, SAS tiene un lenguaje especial llamado lenguaje macro, el cual especie de procesador de instrucciones que compila y ejecuta. Este lenguaje es muy \u00fatil para ejecutar tareas comunes o repetitivas A diferencia de otros lenguajes de programaci\u00f3n, SAS no permite definir variables de forma directa. Sin embargo, es posible definir variables macro , las cuales almacenan un valor ya sea un n\u00famero o un texto. Dichas variables son evaluadas y pueden ser llamadas en cualquier procedimiento macro. Hay tres formas de crear variables macro: Con la sentencia %let . Con la llamada symput() . con la sentencia INTO dentro de un procedimiento SQL. Se usa la sentencia %let macro-variable = <value>; y para mandar llamar el valor de dicha variable maro se usa &macro-variable . Por ejemplo si se desea definir ciertas variables a analizar, se puede crear la siguiente sentencia; %let x = age weight height; PROC MEANS DATA = SASHELP.CLASS; VAR &X; RUN; Para ver el valor de la variable macro, se puede usar la sentencia macro %PUT <&macro-variable> , por ejemplo: %PUT &x; y el resultado ser\u00e1 age weight height Para m\u00e1s informaci\u00f3n acerca de sentencias y variables macro visite la documentaci\u00f3n de SAS .","title":"Introducci\u00f3n a SAS"},{"location":"sas/intro_sas/#elementos-esenciales","text":"Este es un tutorial breve sobre el programa, se muestran los principales conceptos de SAS para iniciarse en SAS. En esta secci\u00f3n se aprender\u00e1n los principios sobre los cuales se basa SAS, as\u00ed como algunas definiciones importantes como datasets o librer\u00edas. Finalmente se muestran algunas pinceladas de lo que se puede hacer con SAS mediante el uso lenguaje m\u00e1s avanzado.","title":"Elementos esenciales"},{"location":"sas/intro_sas/#instalacion-e-interfaces-graficas","text":"Consulte el sitio web de sas para m\u00e1s detalles. SAS University Edition SAS no es software libre ni es gratuito, sin embargo usted puede descargar el software gratuitamente. Visite SAS University edition para m\u00e1s informaci\u00f3n. SAS BASE es la interfaz gr\u00e1fica cl\u00e1sica de SAS. Contiene una verntana lateral con una lista de librer\u00edas, mientras que hay una ventana principal de mensajes (log) y otra para escribir c\u00f3digo. Esta interfaz fue de las primeras en desarrollarse y por ello ya no ha sido mejorada por lo que podr\u00eda carecer de nuevas caracter\u00edsticas. Su principal ventaja es que gasta pocos recurso y es bastante r\u00e1pida. SAS Enterprise Guide es la interfaz gr\u00e1fica mas reciente y es constantemente mejorada. Esta versi\u00f3n tiene muchas caracter\u00edsticas y adem\u00e1s permite crear distintos perfiles de usuario. Tiene un panel principal en el cual se muestra el flujo de trabajo. La idea b\u00e1sica es ir trabajando en peque\u00f1os programas y se conectan entre s\u00ed, con el fin de tener una visi\u00f3n m\u00e1s global de lo que se est\u00e1 realizando","title":"Instalaci\u00f3n e interfaces gr\u00e1ficas"},{"location":"sas/intro_sas/#conceptos-basicos","text":"En esta secci\u00f3n se mostrar\u00e1n","title":"Conceptos b\u00e1sicos"},{"location":"sas/intro_sas/#procedimientos-y-pasos-data","text":"SAS se compone de dos grandes bloques: el paso DATA y el paso PROC. El bloque DATA sirve para leer o generar datos, mientras que el bloque PROC generalmente sirve para analizar dichos datos, aunque hay muchos procedimientos. Este sencillo ejemplo muestra el flujo general de los programas de sas. Primero se crear\u00e1 un dataset con el bloque de instrucciones DATA. DATA calificaciones; INPUT nombre $ Grupo $ puntaje; DATALINES; ANGELICA A 10 BRENDA A 9 MARCO B 8 LILIANA B 8 FABIAN C 9 MAURICIO C 7 ; RUN; SAS no muestra directamente los resultados, en su lugar, se escribe un mensaje en la ventana de log. Para visualizar el dataset creado, se debe ejecutar el siguiente c\u00f3digo, que constituye el paso PROC: PROC PRINT DATA = calificaciones; RUN; El resultado se muestra a continuaci\u00f3n Aunque se ha producido un resultado, nuevamente aparece un mensaje en la ventana del log: En el log aparecen las instrucciones que se ejecutaron, seguido de un mensaje indicando que los resultados se estan escribiendo en un archivo html. Finalmente en el log se nos indica el n\u00famero de observaciones le\u00eddas y el tiempo de ejecuci\u00f3n del procedimiento. Como puede verse, el log siempre est\u00e1 activo y registra todas las acciones ejecutadas. Posteriormente se ver\u00e1n como nos puede ayudar a encontrar errores y nos apoyar\u00e1 en la resoluci\u00f3n de estos.","title":"Procedimientos y pasos DATA"},{"location":"sas/intro_sas/#datasets","text":"SAS almacena los datos en tablas llamadas datasets, los cuales son archivos que se almacenan en bibliotecas (library). SAS maneja dos tipos de datos: num\u00e9ricos y caracter. Los dataset permiten almacenar un tipo de dato en cada variable. Para crear un dataset, se utiliza el bloque de instrucciones conocido como paso DATA. El paso DATA inicia con la sentencia DATA seguido del nombre del dataset y termina con la palabra clave RUN. Por ejemplo el siguiente c\u00f3digo crea un dataset con 1 observaci\u00f3n y tres variables (2 num\u00e9ricas y otra caracter). DATA EJEMPLO; FORMAT FECHA DATE.; FECHA = TODAY(); INPUT X GRUPO $; DATALINES; 12.5 azul ; RUN; La primer sentencia define el nombre del dataset. La segunda le asigna un formato de fecha a la variable fecha. Esto a se debe a que internamente SAS almacena el resultado como un valor num\u00e9rico, pero quisieramos visualizarlo como una fecha. En la tercer sentencia se define una variable num\u00e9rica mediante una funci\u00f3n, la cual obtiene la fecha de hoy (n\u00famero de d\u00edas transcurridos desde el 1 de enero de 1960). En la siguiente sentencia se declaran 2 variables que sas va a recibir, la segunda se define como caracter al agregarle el signo $ . La sentencia DATALINES le dice al programa que se introducir\u00e1n valores de manera manual (cada rengl\u00f3n representa la primera observaci\u00f3n y cada variable est\u00e1 separada por un espacio). El punto y coma dicta el fin de la introducci\u00f3n de datos. Finalmente la palabra RUN define el fin del paso DATA. Un dataset consiste de dos partes: Una porci\u00f3n descriptora Una porci\u00f3n de datos La porci\u00f3n de datos es una colecci\u00f3n de datos arreglados en una tabla rectangular. Cada rengl\u00f3n o observaci\u00f3n representa mediciones de un individuo. La porci\u00f3n descriptora de un dataset contiene informaci\u00f3n del descriptor, por ejemplo, el nombre, fecha y hora de creaci\u00f3n, n\u00famero de observaciones y n\u00famero de variables. La porci\u00f3n descriptora tambien contiene informaci\u00f3n de los atributos de cada variable en el dataset. Los atributos contienen informaci\u00f3n como el nombre de la variable, el tipo, longitud, formato, informato y etiqueta. El siguiente cuadro resume los atributos de las variables. Atributo Valor Ejemplo Requerido Nota Nombre Nombre SAS _nombre_alumno2 S\u00ed Hasta 32 car\u00e1cteres, iniciando con _ o una letras, puede contener valores num\u00e9ricos. Tipo char o num num S\u00ed Los valores perdidos (missing) para variables num\u00e9ricas se representan con . o con \"\" para caracter. Longitud Hasta 32,767 bytes para caracter, 8 para variables num\u00e9ricas 8 S\u00ed Las variables num\u00e9ricas se almacenan como valores de punto flotante en 8 bytes de longitud. Formato Nombre de formato date10. No Consulte Formatos de SAS para una referencia completa Informato Nombre de Informato dollar10. No Consulte Informatos de SAS para una referencia completa Etiqueta Una cadena de hasta 256 caracteres \u201cSegundo nombre del alumno\u201d No Algunos procedimientos o reportes usan la etiqueta en lugar del nombre de la variable. Es posible conocer las propiedades de un dataset usando el PROCEDIMIENTO CONTENTS para conocer la porci\u00f3n descriptora de un dataset. El siguiente c\u00f3digo nos muestra c\u00f3mo saber las propiedades de un dataset almacenado en sas. PROC CONTENTS DATA = SASHELP.HEART VARNUM; RUN; El resultado se muestra a continuaci\u00f3n","title":"Datasets"},{"location":"sas/intro_sas/#librerias","text":"Las librer\u00edas o bibliotecas son rutas donde se almacenan los datasets. Librer\u00eda Una librer\u00eda de SAS es una colecci\u00f3n de archivos de SAS. Es el nivel m\u00e1s alto de organizaci\u00f3n para la informaci\u00f3n dentro de SAS. En el sistema operativo Windows o UNIX, una librer\u00eda es t\u00edpicamente un grupo de archivos de SAS en el mismo folder o directorio. Si no se define una librer\u00eda, sas define una librer\u00eda temporal llamada WORK, la cual eliminar\u00e1 todos los datasets al finalizar la sesi\u00f3n. Para definir una librer\u00eda, se puede asignar una librer\u00eda a un ruta de la forma: LIBNAME libref \u2018 sas-library \u2019; donde libref es el nombre de la librer\u00eda (un nombre de sas de 1 a 8 caracteres que inicia con una letra o gui\u00f3n bajo y contiene solo letras, n\u00fameros o gui\u00f3n bajo) y sas-library es la ruta donde se almacenar\u00e1n los dataset, por ejemplo: LIBNAME TAREAS \"C:\\Users\\Default\\Documents\"; asignar\u00eda dicho directorio a la librer\u00eda TAREAS . Para referirse a un dataset almacenado en dicha librer\u00eda, se utiliza el siguiente nombre LIBRARY.DATASET , por ejemplo TAREAS.TABLA .","title":"Librer\u00edas"},{"location":"sas/intro_sas/#macros-y-variables-macro","text":"Adem\u00e1s de los pasos PROC y DATA, SAS tiene un lenguaje especial llamado lenguaje macro, el cual especie de procesador de instrucciones que compila y ejecuta. Este lenguaje es muy \u00fatil para ejecutar tareas comunes o repetitivas A diferencia de otros lenguajes de programaci\u00f3n, SAS no permite definir variables de forma directa. Sin embargo, es posible definir variables macro , las cuales almacenan un valor ya sea un n\u00famero o un texto. Dichas variables son evaluadas y pueden ser llamadas en cualquier procedimiento macro. Hay tres formas de crear variables macro: Con la sentencia %let . Con la llamada symput() . con la sentencia INTO dentro de un procedimiento SQL. Se usa la sentencia %let macro-variable = <value>; y para mandar llamar el valor de dicha variable maro se usa &macro-variable . Por ejemplo si se desea definir ciertas variables a analizar, se puede crear la siguiente sentencia; %let x = age weight height; PROC MEANS DATA = SASHELP.CLASS; VAR &X; RUN; Para ver el valor de la variable macro, se puede usar la sentencia macro %PUT <&macro-variable> , por ejemplo: %PUT &x; y el resultado ser\u00e1 age weight height Para m\u00e1s informaci\u00f3n acerca de sentencias y variables macro visite la documentaci\u00f3n de SAS .","title":"Macros y variables macro"},{"location":"sas/manejo_variables/","text":"Manejo de bases \u00b6 En esta secci\u00f3n se presentan temas m\u00e1s profundos acerca del procesamiento de datos. Se explorar\u00e1n distintas formas de manejar bases mediante uso de variables, seleccionar observaciones as\u00ed como el uso de ciclos y arreglos que nos permitan tener un mayor control de la informaci\u00f3n que se tenga. Primero se ver\u00e1 la forma de crear variables con el fin de realizar c\u00e1lculos posteriores, estas variables pueden ser usadas incluso para crear varios datasets, crear contadores o acumuladores, entre otras. Tambi\u00e9n se conocer\u00e1n t\u00e9cnicas de selecci\u00f3n de observaciones con el fin de manipular mejor las bases. Despu\u00e9s se explorar\u00e1 un poco el tema del ordenamiento con el fin de crear ya sea grupos o realizar otras operciones como uniones, transposiciones entre otras. Antes de continuar con temas mas complejos, es importante comprender de forma general el funcionamiento del paso DATA. Para una explicaci\u00f3n m\u00e1s detallada consulte C\u00f3mo funciona el paso DATA . El paso DATA tiene dos fases: Fase de compilaci\u00f3n Fase de ejecuci\u00f3n A continuaci\u00f3n se describir\u00b4n de forma breve estas fases. Durante la fase de compilaci\u00f3n, SAS revisa la sintaxis y si es correcta, se manda a c\u00f3digo m\u00e1quina en dondese procesa el c\u00f3digo y se generan los siguientes objetos: Memoria de entrada . Es un lugar en la memoria donde SAS lee registros de un archivo de texto cuando el programa se ejecute. Vector de datos del programa . Es un lugar en la memoria donde SAS construye un conjunto de datos, una observaci\u00f3n a la vez. Porci\u00f3n descriptora . Es la informaci\u00f3n general del dataset como el nombre de la base y los atributos de las variables a crear. La memoria de entrada solo aplica en el caso en que se lean archivos externos. En este caso, los datos se leen de la memoria de entrada al vector de datos del programa. El vector de datos del programa (VDP) es importante porque en \u00e9ste se realizar\u00edan los c\u00e1lculos de las sentencias de SAS o funciones. Contiene el nombre de todas las variables declaradas o inicializadas. Es como un paso intermedio entre lo que se lee y calcula con lo que se se escribe al dataset. Al inicio de cada iteraci\u00f3n los valores en el VDP son iniciados con valor missing y son llenados seg\u00fan lea o ejecuten sentencias. Durante la fase de compilaci\u00f3n tambien se crean dos variables auxiliares en el VDP que no se escribir\u00e1n en el dataset: _N_ y _ERROR_ . La primera cuenta el n\u00famero de veces que el paso DATA itera y la segunda registra si hubo alg\u00fan problema en la fase de ejecuci\u00f3n. Una vez conclu\u00edda esta etapa, se procede a la siguiente fase. En la fase de ejecuci\u00f3n se realizan las siguientes acciones: Se leen las observaciones del VDP. Se ejecutan las sentencias (c\u00e1lculo de variables). Se escriben al dataset. La variables en el VDP son reiniciadas y se colocan valores missing. Debido a que es un procesos repetitivo, SAS realiza los pasos mencionados tantas veces como observaciones haya en el archivo externo o dataset le\u00eddo. El proceso termina cuando ya no hay registros que leer y en ese momento el dataset es cerrado y se concluye el paso DATA. Creando variables \u00b6 Hasta ahora solo conoc\u00edamos las sentencias ATTRIB , LENGTH y FORMAT para declarar o iniciar variables. Otra forma de crearlas es mediante la asignaci\u00f3n de variables de la siguiente forma: variable = expresi\u00f3n sas ; Esta sentencia se conoce como sentencias de asignaci\u00f3n . Su funci\u00f3n es evaluar y almacenar el resultado en alguna variable que est\u00e1 al lado izquierdo del signo = . Una forma muy com\u00fan de crear variables es mediante el uso de operadores matem\u00e1ticos. La siguiente tabla muestra algunos de los operadores aritm\u00e9ticos en SAS. Para una referencia consulte Operadores SAS en expresiones y Funciones SAS en expresiones . S\u00edmbolo Descripci\u00f3n Ejemplo + Adici\u00f3n fecha + 1 - Sustracci\u00f3n fecha - 7 * Multiplicaci\u00f3n height * 2.54 / Divisi\u00f3n suma / total ** Exponenciaci\u00f3n metros ** 2 Considere las siguientes sentencias: fecha = '10Jun20'd; version = 1; status = \"ok\"; altura = height * 2.54; nombre2 = SUBSTR(name,1,3); En esas sentencias se han creado las variables simplemente asignando un valor o una expresi\u00f3n SAS. Las primeras tres sentencias crear\u00edan variables de tipo num\u00e9rico; la expresi\u00f3n '10Jun20'd es interpretada por sas como un valor num\u00e9rico. La cuarta sentencia realiza una multiplicaci\u00f3n de una variable por una constante. Finalmente, la quinta aplica una funci\u00f3n a una variable de tipo caracter que extraer\u00e1 los 3 primeros caracteres de una cadena. Para conocer un poco m\u00e1s vea la secci\u00f3n . A continuaci\u00f3n se presentan algunas variables que ser\u00e1n muy \u00fatiles. Variables acumuladoras y contadoras \u00b6 En SAS es posible crear una variable que sume o vaya acumulando. Considere la siguiente tabla donde se representan la informaci\u00f3n de los empleados de una compa\u00f1\u00eda. Se desea obtener un acumulado de las ventas de los empleados y un contador para tener en cuenta el n\u00famero de empleados. El siguiente c\u00f3digo muestra la forma de crear el acumulador y el contador de forma muy b\u00e1sica. DATA ventas_au2; SET ventas_au; contador = _N_; salario_acum + salary; RUN; La tercer l\u00ednea guarda el n\u00famero de veces que se ha iterado, es decir el n\u00famero de registros le\u00eddos. Debido a que la variable _N_ es temporal y no se escribe en el dataset, se guarda en la variable contador . En la cuarta se muestra c\u00f3mo acumular en la variable salario_acum , en cada iteraci\u00f3n se le suma la variable salary a la variable salario_acum . Esta sentencia es conocida como sentencia SUM . Cuidado con el operador + Se debe tener cuidado al usar el operador + debido a que si alguno de los operandos tiene un valor missing , el resultado ser\u00eda missing . Se recomienda usar la funci\u00f3n SUM para evitar esos imprevistos. Si se hubiese definido salario_acum = salario_acum + salary en la l\u00ednea 4, el resultado en cada observacion nos resultar\u00eda un valor missing . Como se mencion\u00f3 previamente, durante la fase de compilaci\u00f3n los valores en el VDP se reinician a valor missing causando que el resultado en dicha expresi\u00f3n sea missing . Para evitar que eso ocurra, se puede usar la sentencia RETAIN con el fin de que SAS conserve el valor en cada iteraci\u00f3n. DATA ventas_au2; SET ventas_au; RETAIN salario_acum2 0; salario_acum2 = salario_acum2 + salary; RUN; En la l\u00ednea 3 se pide que SAS retenga la variable salario_acum2 en cada iteraci\u00f3n y que su valor inicial sea 0. De esta manera se podr\u00eda sumar de manera normal. Consulte la sentencia RETAIN para m\u00e1s informaci\u00f3n. Funciones y llamadas a rutinas \u00b6 Ya hab\u00edamos mencionado que las funciones pod\u00edan usarse para crear variables, sin embargo ahora se profundizar\u00e1 un poco m\u00e1s en su uso. Las funciones permiten realizar c\u00e1lculos y operaciones en ocasiones muy complejas, \u00e9stas pueden requerir de cierta informaci\u00f3n o argumentos con el fin de traer el resultado. Generalmente son almacenadas en variables, aunque pudieran usarse como una expresi\u00f3n en una sentencia WHERE o IF . Su sintaxis es la siguiente: < variable = > funcion(< argumento1,argumento2 ,\u2026, argumenton >); Las llamadas a rutinas, en cambio en lugar de arrojar un resultado, realizan una acci\u00f3n u operacion. Su sintaxis es la siguiente: CALL rutina(< argumento1,argumento2 ,\u2026, argumenton >); Para m\u00e1s informaci\u00f3n acerca de las llamadas a rutinas y funciones consulte Funciones SAS y rutinas . Filtrado de datos \u00b6 En ocasiones, se tiene una basta cantidad de datos y solo nos interesa un subconjunto de estos. Para eso se pueden elegir observaciones de un dataset con la sentencia WHERE . WHERE vs IF No debe confundirse la sentencia WHERE con IF . La sentencia IF trabaja con observaciones despu\u00e9s de ser le\u00eddas en el VDP, mietras que WHERE selecciona las observaciones antes de pasar al VDP. La sintaxis es la siguiente: WHERE expresi\u00f3n ; donde expresi\u00f3n es una condici\u00f3n a evaluar, vea la secci\u00f3n selecci\u00f3n de observaciones para una referencia de los operadores l\u00f3gicos y booleanos. La siguiente tabla muestra expresiones v\u00e1lidas para la sentencia WHERE Operador Descripci\u00f3n Ejemplo BETWEEN - AND Un rango inclusivo WHERE age BETWEEN 12 AND 15; ? o CONTAINS Una cadena de caracteres WHERE name ? \"Ja\"; IS NULL o IS MISSING Valores faltantes WHERE volumen IS NULL; LIKE Combinaci\u00f3n de patrones WHERE name LIKE \"J%\"; =* Suena como (S\u00f3lo palabras en ingl\u00e9s) WHERE name =* \"jeims\"; SAME - AND Agrega cl\u00e1usulas a una sentencia WHERE existente WHERE sex = \"F\"; WHERE SAME AND age >= 13; En el siguiente ejemplo se muestra el filtrado usando la sentencia WHERE usando los datos de covid para tener s\u00f3lo la informaci\u00f3n de M\u00e9xico. DATA mexico; SET covid; WHERE iso_code EQ \"MEX\"; RUN; El log muestra el siguiente mensaje: NOTE: There were 609 observations read from the data set WORK.COVID. WHERE iso_code=\u2019MEX\u2019 Si se hubiese usado la sentencia IF en lugar de WHERE el resultado hubiera sido el siguiente: NOTE: There were 113406 observations read from the data set WORK.COVID. NOTE: The data set WORK.MEXICO has 609 observations and 60 variables. El ejemplo anterior muestra las diferencias entre las sentencias IF y WHERE . WHERE como opci\u00f3n de dataset Es posible usar la opci\u00f3n WHERE = para filtrar observaciones para un dataset especificado, esto es \u00fatil cuando se leen m\u00e1s de un dataset. Vea la documentaci\u00f3n para m\u00e1s informaci\u00f3n. Sentencias condicionales \u00b6 Anteriormente se hab\u00eda usado la sentencia IF para seleccionar variables, ahora se usar\u00e1 en conjunto con la palabra THEN con el fin de que realice una acci\u00f3n. Esta sentencia se conoce como sentencia IF-ELSE . La sintaxis es la siguiente: IF expresi\u00f3n THEN acci\u00f3n1 ; ELSE acci\u00f3n2 ; El siguiente ejemplo muestra c\u00f3mo crear una variable a partir de ciertos valores. DATA clase; SET SASHELP.CLASS; LENGTH sexo $8; IF sex = \"F\" THEN sexo = \"Mujer\"; ELSE sexo = \"Hombre\"; RUN; Note que la sentencia IF-ELSE solo permite una acci\u00f3n a la vez. Para realizar m\u00e1s de una acci\u00f3n se debe usar el bloque DO . Consulte la documentaci\u00f3n para m\u00e1s informaci\u00f3n. DATA clase; SET SASHELP.CLASS; sexo = \"Hombre\"; genero = \"Masculino\"; IF sex = \"F\" THEN DO; sexo = \"Mujer\"; genero = \"Femenino\"; END; RUN; Estas sentencias pueden anidarse para formar sentencias m\u00e1s complejas, por ejemplo. DATA clase; SET SASHELP.CLASS; LENGTH escuela $12.; IF age LE 12 THEN escuela = \"Primaria\"; ELSE IF age GE 16 THEN escuela = \"Preparatoria\"; ELSE escuela = \"Secundaria\"; RUN; Cuidado con las estructuras anidadas Se debe tener cuidado al usar sentencias anidadas ya que deben ser cerradas correctamente. De no ser as\u00ed, se pueden cometer errores. Otra forma de crear sentencias condicionales es mediante el uso de la sentencia SELECT . Consulte la ayuda para m\u00e1s informaci\u00f3n. DATA clase; SET SASHELP.CLASS; LENGTH escuela $12.; SELECT; WHEN (age LE 12) escuela = \"Primaria\"; WHEN (age GE 16) escuela = \"Preparatoria\"; OTHERWISE escuela = \"Secundaria\"; END; RUN; No confundirse Esta sentencia no debe confundirse con la sentencia SELECT de SQL . Para hacer algo similar en SQL, revise este ejemplo . Ciclos \u00b6 Al igual que otros lenguajes de programaci\u00f3n SAS dispone de sentencias de ciclo repetitivos. Estas sentencias son \u00fatiles para simulaci\u00f3n de datos o para ingreso de datos repetitivos. DO iterativo \u00b6 Es el equivalente al FOR de algunos programas La sintaxis es la siguiente: DO variable-\u00edndice = lista ; sentencias sas ; END; donde lista puede ser un rango de valores consecutivos () o una lista de valores. Consulte la documentaci\u00f3n para una mayor referencia. El siguiente ejemplo muestra su uso DATA ejemplo; INPUT color :$8.; DO i = 1,3,5; j = _N_; OUTPUT; END; DATALINES; azul verde rojo amarillo ; RUN; El dataset anterior lee los datos se\u00f1alados por la sentencia INPUT . En la primer iteraci\u00f3n (es decir,cuando lee \u201cazul\u201d) entra al ciclo DO y se escribe en el VDP el primer valor de la secuencia (i). La instrucci\u00f3n OUTPUT indica que se debe escribir ese valor al DATASET. Esto se repite para los valores restantes (3 y 5). Note que a\u00fan estamos en la primer iteraci\u00f3n (es decir _N_ = 1 ). Cuando se terminan los valores del ciclo DO, se lee la segunda observaci\u00f3n del DATALINES y se repite lo mismo. DO WHILE \u00b6 DO UNTIL \u00b6 Arreglos \u00b6 Manipulaci\u00f3n y transformaci\u00f3n de bases \u00b6","title":"Manipulaci\u00f3n de bases"},{"location":"sas/manejo_variables/#manejo-de-bases","text":"En esta secci\u00f3n se presentan temas m\u00e1s profundos acerca del procesamiento de datos. Se explorar\u00e1n distintas formas de manejar bases mediante uso de variables, seleccionar observaciones as\u00ed como el uso de ciclos y arreglos que nos permitan tener un mayor control de la informaci\u00f3n que se tenga. Primero se ver\u00e1 la forma de crear variables con el fin de realizar c\u00e1lculos posteriores, estas variables pueden ser usadas incluso para crear varios datasets, crear contadores o acumuladores, entre otras. Tambi\u00e9n se conocer\u00e1n t\u00e9cnicas de selecci\u00f3n de observaciones con el fin de manipular mejor las bases. Despu\u00e9s se explorar\u00e1 un poco el tema del ordenamiento con el fin de crear ya sea grupos o realizar otras operciones como uniones, transposiciones entre otras. Antes de continuar con temas mas complejos, es importante comprender de forma general el funcionamiento del paso DATA. Para una explicaci\u00f3n m\u00e1s detallada consulte C\u00f3mo funciona el paso DATA . El paso DATA tiene dos fases: Fase de compilaci\u00f3n Fase de ejecuci\u00f3n A continuaci\u00f3n se describir\u00b4n de forma breve estas fases. Durante la fase de compilaci\u00f3n, SAS revisa la sintaxis y si es correcta, se manda a c\u00f3digo m\u00e1quina en dondese procesa el c\u00f3digo y se generan los siguientes objetos: Memoria de entrada . Es un lugar en la memoria donde SAS lee registros de un archivo de texto cuando el programa se ejecute. Vector de datos del programa . Es un lugar en la memoria donde SAS construye un conjunto de datos, una observaci\u00f3n a la vez. Porci\u00f3n descriptora . Es la informaci\u00f3n general del dataset como el nombre de la base y los atributos de las variables a crear. La memoria de entrada solo aplica en el caso en que se lean archivos externos. En este caso, los datos se leen de la memoria de entrada al vector de datos del programa. El vector de datos del programa (VDP) es importante porque en \u00e9ste se realizar\u00edan los c\u00e1lculos de las sentencias de SAS o funciones. Contiene el nombre de todas las variables declaradas o inicializadas. Es como un paso intermedio entre lo que se lee y calcula con lo que se se escribe al dataset. Al inicio de cada iteraci\u00f3n los valores en el VDP son iniciados con valor missing y son llenados seg\u00fan lea o ejecuten sentencias. Durante la fase de compilaci\u00f3n tambien se crean dos variables auxiliares en el VDP que no se escribir\u00e1n en el dataset: _N_ y _ERROR_ . La primera cuenta el n\u00famero de veces que el paso DATA itera y la segunda registra si hubo alg\u00fan problema en la fase de ejecuci\u00f3n. Una vez conclu\u00edda esta etapa, se procede a la siguiente fase. En la fase de ejecuci\u00f3n se realizan las siguientes acciones: Se leen las observaciones del VDP. Se ejecutan las sentencias (c\u00e1lculo de variables). Se escriben al dataset. La variables en el VDP son reiniciadas y se colocan valores missing. Debido a que es un procesos repetitivo, SAS realiza los pasos mencionados tantas veces como observaciones haya en el archivo externo o dataset le\u00eddo. El proceso termina cuando ya no hay registros que leer y en ese momento el dataset es cerrado y se concluye el paso DATA.","title":"Manejo de bases"},{"location":"sas/manejo_variables/#creando-variables","text":"Hasta ahora solo conoc\u00edamos las sentencias ATTRIB , LENGTH y FORMAT para declarar o iniciar variables. Otra forma de crearlas es mediante la asignaci\u00f3n de variables de la siguiente forma: variable = expresi\u00f3n sas ; Esta sentencia se conoce como sentencias de asignaci\u00f3n . Su funci\u00f3n es evaluar y almacenar el resultado en alguna variable que est\u00e1 al lado izquierdo del signo = . Una forma muy com\u00fan de crear variables es mediante el uso de operadores matem\u00e1ticos. La siguiente tabla muestra algunos de los operadores aritm\u00e9ticos en SAS. Para una referencia consulte Operadores SAS en expresiones y Funciones SAS en expresiones . S\u00edmbolo Descripci\u00f3n Ejemplo + Adici\u00f3n fecha + 1 - Sustracci\u00f3n fecha - 7 * Multiplicaci\u00f3n height * 2.54 / Divisi\u00f3n suma / total ** Exponenciaci\u00f3n metros ** 2 Considere las siguientes sentencias: fecha = '10Jun20'd; version = 1; status = \"ok\"; altura = height * 2.54; nombre2 = SUBSTR(name,1,3); En esas sentencias se han creado las variables simplemente asignando un valor o una expresi\u00f3n SAS. Las primeras tres sentencias crear\u00edan variables de tipo num\u00e9rico; la expresi\u00f3n '10Jun20'd es interpretada por sas como un valor num\u00e9rico. La cuarta sentencia realiza una multiplicaci\u00f3n de una variable por una constante. Finalmente, la quinta aplica una funci\u00f3n a una variable de tipo caracter que extraer\u00e1 los 3 primeros caracteres de una cadena. Para conocer un poco m\u00e1s vea la secci\u00f3n . A continuaci\u00f3n se presentan algunas variables que ser\u00e1n muy \u00fatiles.","title":"Creando variables"},{"location":"sas/manejo_variables/#variables-acumuladoras-y-contadoras","text":"En SAS es posible crear una variable que sume o vaya acumulando. Considere la siguiente tabla donde se representan la informaci\u00f3n de los empleados de una compa\u00f1\u00eda. Se desea obtener un acumulado de las ventas de los empleados y un contador para tener en cuenta el n\u00famero de empleados. El siguiente c\u00f3digo muestra la forma de crear el acumulador y el contador de forma muy b\u00e1sica. DATA ventas_au2; SET ventas_au; contador = _N_; salario_acum + salary; RUN; La tercer l\u00ednea guarda el n\u00famero de veces que se ha iterado, es decir el n\u00famero de registros le\u00eddos. Debido a que la variable _N_ es temporal y no se escribe en el dataset, se guarda en la variable contador . En la cuarta se muestra c\u00f3mo acumular en la variable salario_acum , en cada iteraci\u00f3n se le suma la variable salary a la variable salario_acum . Esta sentencia es conocida como sentencia SUM . Cuidado con el operador + Se debe tener cuidado al usar el operador + debido a que si alguno de los operandos tiene un valor missing , el resultado ser\u00eda missing . Se recomienda usar la funci\u00f3n SUM para evitar esos imprevistos. Si se hubiese definido salario_acum = salario_acum + salary en la l\u00ednea 4, el resultado en cada observacion nos resultar\u00eda un valor missing . Como se mencion\u00f3 previamente, durante la fase de compilaci\u00f3n los valores en el VDP se reinician a valor missing causando que el resultado en dicha expresi\u00f3n sea missing . Para evitar que eso ocurra, se puede usar la sentencia RETAIN con el fin de que SAS conserve el valor en cada iteraci\u00f3n. DATA ventas_au2; SET ventas_au; RETAIN salario_acum2 0; salario_acum2 = salario_acum2 + salary; RUN; En la l\u00ednea 3 se pide que SAS retenga la variable salario_acum2 en cada iteraci\u00f3n y que su valor inicial sea 0. De esta manera se podr\u00eda sumar de manera normal. Consulte la sentencia RETAIN para m\u00e1s informaci\u00f3n.","title":"Variables acumuladoras y contadoras"},{"location":"sas/manejo_variables/#funciones-y-llamadas-a-rutinas","text":"Ya hab\u00edamos mencionado que las funciones pod\u00edan usarse para crear variables, sin embargo ahora se profundizar\u00e1 un poco m\u00e1s en su uso. Las funciones permiten realizar c\u00e1lculos y operaciones en ocasiones muy complejas, \u00e9stas pueden requerir de cierta informaci\u00f3n o argumentos con el fin de traer el resultado. Generalmente son almacenadas en variables, aunque pudieran usarse como una expresi\u00f3n en una sentencia WHERE o IF . Su sintaxis es la siguiente: < variable = > funcion(< argumento1,argumento2 ,\u2026, argumenton >); Las llamadas a rutinas, en cambio en lugar de arrojar un resultado, realizan una acci\u00f3n u operacion. Su sintaxis es la siguiente: CALL rutina(< argumento1,argumento2 ,\u2026, argumenton >); Para m\u00e1s informaci\u00f3n acerca de las llamadas a rutinas y funciones consulte Funciones SAS y rutinas .","title":"Funciones y llamadas a rutinas"},{"location":"sas/manejo_variables/#filtrado-de-datos","text":"En ocasiones, se tiene una basta cantidad de datos y solo nos interesa un subconjunto de estos. Para eso se pueden elegir observaciones de un dataset con la sentencia WHERE . WHERE vs IF No debe confundirse la sentencia WHERE con IF . La sentencia IF trabaja con observaciones despu\u00e9s de ser le\u00eddas en el VDP, mietras que WHERE selecciona las observaciones antes de pasar al VDP. La sintaxis es la siguiente: WHERE expresi\u00f3n ; donde expresi\u00f3n es una condici\u00f3n a evaluar, vea la secci\u00f3n selecci\u00f3n de observaciones para una referencia de los operadores l\u00f3gicos y booleanos. La siguiente tabla muestra expresiones v\u00e1lidas para la sentencia WHERE Operador Descripci\u00f3n Ejemplo BETWEEN - AND Un rango inclusivo WHERE age BETWEEN 12 AND 15; ? o CONTAINS Una cadena de caracteres WHERE name ? \"Ja\"; IS NULL o IS MISSING Valores faltantes WHERE volumen IS NULL; LIKE Combinaci\u00f3n de patrones WHERE name LIKE \"J%\"; =* Suena como (S\u00f3lo palabras en ingl\u00e9s) WHERE name =* \"jeims\"; SAME - AND Agrega cl\u00e1usulas a una sentencia WHERE existente WHERE sex = \"F\"; WHERE SAME AND age >= 13; En el siguiente ejemplo se muestra el filtrado usando la sentencia WHERE usando los datos de covid para tener s\u00f3lo la informaci\u00f3n de M\u00e9xico. DATA mexico; SET covid; WHERE iso_code EQ \"MEX\"; RUN; El log muestra el siguiente mensaje: NOTE: There were 609 observations read from the data set WORK.COVID. WHERE iso_code=\u2019MEX\u2019 Si se hubiese usado la sentencia IF en lugar de WHERE el resultado hubiera sido el siguiente: NOTE: There were 113406 observations read from the data set WORK.COVID. NOTE: The data set WORK.MEXICO has 609 observations and 60 variables. El ejemplo anterior muestra las diferencias entre las sentencias IF y WHERE . WHERE como opci\u00f3n de dataset Es posible usar la opci\u00f3n WHERE = para filtrar observaciones para un dataset especificado, esto es \u00fatil cuando se leen m\u00e1s de un dataset. Vea la documentaci\u00f3n para m\u00e1s informaci\u00f3n.","title":"Filtrado de datos"},{"location":"sas/manejo_variables/#sentencias-condicionales","text":"Anteriormente se hab\u00eda usado la sentencia IF para seleccionar variables, ahora se usar\u00e1 en conjunto con la palabra THEN con el fin de que realice una acci\u00f3n. Esta sentencia se conoce como sentencia IF-ELSE . La sintaxis es la siguiente: IF expresi\u00f3n THEN acci\u00f3n1 ; ELSE acci\u00f3n2 ; El siguiente ejemplo muestra c\u00f3mo crear una variable a partir de ciertos valores. DATA clase; SET SASHELP.CLASS; LENGTH sexo $8; IF sex = \"F\" THEN sexo = \"Mujer\"; ELSE sexo = \"Hombre\"; RUN; Note que la sentencia IF-ELSE solo permite una acci\u00f3n a la vez. Para realizar m\u00e1s de una acci\u00f3n se debe usar el bloque DO . Consulte la documentaci\u00f3n para m\u00e1s informaci\u00f3n. DATA clase; SET SASHELP.CLASS; sexo = \"Hombre\"; genero = \"Masculino\"; IF sex = \"F\" THEN DO; sexo = \"Mujer\"; genero = \"Femenino\"; END; RUN; Estas sentencias pueden anidarse para formar sentencias m\u00e1s complejas, por ejemplo. DATA clase; SET SASHELP.CLASS; LENGTH escuela $12.; IF age LE 12 THEN escuela = \"Primaria\"; ELSE IF age GE 16 THEN escuela = \"Preparatoria\"; ELSE escuela = \"Secundaria\"; RUN; Cuidado con las estructuras anidadas Se debe tener cuidado al usar sentencias anidadas ya que deben ser cerradas correctamente. De no ser as\u00ed, se pueden cometer errores. Otra forma de crear sentencias condicionales es mediante el uso de la sentencia SELECT . Consulte la ayuda para m\u00e1s informaci\u00f3n. DATA clase; SET SASHELP.CLASS; LENGTH escuela $12.; SELECT; WHEN (age LE 12) escuela = \"Primaria\"; WHEN (age GE 16) escuela = \"Preparatoria\"; OTHERWISE escuela = \"Secundaria\"; END; RUN; No confundirse Esta sentencia no debe confundirse con la sentencia SELECT de SQL . Para hacer algo similar en SQL, revise este ejemplo .","title":"Sentencias condicionales"},{"location":"sas/manejo_variables/#ciclos","text":"Al igual que otros lenguajes de programaci\u00f3n SAS dispone de sentencias de ciclo repetitivos. Estas sentencias son \u00fatiles para simulaci\u00f3n de datos o para ingreso de datos repetitivos.","title":"Ciclos"},{"location":"sas/manejo_variables/#do-iterativo","text":"Es el equivalente al FOR de algunos programas La sintaxis es la siguiente: DO variable-\u00edndice = lista ; sentencias sas ; END; donde lista puede ser un rango de valores consecutivos () o una lista de valores. Consulte la documentaci\u00f3n para una mayor referencia. El siguiente ejemplo muestra su uso DATA ejemplo; INPUT color :$8.; DO i = 1,3,5; j = _N_; OUTPUT; END; DATALINES; azul verde rojo amarillo ; RUN; El dataset anterior lee los datos se\u00f1alados por la sentencia INPUT . En la primer iteraci\u00f3n (es decir,cuando lee \u201cazul\u201d) entra al ciclo DO y se escribe en el VDP el primer valor de la secuencia (i). La instrucci\u00f3n OUTPUT indica que se debe escribir ese valor al DATASET. Esto se repite para los valores restantes (3 y 5). Note que a\u00fan estamos en la primer iteraci\u00f3n (es decir _N_ = 1 ). Cuando se terminan los valores del ciclo DO, se lee la segunda observaci\u00f3n del DATALINES y se repite lo mismo.","title":"DO iterativo"},{"location":"sas/manejo_variables/#do-while","text":"","title":"DO WHILE"},{"location":"sas/manejo_variables/#do-until","text":"","title":"DO UNTIL"},{"location":"sas/manejo_variables/#arreglos","text":"","title":"Arreglos"},{"location":"sas/manejo_variables/#manipulacion-y-transformacion-de-bases","text":"","title":"Manipulaci\u00f3n y transformaci\u00f3n de bases"},{"location":"sas/reportes/","text":"Creaci\u00f3n de reportes \u00b6 SAS es una herramienta muy \u00fatil para crear reportes de datos, algunos de ellos se pueden personalizar o adaptarlos a distintas necesidades. Formatos \u00b6 Anteriormente ya hab\u00edamos hablado de los formatos. Reportes b\u00e1sicos \u00b6 El reporte m\u00e1s simple que se puede crear, es mostrar el conjunto de datos usando el procedimiento PROC PRINT . Sin embargo, para datasets muy grandes, esto no ser\u00eda una buena opci\u00f3n debido a que SAS gastar\u00eda muchos recursos en imprimir toda la tabla. Se pueden usar ciertas configuraciones para que SAS solo procece cierta cantidad de observaciones de un dataset. La primera de ellas es mediante las opciones generales , la cual afectar\u00eda a todos los procedimientos durante la sesi\u00f3n o mediante las opciones de dataset la cual solo aplica durante ese procedimiento. Para una referencia completa sobre las opciones generales, visite el diccionario de opciones del sistema y para las opciones de dataset vea el diccionario de opciones de datasets . El siguiente ejemplo muestra las primeras diez observaciones del conjunto de datos de baseball, pero solo pedimos que muestre ciertas variables. PROC PRINT DATA = SASHELP.BASEBALL(OBS=10); VAR NAME TEAM NHOME SALARY; RUN; Produce el siguiente resultado Un reporte con seleccionando casos con total \u00b6 PROC PRINT tambien tiene diversas sentencias para hacer reportes m\u00e1s completos o espec\u00edficos. TITLE \"Reporte del equipo San Francisco\"; PROC PRINT DATA = SASHELP.BASEBALL NOOBS; VAR NAME NHOME SALARY; WHERE TEAM EQ \"San Francisco\"; FORMAT SALARY DOLLAR12.; LABEL NAME = \"Nombre del jugador\" NHOME = \"N\u00famero de Home Runs en 1986\" SALARY = \"Salario en 1987 (Miles de d\u00f3lares)\" ; SUM NHOME SALARY; RUN; TITLE; El anterior ejemplo muestra un reporte que incluye el nombre de todos los jugadores del equipo San Francisco , n\u00famero de home run ysu salario; al final del reporte se presenta el gran total de estas variables. En este ejemplo se modificaron las etiquetas y los formatos, pero s\u00f3lo para el reporte mediante las sentencias LABEL y FORMAT y se seleccionaron las observaciones que cumplieran cierto criterio. La opci\u00f3n NOOBS en la sentencia DATA pide no imprimir el n\u00famero de observaci\u00f3n del dataset y con la opci\u00f3n LABEL se mostrar\u00e1n las etiquetas de las variables. La sentencia VAR especifica las variables a mostrar. La sentencia WHERE selecciona las observaciones que cumplan la condici\u00f3n de que el equipo sea igual a San Francisco . La sentencia FORMAT le asigna a la variable SALARY el formato DOLLAR12. . LABEL especifica las etiquetas de las variables en el reporte. En caso de que las variables del dataset ya tengan etiquetas, estas etiquetas definidas prevalecen en el reporte. La sentencia SUM es la que especifica las variables que mostrar\u00e1n el gran total. Finalmente se agrega la opci\u00f3n TITLE para que se le ponga un t\u00edtulo al reporte y se vuelve a llamar al final para que vuelva a su valor inicial. Reporte con subtotales \u00b6 Es posible mostrar los reportes con subtotales por grupos de variables. Datos agrupados Los datos se deber\u00edan ordenar por la variables que se desee hacer el agrupamiento para evitar posibles errores en los c\u00e1lculos. SAS considera valores iguales de la variable de agrupamiento como un bloque. Si SAS encontrara una observaci\u00f3n con un valor que ya proces\u00f3, se generar\u00e1 un error. Se puede usar el procedimiento SORT para ordenar una dataset por las variables que se deseen y posteriormente realizar el reporte. PROC SORT DATA = SASHELP.BASEBALL OUT = BASEBALL; BY DIVISION TEAM; RUN; PROC PRINT DATA = BASEBALL NOOBS LABEL; VAR NAME POSITION NHOME SALARY; FORMAT SALARY DOLLAR12.; LABEL DIVISION = \"Divisi\u00f3n\" NAME = \"Nombre del jugador\" TEAM = \"Equipo\" POSITION = \"Posici\u00f3n\" NHOME = \"N\u00famero de Home Runs en 1986\" SALARY = \"Salario en 1987 (Miles de d\u00f3lares)\" ; SUM NHOME SALARY; BY DIVISION TEAM; RUN; El procedimiento SORT especifica que se ordene por las variables division y luego por team y se pide que se guarde una copia temporal, con el fin de no modificar el dataset original. En el procedimiento PRINT se usa la sentencia BY para que crear el reporte por combinaciones de valores de division y team . La imagen anterior muestra el ultimo grupo de variables (Divisi\u00f3n = West y Equipo = Texas). N\u00f3tese que este grupo contiene los subtotales tanto de las variables team y division as\u00ed como el gran total. Cada grupo contiene como t\u00edtulo el valor de las variables division y team . Personalizar etiquetas Se pueden agregar en la sentencia PROC PRINT las opciones SUMLABEL = y GRANDTOTAL_LABEL = para personalizar las etiquetas de subtotales y el gran total. Si se desea mostrar un reporte con otro estilo resaltando las variables de agrupamiento, se puede agregar la sentencia. ID DIVISION TEAM; El resultado es el siguente.","title":"Elaboraci\u00f3n de reportes"},{"location":"sas/reportes/#creacion-de-reportes","text":"SAS es una herramienta muy \u00fatil para crear reportes de datos, algunos de ellos se pueden personalizar o adaptarlos a distintas necesidades.","title":"Creaci\u00f3n de reportes"},{"location":"sas/reportes/#formatos","text":"Anteriormente ya hab\u00edamos hablado de los formatos.","title":"Formatos"},{"location":"sas/reportes/#reportes-basicos","text":"El reporte m\u00e1s simple que se puede crear, es mostrar el conjunto de datos usando el procedimiento PROC PRINT . Sin embargo, para datasets muy grandes, esto no ser\u00eda una buena opci\u00f3n debido a que SAS gastar\u00eda muchos recursos en imprimir toda la tabla. Se pueden usar ciertas configuraciones para que SAS solo procece cierta cantidad de observaciones de un dataset. La primera de ellas es mediante las opciones generales , la cual afectar\u00eda a todos los procedimientos durante la sesi\u00f3n o mediante las opciones de dataset la cual solo aplica durante ese procedimiento. Para una referencia completa sobre las opciones generales, visite el diccionario de opciones del sistema y para las opciones de dataset vea el diccionario de opciones de datasets . El siguiente ejemplo muestra las primeras diez observaciones del conjunto de datos de baseball, pero solo pedimos que muestre ciertas variables. PROC PRINT DATA = SASHELP.BASEBALL(OBS=10); VAR NAME TEAM NHOME SALARY; RUN; Produce el siguiente resultado","title":"Reportes b\u00e1sicos"},{"location":"sas/reportes/#un-reporte-con-seleccionando-casos-con-total","text":"PROC PRINT tambien tiene diversas sentencias para hacer reportes m\u00e1s completos o espec\u00edficos. TITLE \"Reporte del equipo San Francisco\"; PROC PRINT DATA = SASHELP.BASEBALL NOOBS; VAR NAME NHOME SALARY; WHERE TEAM EQ \"San Francisco\"; FORMAT SALARY DOLLAR12.; LABEL NAME = \"Nombre del jugador\" NHOME = \"N\u00famero de Home Runs en 1986\" SALARY = \"Salario en 1987 (Miles de d\u00f3lares)\" ; SUM NHOME SALARY; RUN; TITLE; El anterior ejemplo muestra un reporte que incluye el nombre de todos los jugadores del equipo San Francisco , n\u00famero de home run ysu salario; al final del reporte se presenta el gran total de estas variables. En este ejemplo se modificaron las etiquetas y los formatos, pero s\u00f3lo para el reporte mediante las sentencias LABEL y FORMAT y se seleccionaron las observaciones que cumplieran cierto criterio. La opci\u00f3n NOOBS en la sentencia DATA pide no imprimir el n\u00famero de observaci\u00f3n del dataset y con la opci\u00f3n LABEL se mostrar\u00e1n las etiquetas de las variables. La sentencia VAR especifica las variables a mostrar. La sentencia WHERE selecciona las observaciones que cumplan la condici\u00f3n de que el equipo sea igual a San Francisco . La sentencia FORMAT le asigna a la variable SALARY el formato DOLLAR12. . LABEL especifica las etiquetas de las variables en el reporte. En caso de que las variables del dataset ya tengan etiquetas, estas etiquetas definidas prevalecen en el reporte. La sentencia SUM es la que especifica las variables que mostrar\u00e1n el gran total. Finalmente se agrega la opci\u00f3n TITLE para que se le ponga un t\u00edtulo al reporte y se vuelve a llamar al final para que vuelva a su valor inicial.","title":"Un reporte con seleccionando casos con total"},{"location":"sas/reportes/#reporte-con-subtotales","text":"Es posible mostrar los reportes con subtotales por grupos de variables. Datos agrupados Los datos se deber\u00edan ordenar por la variables que se desee hacer el agrupamiento para evitar posibles errores en los c\u00e1lculos. SAS considera valores iguales de la variable de agrupamiento como un bloque. Si SAS encontrara una observaci\u00f3n con un valor que ya proces\u00f3, se generar\u00e1 un error. Se puede usar el procedimiento SORT para ordenar una dataset por las variables que se deseen y posteriormente realizar el reporte. PROC SORT DATA = SASHELP.BASEBALL OUT = BASEBALL; BY DIVISION TEAM; RUN; PROC PRINT DATA = BASEBALL NOOBS LABEL; VAR NAME POSITION NHOME SALARY; FORMAT SALARY DOLLAR12.; LABEL DIVISION = \"Divisi\u00f3n\" NAME = \"Nombre del jugador\" TEAM = \"Equipo\" POSITION = \"Posici\u00f3n\" NHOME = \"N\u00famero de Home Runs en 1986\" SALARY = \"Salario en 1987 (Miles de d\u00f3lares)\" ; SUM NHOME SALARY; BY DIVISION TEAM; RUN; El procedimiento SORT especifica que se ordene por las variables division y luego por team y se pide que se guarde una copia temporal, con el fin de no modificar el dataset original. En el procedimiento PRINT se usa la sentencia BY para que crear el reporte por combinaciones de valores de division y team . La imagen anterior muestra el ultimo grupo de variables (Divisi\u00f3n = West y Equipo = Texas). N\u00f3tese que este grupo contiene los subtotales tanto de las variables team y division as\u00ed como el gran total. Cada grupo contiene como t\u00edtulo el valor de las variables division y team . Personalizar etiquetas Se pueden agregar en la sentencia PROC PRINT las opciones SUMLABEL = y GRANDTOTAL_LABEL = para personalizar las etiquetas de subtotales y el gran total. Si se desea mostrar un reporte con otro estilo resaltando las variables de agrupamiento, se puede agregar la sentencia. ID DIVISION TEAM; El resultado es el siguente.","title":"Reporte con subtotales"}]}