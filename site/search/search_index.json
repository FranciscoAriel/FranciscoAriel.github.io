{"config":{"indexing":"full","lang":["es"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenido a Estad\u00edstica desde Cero \u00b6 En este sitio web conocer\u00e1s conceptos b\u00e1sicos de estad\u00edstica as\u00ed como fundamentos de diversos programas de software estad\u00edstico con el fin de iniciarse en el mundo de la ciencia de datos. Imagen de Sara Torda en Pixabay Conceptos b\u00e1sicos \u00b6 En esta secci\u00f3n encontrar\u00e1s una breve introducci\u00f3n a la estad\u00edstica, abarcando desde los conceptos y definiciones b\u00e1sicos hasta modelos m\u00e1s complejos. Haz click aqu\u00ed para ir al blog de Estad\u00edstica. Imagen de janjf93 en Pixabay Software estad\u00edstico \u00b6 Presentamos una gu\u00eda b\u00e1sica para aprender los comandos b\u00e1sicos de distintos lenguajes de programaci\u00f3n m\u00e1s usados en estad\u00edstica y ciencias de datos. Imagen de 200 Degrees en Pixabay SAS \u00ae Software \u00b6 En este blog conoceras todo lo relacionado a: SAS \u00ae software - Contiene todo lo esencial para leer, manipular datos as\u00ed como otras funciones b\u00e1sicas de SAS. SAS/STAT \u00ae software - Tiene muchos m\u00e9todos estad\u00edsticos y otros an\u00e1lisis de datos. SAS/IML \u00ae software - Es un lenguaje espec\u00edfico para trabajar con vectores, matrices, funciones matem\u00e1ticas y estad\u00edsticas avanzadas. OTROS - Conexi\u00f3n de SAS \u00ae software con otros lenguajes de programaci\u00f3n y sus configuraciones. Para ir al blog de SAS haz click aqu\u00ed . Imagen de Karolina Grabowska en Pixabay R \u00b6 Visita mi blog sobre R . En este blog encontrar\u00e1s todo lo relacionada al lenguaje R. Variables Funciones Matrices Gr\u00e1ficas Data sets Entre otras cosas m\u00e1s. Imagen de Free-Photos en Pixabay Python \u00b6 Click aqu\u00ed para ir a mi blog de Python. Aqu\u00ed encontrar\u00e1s todo lo relacionado con librer\u00edas que se usan en ciencia de datos. Julia \u00a1NUEVO! \u00b6 Julia es un nuevo lenguaje de programaci\u00f3n enfocado en la velocidad y est\u00e1 optimizado para trabajar con todos los recursos de la computadora. Click aqu\u00ed para ir a mi blog de Julia. Jupyter Notebooks \u00b6 PROXIMAMENTE \u2026 Sobre el sitio \u00b6 Este sitio es una gu\u00eda para iniciarse en el mundo de la programaci\u00f3n en diversos lengajes estad\u00edsticos y bajo ning\u00fan motivo el autor es responsable de los da\u00f1os ocasionados por resultados inesperados. Los softwares usados son SAS R Python Julia Los programas son mostrados con fines educativos. S\u00edguenos en nuestras redes sociales Github LinkedIn No te pierdas las \u00faltimas noticias en nuestro canal de Telegram T\u00fa puedes contribuir \u00b6 \u00a1Todos aprendemos de todos! Si deseas aportar nuevos conocimientos puedes apoyarnos con sugerencias o comentarios. Tambi\u00e9n puedes hacer aportaciones a mi c\u00f3digo fuente, es muy f\u00e1cil todo est\u00e1 escrito en formato markdown. Puedes clonar este repositorio. 1 git clone https://github.com/FranciscoAriel/FranciscoAriel.github.io.git o simplemente descarga el zip en tu computadora. Organizaci\u00f3n del sitio \u00b6 El archivo mkdoc.yml es el archivo principal que contiene la configuraci\u00f3n para construir el sitio web con MKDOCS. Este archivo contiene el men\u00fa de navegaci\u00f3n para organizar por los distntos lenguajes de programaci\u00f3n. Dentro de cada men\u00fa se despliegan temas seg\u00fan su nivel de dificultad. Cada tema est\u00e1 ligado a un archivo markdown. La carpeta docs contiene de forma organizada los diversos archivos markdown por lenguaje y una carpeta llamada src donde se contienen archivos auxiliares, como ejemplos de c\u00f3digos, dataset u otros recursos. Finalmente la carpeta img contiene contiene im\u00e1genes para ilustrar algunos resultados. El proyecto est\u00e1 basado en el tema material . Archivos markdown \u00b6 Los archivos markdown est\u00e1n en formato utf-8 . Cada archivo inicia con un encabezado en donde se especifica los metadatos. 1 2 3 4 title : T\u00edtulo summary : Resumen authors : Nombre del autor date : yyyy-mm-dd Se pueden usar encabezados de nivel dos para temas principales y de nivel 3 para subtemas 1 2 3 4 5 6 7 ## Tema P\u00e1rrafo ### Subtema P\u00e1rrafo Extras \u00b6 Para agregar fragmentos de c\u00f3digo, consulte la secci\u00f3n code blocks para conocer sobre como resaltar los c\u00f3digos o lenguajes soportados. Se pueden agregar cuadros que resaltan la informaci\u00f3n consulte Admonitions para una referencia completa. SAS and all other SAS Institute Inc. product or service names are registered trademarks or trademarks of SAS Institute Inc. in the USA and other countries. \u00ae indicates USA registration.","title":"Bienvenido a Estad\u00edstica desde Cero"},{"location":"#bienvenido-a-estadistica-desde-cero","text":"En este sitio web conocer\u00e1s conceptos b\u00e1sicos de estad\u00edstica as\u00ed como fundamentos de diversos programas de software estad\u00edstico con el fin de iniciarse en el mundo de la ciencia de datos. Imagen de Sara Torda en Pixabay","title":"Bienvenido a Estad\u00edstica desde Cero"},{"location":"#conceptos-basicos","text":"En esta secci\u00f3n encontrar\u00e1s una breve introducci\u00f3n a la estad\u00edstica, abarcando desde los conceptos y definiciones b\u00e1sicos hasta modelos m\u00e1s complejos. Haz click aqu\u00ed para ir al blog de Estad\u00edstica. Imagen de janjf93 en Pixabay","title":"Conceptos b\u00e1sicos"},{"location":"#software-estadistico","text":"Presentamos una gu\u00eda b\u00e1sica para aprender los comandos b\u00e1sicos de distintos lenguajes de programaci\u00f3n m\u00e1s usados en estad\u00edstica y ciencias de datos. Imagen de 200 Degrees en Pixabay","title":"Software estad\u00edstico"},{"location":"#sas-software","text":"En este blog conoceras todo lo relacionado a: SAS \u00ae software - Contiene todo lo esencial para leer, manipular datos as\u00ed como otras funciones b\u00e1sicas de SAS. SAS/STAT \u00ae software - Tiene muchos m\u00e9todos estad\u00edsticos y otros an\u00e1lisis de datos. SAS/IML \u00ae software - Es un lenguaje espec\u00edfico para trabajar con vectores, matrices, funciones matem\u00e1ticas y estad\u00edsticas avanzadas. OTROS - Conexi\u00f3n de SAS \u00ae software con otros lenguajes de programaci\u00f3n y sus configuraciones. Para ir al blog de SAS haz click aqu\u00ed . Imagen de Karolina Grabowska en Pixabay","title":"SAS &reg; Software"},{"location":"#r","text":"Visita mi blog sobre R . En este blog encontrar\u00e1s todo lo relacionada al lenguaje R. Variables Funciones Matrices Gr\u00e1ficas Data sets Entre otras cosas m\u00e1s. Imagen de Free-Photos en Pixabay","title":"R"},{"location":"#python","text":"Click aqu\u00ed para ir a mi blog de Python. Aqu\u00ed encontrar\u00e1s todo lo relacionado con librer\u00edas que se usan en ciencia de datos.","title":"Python"},{"location":"#julia-nuevo","text":"Julia es un nuevo lenguaje de programaci\u00f3n enfocado en la velocidad y est\u00e1 optimizado para trabajar con todos los recursos de la computadora. Click aqu\u00ed para ir a mi blog de Julia.","title":"Julia \u00a1NUEVO!"},{"location":"#jupyter-notebooks","text":"PROXIMAMENTE \u2026","title":"Jupyter Notebooks"},{"location":"#sobre-el-sitio","text":"Este sitio es una gu\u00eda para iniciarse en el mundo de la programaci\u00f3n en diversos lengajes estad\u00edsticos y bajo ning\u00fan motivo el autor es responsable de los da\u00f1os ocasionados por resultados inesperados. Los softwares usados son SAS R Python Julia Los programas son mostrados con fines educativos. S\u00edguenos en nuestras redes sociales Github LinkedIn No te pierdas las \u00faltimas noticias en nuestro canal de Telegram","title":"Sobre el sitio"},{"location":"#tu-puedes-contribuir","text":"\u00a1Todos aprendemos de todos! Si deseas aportar nuevos conocimientos puedes apoyarnos con sugerencias o comentarios. Tambi\u00e9n puedes hacer aportaciones a mi c\u00f3digo fuente, es muy f\u00e1cil todo est\u00e1 escrito en formato markdown. Puedes clonar este repositorio. 1 git clone https://github.com/FranciscoAriel/FranciscoAriel.github.io.git o simplemente descarga el zip en tu computadora.","title":"T\u00fa puedes contribuir"},{"location":"#organizacion-del-sitio","text":"El archivo mkdoc.yml es el archivo principal que contiene la configuraci\u00f3n para construir el sitio web con MKDOCS. Este archivo contiene el men\u00fa de navegaci\u00f3n para organizar por los distntos lenguajes de programaci\u00f3n. Dentro de cada men\u00fa se despliegan temas seg\u00fan su nivel de dificultad. Cada tema est\u00e1 ligado a un archivo markdown. La carpeta docs contiene de forma organizada los diversos archivos markdown por lenguaje y una carpeta llamada src donde se contienen archivos auxiliares, como ejemplos de c\u00f3digos, dataset u otros recursos. Finalmente la carpeta img contiene contiene im\u00e1genes para ilustrar algunos resultados. El proyecto est\u00e1 basado en el tema material .","title":"Organizaci\u00f3n del sitio"},{"location":"#archivos-markdown","text":"Los archivos markdown est\u00e1n en formato utf-8 . Cada archivo inicia con un encabezado en donde se especifica los metadatos. 1 2 3 4 title : T\u00edtulo summary : Resumen authors : Nombre del autor date : yyyy-mm-dd Se pueden usar encabezados de nivel dos para temas principales y de nivel 3 para subtemas 1 2 3 4 5 6 7 ## Tema P\u00e1rrafo ### Subtema P\u00e1rrafo","title":"Archivos markdown"},{"location":"#extras","text":"Para agregar fragmentos de c\u00f3digo, consulte la secci\u00f3n code blocks para conocer sobre como resaltar los c\u00f3digos o lenguajes soportados. Se pueden agregar cuadros que resaltan la informaci\u00f3n consulte Admonitions para una referencia completa. SAS and all other SAS Institute Inc. product or service names are registered trademarks or trademarks of SAS Institute Inc. in the USA and other countries. \u00ae indicates USA registration.","title":"Extras"},{"location":"estadistica/inferencia/","text":"Introducci\u00f3n \u00b6 En la vida real quisi\u00e9ramos estimar valores aproximados de caracter\u00edsticas de inter\u00e9s de una poblaci\u00f3n, por ejemplo la temperatura promedio de cierto lugar. Imagen de Bianca van Dijk en Pixabay Ser\u00eda conveniente tener f\u00f3rmulas generales para poder estimar algo desconocido \u00fanicamente utilizando informaci\u00f3n obtenida a partir de la observaci\u00f3n de fen\u00f3menos; quisi\u00e9ramos que esas f\u00f3rmulas generales sean buenas y que se pudieran utilizar con otros datos. Por ello en este documento se detalla la forma en obtener estimadores de los par\u00e1metros poblacionales que son de inter\u00e9s. Propiedades deseables de los estimadores \u00b6 Sup\u00f3ngase que $\\mathbf{X}=( X_1,X_2,\\ldots,X_n )$ es una muestra aleatoria de una densidad (f_X(x;\\theta)) conocida, la cual depende de un par\u00e1metro desconocido 1 (\\theta), aunque sabemos que (\\theta) pertenece a un espacio de par\u00e1metros (\\Theta). Si \u00fanicamente conocemos la muestra aleatoria (observaciones), (\\mathbf{x}) que representan una realizaci\u00f3n de (\\mathbf{X}), \u00bfCu\u00e1l es el valor aproximado de (\\theta)?. Definici\u00f3n Estad\u00edstica Una estad\u00edstica es una funci\u00f3n de la muestra aleatoria solamente. Note que es una variable aleatoria . Definici\u00f3n Estimador Un estimador del par\u00e1metro (\\theta) es una estad\u00edstica (T=v(\\mathbf{X})), funci\u00f3n de la muestra aleatoria, tal que la estimaci\u00f3n (t=v(\\mathbf{x}) \\in \\Theta). Definici\u00f3n Estimaci\u00f3n Una estimaci\u00f3n es una realizaci\u00f3n de un estimador , es decir, es un n\u00famero real. En otras palabras, para que (T) sea un estimador 2 , es necesario que al evaluar el estimador en cualquier muestra, (T) caiga dentro del espacio de par\u00e1metros (\\Theta). Se desea que los estimadores tengan ciertas propiedades deseables: Principio de suficiencia Si (Y_1=u( X_1,X_2,\\ldots,X_n )) es una estad\u00edstica suficiente para (\\theta), entonces cualquier inferencia sobre (\\theta) va a depender de la muestra (X_1,X_2,\\ldots,X_n) \u00fanicamente a trav\u00e9s de la estad\u00edstica suficiente (Y_1). Es decir si tenemos dos muestras observadas (x_1,x_2,\\ldots,x_n) y (y_1,y_2,\\ldots,y_n), entonces la inferencia sobre (\\theta) ser\u00e1 la misma sin importar que se use la muestra uno (\\mathbf{x}=x_1,x_2,\\ldots,x_n) o la muestra dos (\\mathbf{y}=y_1,y_2,\\ldots,y_n); en otras palabras (u( x_1,\\ldots,x_n ) =u( y_1,\\ldots,y_n ) ). La propiedad de suficiencia se refiere a que una estad\u00edstica (Y_1) concentra toda la informaci\u00f3n acerca del par\u00e1metro de la muestra aleatoria en una sola variable aleatoria . Es decir debe tomar en cuenta a toda la muestra . La estad\u00edstica suficiente es un tipo especial de estad\u00edstica, ya que condensa la informaci\u00f3n de la muestra de tal forma que no se pierda ninguna informaci\u00f3n acerca del par\u00e1metro (\\theta). Definici\u00f3n Estad\u00edstica suficiente Sea (\\mathbf{X}) una muestra aleatoria con densidad conjunta (f_{\\mathbf{X}}(\\mathbf{x} ;\\theta)). Una estad\u00edstica (Y_1=u(\\mathbf{X}) ) es suficiente si y s\u00f3lo si (f_{\\mathbf{X}|Y_1 } (\\mathbf{x}|y_1)) no depende de (\\theta). Por ahora se considerar\u00e1 que (\\theta) es de dimensi\u00f3n uno, aunque podr\u00eda ser un vector de par\u00e1metros. \u21a9 Note que podr\u00edan existir infinidad de estimadores con esta caracter\u00edstica. \u21a9","title":"Inferencia estad\u00edstica"},{"location":"estadistica/inferencia/#introduccion","text":"En la vida real quisi\u00e9ramos estimar valores aproximados de caracter\u00edsticas de inter\u00e9s de una poblaci\u00f3n, por ejemplo la temperatura promedio de cierto lugar. Imagen de Bianca van Dijk en Pixabay Ser\u00eda conveniente tener f\u00f3rmulas generales para poder estimar algo desconocido \u00fanicamente utilizando informaci\u00f3n obtenida a partir de la observaci\u00f3n de fen\u00f3menos; quisi\u00e9ramos que esas f\u00f3rmulas generales sean buenas y que se pudieran utilizar con otros datos. Por ello en este documento se detalla la forma en obtener estimadores de los par\u00e1metros poblacionales que son de inter\u00e9s.","title":"Introducci\u00f3n"},{"location":"estadistica/inferencia/#propiedades-deseables-de-los-estimadores","text":"Sup\u00f3ngase que $\\mathbf{X}=( X_1,X_2,\\ldots,X_n )$ es una muestra aleatoria de una densidad (f_X(x;\\theta)) conocida, la cual depende de un par\u00e1metro desconocido 1 (\\theta), aunque sabemos que (\\theta) pertenece a un espacio de par\u00e1metros (\\Theta). Si \u00fanicamente conocemos la muestra aleatoria (observaciones), (\\mathbf{x}) que representan una realizaci\u00f3n de (\\mathbf{X}), \u00bfCu\u00e1l es el valor aproximado de (\\theta)?. Definici\u00f3n Estad\u00edstica Una estad\u00edstica es una funci\u00f3n de la muestra aleatoria solamente. Note que es una variable aleatoria . Definici\u00f3n Estimador Un estimador del par\u00e1metro (\\theta) es una estad\u00edstica (T=v(\\mathbf{X})), funci\u00f3n de la muestra aleatoria, tal que la estimaci\u00f3n (t=v(\\mathbf{x}) \\in \\Theta). Definici\u00f3n Estimaci\u00f3n Una estimaci\u00f3n es una realizaci\u00f3n de un estimador , es decir, es un n\u00famero real. En otras palabras, para que (T) sea un estimador 2 , es necesario que al evaluar el estimador en cualquier muestra, (T) caiga dentro del espacio de par\u00e1metros (\\Theta). Se desea que los estimadores tengan ciertas propiedades deseables: Principio de suficiencia Si (Y_1=u( X_1,X_2,\\ldots,X_n )) es una estad\u00edstica suficiente para (\\theta), entonces cualquier inferencia sobre (\\theta) va a depender de la muestra (X_1,X_2,\\ldots,X_n) \u00fanicamente a trav\u00e9s de la estad\u00edstica suficiente (Y_1). Es decir si tenemos dos muestras observadas (x_1,x_2,\\ldots,x_n) y (y_1,y_2,\\ldots,y_n), entonces la inferencia sobre (\\theta) ser\u00e1 la misma sin importar que se use la muestra uno (\\mathbf{x}=x_1,x_2,\\ldots,x_n) o la muestra dos (\\mathbf{y}=y_1,y_2,\\ldots,y_n); en otras palabras (u( x_1,\\ldots,x_n ) =u( y_1,\\ldots,y_n ) ). La propiedad de suficiencia se refiere a que una estad\u00edstica (Y_1) concentra toda la informaci\u00f3n acerca del par\u00e1metro de la muestra aleatoria en una sola variable aleatoria . Es decir debe tomar en cuenta a toda la muestra . La estad\u00edstica suficiente es un tipo especial de estad\u00edstica, ya que condensa la informaci\u00f3n de la muestra de tal forma que no se pierda ninguna informaci\u00f3n acerca del par\u00e1metro (\\theta). Definici\u00f3n Estad\u00edstica suficiente Sea (\\mathbf{X}) una muestra aleatoria con densidad conjunta (f_{\\mathbf{X}}(\\mathbf{x} ;\\theta)). Una estad\u00edstica (Y_1=u(\\mathbf{X}) ) es suficiente si y s\u00f3lo si (f_{\\mathbf{X}|Y_1 } (\\mathbf{x}|y_1)) no depende de (\\theta). Por ahora se considerar\u00e1 que (\\theta) es de dimensi\u00f3n uno, aunque podr\u00eda ser un vector de par\u00e1metros. \u21a9 Note que podr\u00edan existir infinidad de estimadores con esta caracter\u00edstica. \u21a9","title":"Propiedades deseables de los estimadores"},{"location":"julia/basico_julia/","text":"Manejo de bases con Julia \u00b6 En esta p\u00e1gina se aprender\u00e1 a importar archivos en Julia y trabajar con ellos. Tambi\u00e9n se conocer\u00e1 c\u00f3mo hacer filtros y otro tipo de operacione sobre las bases. Lectura de datos \u00b6 En Julia existen diversos paquetes que nos permiten importar y leer datos de archivos externos. En esta secci\u00f3n nos enfocaremos a la creaci\u00f3n de conjuntos de datos. Creaci\u00f3n de datos \u00b6 Para manipular conjuntos de datos, se puede usar el paquete DataFrames . Instalar el paquete No olvide instalar el paquete DataFrames , de otro modo se obtendr\u00e1 un error. Por ejemplo, para crear el siguiente conjunto de datos nombre grupo puntaje ANGELICA A 10 BRENDA A 9 LILIANA B 8 MARCO B 8 FABIAN C 9 MAURICIO C 7 se puede escribir en la consola el siguiente comando: 1 2 3 4 5 using DataFrames datos = DataFrame ( nombre = [ \"ANGELICA\" , \"BRENDA\" , \"LILIANA\" , \"MARCO\" , \"FABIAN\" , \"MAURICIO\" ], grupo = [ \"A\" , \"A\" , \"B\" , \"B\" , \"C\" , \"C\" ], puntaje = [ 10 , 9 , 8 , 8 , 9 , 7 ]); print ( datos ) Este c\u00f3digo crea un objeto llamado datos que es de tipo DataFrame . La forma de definir su contenido es mediante constructores que en este caso son las columnas, aunque pueden ser vectores definidos previamente. Para saber el tipo del objeto datos podemos escribir en la consola el siguiente comando: 1 typeof ( datos ) DataFrame Para visualizar el objeto, se puede usar el comando print() . El resultado se muestra a continuaci\u00f3n. Leyendo un archivo CSV \u00b6 Para leer un archivo csv, recomienda el uso de los paquetes CSV y DataFrames . El siguiente c\u00f3digo muestra c\u00f3mo importar un archivo csv a un objeto DataFrame . 1 2 3 using CSV , DataFrames mi_csv = CSV . read ( \"C: \\\\ Users \\\\ Usuario \\\\ census.csv\" , DataFrame ) summary ( mi_csv ) La primer l\u00ednea carga los paquetes instalados previamente, para poder usar todas sus funciones y m\u00e9todos. En la segunda, se usa la funci\u00f3n CSV.read() especific\u00e1ndole el nombre de archivo y la funci\u00f3n sink , en este caso ser\u00e1 DataFrame , asign\u00e1ndolo al objeto mi_csv . Debido a que el archivo es grande se sugiere ver las dimensiones del dataframe usando la funci\u00f3n summary() . Manipulaci\u00f3n de bases \u00b6 En esta secci\u00f3n se muestra c\u00f3mo manipular bases con el fin de trabajar directamente con ellas o realizar algunas operaciones, tales como ordenar una base, segmentarla o realizar uniones. Tambien, en esta secci\u00f3n nos enfocaremos en conocer las propiedades de las bases, acceder a los elementos de la base, entre otros. Explorando la base \u00b6 Para saber la dimensi\u00f3n de un objeto DataFrame se puede usar la funci\u00f3n summary() . Por ejemplo: 1 summary ( datos ) El siguiente mensaje se muestra en la pantalla o ventana de resultados. Tambi\u00e9n es posible conocer los primeros y \u00faltimos renglones de una base con la funci\u00f3n first() y last() . Por ejemplo, para obtener los primeros 3 y \u00faltimos 3 se puede usar este c\u00f3digo. 1 2 first ( datos , 3 ) last ( datos , 3 ) El siguiente mensaje se mostrar\u00e1 en pantalla. Finalmente tambien es posible obtener estad\u00edsticas descriptivas del dataframe usando la siguiente instrucci\u00f3n. 1 describe ( datos ) Accediendo a los datos \u00b6 Como ya vimos anteriormente, las bases en Julia se guardan en un objeto DataFrame . Para poder acceder a las variables, se pueden usar los corchetes cuadrados de la forma [renglon,columna] , por ejemplo 1 2 3 4 datos [ : , \"grupo\" ] datos [ ! , 2 ] datos [ 1 : 3 , : ] datos [[ 1 , 3 , 5 ],[ 1 , 3 ]] Seleccionar todos los renglones Se puede usar ! en lugar de : para indicar que se deben seleccionar todos los elementos. No puede ir vac\u00edo. Para elegir un elemento de un dataframe se puede usar la funci\u00f3n getindex() , por ejemplo el siguiente c\u00f3digo obtendr\u00e1 del dataframe datos el tercer registro de la columna nombre . 1 getindex ( datos , 3 , \"nombre\" ) Filtrado de datos \u00b6 Para realizar un filtrado, se puede usar la notaci\u00f3n . para acceder a las propiedades de un dataframe y usar los nombres de variables. El siguiente c\u00f3digo muestra c\u00f3mo obtener una filtro del dataframe datos , eligiendo a los alumnos que pertenecen al grupo A . 1 2 datos2 = datos [ datos . grupo .== \"A\" , : ] print ( datos2 ) Comparaci\u00f3n Note que se usa un punto antes de los operadores de comparaci\u00f3n. El resultado se muestra a continuaci\u00f3n: Tambien se puede usar la funci\u00f3n in para elegir m\u00e1s de un valor. 1 2 datos2 = datos [ in ([ \"A\" , \"C\" ]) . ( datos . grupo ) , : ] print ( datos2 ) Para saber m\u00e1s del filtrado de datos, vea la documentaci\u00f3n . Creando nuevas variables \u00b6 Para crear nuevas variable, se puede usar la notaci\u00f3n . para crear en un dataframe el nuevo nombre de la variable. El siguiente c\u00f3digo muestra como crear una nueva variable llamada nota usando una funci\u00f3n condicional. 1 2 datos . nota = ifelse . ( datos . puntaje .< 9 , \"Suficiente\" , \"Excelente\" ) print ( datos ) Note que se usa la notaci\u00f3n .< para expresar que se quiere hacer la comparaci\u00f3n por elemento. El resultado se muestra a continuaci\u00f3n. Ordenando una base \u00b6 Para ordenar una base, se requiere especificar una variable por la cual se deba ordenar. El siguiente ejemplo muestra c\u00f3mo guardar un dataframe en un nuevo objeto ordenado por la variable nombre . 1 2 3 using DataFrames datos_ord = sort ( datos , :nombre ) print ( datos_ord ) El resultado se muestra a continuaci\u00f3n C\u00e1lculo en el dataframe Se puede colocar un signo de admiraci\u00f3n ! despues de la funci\u00f3n sort para indicar que la operaci\u00f3n se haga en el mismo dataframe. No se requiere guardar la base en un nuevo dataframe. Datos agrupados \u00b6 En julia es posible crear dataframes agrupados por alguna variable, en donde cada valor distinto corresponda a un grupo. Esto es relativamente \u00fatil cuando se desea segmentar una base formando grupos excluyentes entre s\u00ed. El siguiente ejemplo muestra c\u00f3mo crear una base agrupada. 1 2 using DataFrames datosg = groupby ( datos , :grupo ) La funci\u00f3n groupby crea una Dataframe agrupado del dataframe datos y lo almacena en el objeto datosg . La variable de agrupamiento es grupo . Note que el tipo de dato es el siguiente: 1 typeof ( datosg ) GroupedDataFrame{DataFrame} Los datos agrupados son de gran ayuda ya que posteriormente nos permitir\u00e1n realizar c\u00e1lculos por grupos de variables.","title":"Julia nivel b\u00e1sico"},{"location":"julia/basico_julia/#manejo-de-bases-con-julia","text":"En esta p\u00e1gina se aprender\u00e1 a importar archivos en Julia y trabajar con ellos. Tambi\u00e9n se conocer\u00e1 c\u00f3mo hacer filtros y otro tipo de operacione sobre las bases.","title":"Manejo de bases con Julia"},{"location":"julia/basico_julia/#lectura-de-datos","text":"En Julia existen diversos paquetes que nos permiten importar y leer datos de archivos externos. En esta secci\u00f3n nos enfocaremos a la creaci\u00f3n de conjuntos de datos.","title":"Lectura de datos"},{"location":"julia/basico_julia/#creacion-de-datos","text":"Para manipular conjuntos de datos, se puede usar el paquete DataFrames . Instalar el paquete No olvide instalar el paquete DataFrames , de otro modo se obtendr\u00e1 un error. Por ejemplo, para crear el siguiente conjunto de datos nombre grupo puntaje ANGELICA A 10 BRENDA A 9 LILIANA B 8 MARCO B 8 FABIAN C 9 MAURICIO C 7 se puede escribir en la consola el siguiente comando: 1 2 3 4 5 using DataFrames datos = DataFrame ( nombre = [ \"ANGELICA\" , \"BRENDA\" , \"LILIANA\" , \"MARCO\" , \"FABIAN\" , \"MAURICIO\" ], grupo = [ \"A\" , \"A\" , \"B\" , \"B\" , \"C\" , \"C\" ], puntaje = [ 10 , 9 , 8 , 8 , 9 , 7 ]); print ( datos ) Este c\u00f3digo crea un objeto llamado datos que es de tipo DataFrame . La forma de definir su contenido es mediante constructores que en este caso son las columnas, aunque pueden ser vectores definidos previamente. Para saber el tipo del objeto datos podemos escribir en la consola el siguiente comando: 1 typeof ( datos ) DataFrame Para visualizar el objeto, se puede usar el comando print() . El resultado se muestra a continuaci\u00f3n.","title":"Creaci\u00f3n de datos"},{"location":"julia/basico_julia/#leyendo-un-archivo-csv","text":"Para leer un archivo csv, recomienda el uso de los paquetes CSV y DataFrames . El siguiente c\u00f3digo muestra c\u00f3mo importar un archivo csv a un objeto DataFrame . 1 2 3 using CSV , DataFrames mi_csv = CSV . read ( \"C: \\\\ Users \\\\ Usuario \\\\ census.csv\" , DataFrame ) summary ( mi_csv ) La primer l\u00ednea carga los paquetes instalados previamente, para poder usar todas sus funciones y m\u00e9todos. En la segunda, se usa la funci\u00f3n CSV.read() especific\u00e1ndole el nombre de archivo y la funci\u00f3n sink , en este caso ser\u00e1 DataFrame , asign\u00e1ndolo al objeto mi_csv . Debido a que el archivo es grande se sugiere ver las dimensiones del dataframe usando la funci\u00f3n summary() .","title":"Leyendo un archivo CSV"},{"location":"julia/basico_julia/#manipulacion-de-bases","text":"En esta secci\u00f3n se muestra c\u00f3mo manipular bases con el fin de trabajar directamente con ellas o realizar algunas operaciones, tales como ordenar una base, segmentarla o realizar uniones. Tambien, en esta secci\u00f3n nos enfocaremos en conocer las propiedades de las bases, acceder a los elementos de la base, entre otros.","title":"Manipulaci\u00f3n de bases"},{"location":"julia/basico_julia/#explorando-la-base","text":"Para saber la dimensi\u00f3n de un objeto DataFrame se puede usar la funci\u00f3n summary() . Por ejemplo: 1 summary ( datos ) El siguiente mensaje se muestra en la pantalla o ventana de resultados. Tambi\u00e9n es posible conocer los primeros y \u00faltimos renglones de una base con la funci\u00f3n first() y last() . Por ejemplo, para obtener los primeros 3 y \u00faltimos 3 se puede usar este c\u00f3digo. 1 2 first ( datos , 3 ) last ( datos , 3 ) El siguiente mensaje se mostrar\u00e1 en pantalla. Finalmente tambien es posible obtener estad\u00edsticas descriptivas del dataframe usando la siguiente instrucci\u00f3n. 1 describe ( datos )","title":"Explorando la base"},{"location":"julia/basico_julia/#accediendo-a-los-datos","text":"Como ya vimos anteriormente, las bases en Julia se guardan en un objeto DataFrame . Para poder acceder a las variables, se pueden usar los corchetes cuadrados de la forma [renglon,columna] , por ejemplo 1 2 3 4 datos [ : , \"grupo\" ] datos [ ! , 2 ] datos [ 1 : 3 , : ] datos [[ 1 , 3 , 5 ],[ 1 , 3 ]] Seleccionar todos los renglones Se puede usar ! en lugar de : para indicar que se deben seleccionar todos los elementos. No puede ir vac\u00edo. Para elegir un elemento de un dataframe se puede usar la funci\u00f3n getindex() , por ejemplo el siguiente c\u00f3digo obtendr\u00e1 del dataframe datos el tercer registro de la columna nombre . 1 getindex ( datos , 3 , \"nombre\" )","title":"Accediendo a los datos"},{"location":"julia/basico_julia/#filtrado-de-datos","text":"Para realizar un filtrado, se puede usar la notaci\u00f3n . para acceder a las propiedades de un dataframe y usar los nombres de variables. El siguiente c\u00f3digo muestra c\u00f3mo obtener una filtro del dataframe datos , eligiendo a los alumnos que pertenecen al grupo A . 1 2 datos2 = datos [ datos . grupo .== \"A\" , : ] print ( datos2 ) Comparaci\u00f3n Note que se usa un punto antes de los operadores de comparaci\u00f3n. El resultado se muestra a continuaci\u00f3n: Tambien se puede usar la funci\u00f3n in para elegir m\u00e1s de un valor. 1 2 datos2 = datos [ in ([ \"A\" , \"C\" ]) . ( datos . grupo ) , : ] print ( datos2 ) Para saber m\u00e1s del filtrado de datos, vea la documentaci\u00f3n .","title":"Filtrado de datos"},{"location":"julia/basico_julia/#creando-nuevas-variables","text":"Para crear nuevas variable, se puede usar la notaci\u00f3n . para crear en un dataframe el nuevo nombre de la variable. El siguiente c\u00f3digo muestra como crear una nueva variable llamada nota usando una funci\u00f3n condicional. 1 2 datos . nota = ifelse . ( datos . puntaje .< 9 , \"Suficiente\" , \"Excelente\" ) print ( datos ) Note que se usa la notaci\u00f3n .< para expresar que se quiere hacer la comparaci\u00f3n por elemento. El resultado se muestra a continuaci\u00f3n.","title":"Creando nuevas variables"},{"location":"julia/basico_julia/#ordenando-una-base","text":"Para ordenar una base, se requiere especificar una variable por la cual se deba ordenar. El siguiente ejemplo muestra c\u00f3mo guardar un dataframe en un nuevo objeto ordenado por la variable nombre . 1 2 3 using DataFrames datos_ord = sort ( datos , :nombre ) print ( datos_ord ) El resultado se muestra a continuaci\u00f3n C\u00e1lculo en el dataframe Se puede colocar un signo de admiraci\u00f3n ! despues de la funci\u00f3n sort para indicar que la operaci\u00f3n se haga en el mismo dataframe. No se requiere guardar la base en un nuevo dataframe.","title":"Ordenando una base"},{"location":"julia/basico_julia/#datos-agrupados","text":"En julia es posible crear dataframes agrupados por alguna variable, en donde cada valor distinto corresponda a un grupo. Esto es relativamente \u00fatil cuando se desea segmentar una base formando grupos excluyentes entre s\u00ed. El siguiente ejemplo muestra c\u00f3mo crear una base agrupada. 1 2 using DataFrames datosg = groupby ( datos , :grupo ) La funci\u00f3n groupby crea una Dataframe agrupado del dataframe datos y lo almacena en el objeto datosg . La variable de agrupamiento es grupo . Note que el tipo de dato es el siguiente: 1 typeof ( datosg ) GroupedDataFrame{DataFrame} Los datos agrupados son de gran ayuda ya que posteriormente nos permitir\u00e1n realizar c\u00e1lculos por grupos de variables.","title":"Datos agrupados"},{"location":"julia/intro_julia/","text":"Inicio \u00b6 Julia es un poderoso lenguaje de programaci\u00f3n enfocado en la potencia y velocidad. Es de c\u00f3digo abierto y de libre uso. Visite la p\u00e1gina oficial de Julia para mayor informaci\u00f3n. Al iniciar Julia se muestra una pantalla en que es la l\u00ednea de comandos de Julia conocida como Julia REPL . Esta permite la entrada y evalua los comandos al instante. Una vez en la consola se pueden entrar a distintos modos, tal como el modo de ayuda escribiendo ? o el modo comando de sistema con ; o el modo paquetes escribiendo ] . Se puede salir de dichos modos con la tecla de borrar o con Ctrl+c . Julia tambi\u00e9n puede ejecutarse en entornos gr\u00e1ficos, por ejemplo Jypiter Notebooks o VS Code. Variables \u00b6 Julia tiene varios tipos de variables, por ejemplo tipo num\u00e9rico (entero y flotante) booleano o caracter. Para conocer todos los tipos de variables que existen, consulte la documentaci\u00f3n . Se puede definir una variable usando el operador de asignaci\u00f3n = como se muestra en el siguiente ejemplo. 1 2 3 4 5 x = 1 y = 1.25 z = x + y a = \"abc\" si = true Para saber de que tipo es, se puede usar la funci\u00f3n typeof() , el resultado se muestra 1 typeof ( x ) Int64 Vectores \u00b6 La forma de definir vectores es mediante el uso de corchetes cuadrados [] , por ejemplo: 1 2 a = [ 1 , 2 , 3 ] b = [ 2 , 4 , 5 ] No confundir con tuplas La forma de definir una tupla es mediante un par\u00e9ntesis () . Al igual que otros lenguajes de programaci\u00f3n, la forma de acceder a sus elementos es mediante el operador [] y tambi\u00e9n con : se puede definir una secuencia. 1 2 a [ 2 ] b [ 1 : 2 ] Operadores aritm\u00e9ticos \u00b6 Julia soporta diversos operadores aritm\u00e9ticos, la siguiente tabla muestra los principales operadores. Expresi\u00f3n Nombre Descripci\u00f3n x + y suma realiza adici\u00f3n x - y resta realiza substracci\u00f3n x * y producto realiza multiplicaci\u00f3n x / y divisi\u00f3n realiza divisi\u00f3n x \u00f7 y divisi\u00f3n entera similar a x/y , pero truncado a un entero x \\ y divisi\u00f3n inversa equivalente a y/x x ^ y potencia eleva x a la potencia y x % y resto equivalente to rem(x,y) Para una mayor referencia visita la secci\u00f3n operadores aritm\u00e9ticos . Control de flujo \u00b6 Julia posee estructuras para control de flujo. Se puede realizar un ciclo usando el siguiente c\u00f3digo 1 2 3 for x in 1 : 10 println ( x ) end Nota La funci\u00f3n print() imprimir\u00eda los valores consecutivamente sin espacio, mientras que println() los imprime en una l\u00ednea nueva. Se debe tomar en cuenta que la palabra for debe cerrarse con un end para delimitar el bloque. Para usar el ciclo while, se usa el siguiente c\u00f3digo 1 2 3 4 5 x = 0 while x <= 5 println ( x ) x = x + 1 end Ciclo infinito No olvides aumentar el contador con el fin de que se cumpla la condici\u00f3n, de otro modo se entrar\u00eda en un ciclo infinito. Funciones \u00b6 Para definir una funci\u00f3n, se usa la palabra function seguido del nombre de la funci\u00f3n y entre par\u00e9ntesis los argumentos. Se debe especificar la paabra clave return , de otro modo retornar\u00eda el \u00faltimo valor calculado. La funci\u00f3n termina con un end e inmediatamente se compila. 1 2 3 4 5 6 7 function signo ( x ) if x < 0 resp = \"Negativo\" elseif x > 0 resp = \"Positivo\" else resp = \"Es Cero\" end return resp end una vez compilada, se puede usar. 1 signo ( - 5 ) El resultado ser\u00eda el siguiente \u201cNegativo\u201d Paquetes \u00b6 Julia tiene un gestor de paquetes en el cual se pueden descargar miles de ellos. Para acceder a ellos basta con entrar al modo paquete y escribir en la consola. Por ejemplo, para instalar el paquete DataFrames usaremos el siguiente comando 1 add DataFrames alternativamente, desde la consola REPL podemos escribir 1 2 import Pkg Pkg . add ( \"DataFrames\" ) Para comenzar a usarlo, escribimos desde la consola 1 using DataFrames","title":"Introducci\u00f3n a Julia"},{"location":"julia/intro_julia/#inicio","text":"Julia es un poderoso lenguaje de programaci\u00f3n enfocado en la potencia y velocidad. Es de c\u00f3digo abierto y de libre uso. Visite la p\u00e1gina oficial de Julia para mayor informaci\u00f3n. Al iniciar Julia se muestra una pantalla en que es la l\u00ednea de comandos de Julia conocida como Julia REPL . Esta permite la entrada y evalua los comandos al instante. Una vez en la consola se pueden entrar a distintos modos, tal como el modo de ayuda escribiendo ? o el modo comando de sistema con ; o el modo paquetes escribiendo ] . Se puede salir de dichos modos con la tecla de borrar o con Ctrl+c . Julia tambi\u00e9n puede ejecutarse en entornos gr\u00e1ficos, por ejemplo Jypiter Notebooks o VS Code.","title":"Inicio"},{"location":"julia/intro_julia/#variables","text":"Julia tiene varios tipos de variables, por ejemplo tipo num\u00e9rico (entero y flotante) booleano o caracter. Para conocer todos los tipos de variables que existen, consulte la documentaci\u00f3n . Se puede definir una variable usando el operador de asignaci\u00f3n = como se muestra en el siguiente ejemplo. 1 2 3 4 5 x = 1 y = 1.25 z = x + y a = \"abc\" si = true Para saber de que tipo es, se puede usar la funci\u00f3n typeof() , el resultado se muestra 1 typeof ( x ) Int64","title":"Variables"},{"location":"julia/intro_julia/#vectores","text":"La forma de definir vectores es mediante el uso de corchetes cuadrados [] , por ejemplo: 1 2 a = [ 1 , 2 , 3 ] b = [ 2 , 4 , 5 ] No confundir con tuplas La forma de definir una tupla es mediante un par\u00e9ntesis () . Al igual que otros lenguajes de programaci\u00f3n, la forma de acceder a sus elementos es mediante el operador [] y tambi\u00e9n con : se puede definir una secuencia. 1 2 a [ 2 ] b [ 1 : 2 ]","title":"Vectores"},{"location":"julia/intro_julia/#operadores-aritmeticos","text":"Julia soporta diversos operadores aritm\u00e9ticos, la siguiente tabla muestra los principales operadores. Expresi\u00f3n Nombre Descripci\u00f3n x + y suma realiza adici\u00f3n x - y resta realiza substracci\u00f3n x * y producto realiza multiplicaci\u00f3n x / y divisi\u00f3n realiza divisi\u00f3n x \u00f7 y divisi\u00f3n entera similar a x/y , pero truncado a un entero x \\ y divisi\u00f3n inversa equivalente a y/x x ^ y potencia eleva x a la potencia y x % y resto equivalente to rem(x,y) Para una mayor referencia visita la secci\u00f3n operadores aritm\u00e9ticos .","title":"Operadores aritm\u00e9ticos"},{"location":"julia/intro_julia/#control-de-flujo","text":"Julia posee estructuras para control de flujo. Se puede realizar un ciclo usando el siguiente c\u00f3digo 1 2 3 for x in 1 : 10 println ( x ) end Nota La funci\u00f3n print() imprimir\u00eda los valores consecutivamente sin espacio, mientras que println() los imprime en una l\u00ednea nueva. Se debe tomar en cuenta que la palabra for debe cerrarse con un end para delimitar el bloque. Para usar el ciclo while, se usa el siguiente c\u00f3digo 1 2 3 4 5 x = 0 while x <= 5 println ( x ) x = x + 1 end Ciclo infinito No olvides aumentar el contador con el fin de que se cumpla la condici\u00f3n, de otro modo se entrar\u00eda en un ciclo infinito.","title":"Control de flujo"},{"location":"julia/intro_julia/#funciones","text":"Para definir una funci\u00f3n, se usa la palabra function seguido del nombre de la funci\u00f3n y entre par\u00e9ntesis los argumentos. Se debe especificar la paabra clave return , de otro modo retornar\u00eda el \u00faltimo valor calculado. La funci\u00f3n termina con un end e inmediatamente se compila. 1 2 3 4 5 6 7 function signo ( x ) if x < 0 resp = \"Negativo\" elseif x > 0 resp = \"Positivo\" else resp = \"Es Cero\" end return resp end una vez compilada, se puede usar. 1 signo ( - 5 ) El resultado ser\u00eda el siguiente \u201cNegativo\u201d","title":"Funciones"},{"location":"julia/intro_julia/#paquetes","text":"Julia tiene un gestor de paquetes en el cual se pueden descargar miles de ellos. Para acceder a ellos basta con entrar al modo paquete y escribir en la consola. Por ejemplo, para instalar el paquete DataFrames usaremos el siguiente comando 1 add DataFrames alternativamente, desde la consola REPL podemos escribir 1 2 import Pkg Pkg . add ( \"DataFrames\" ) Para comenzar a usarlo, escribimos desde la consola 1 using DataFrames","title":"Paquetes"},{"location":"python/basico/","text":"Introducci\u00f3n \u00b6 En esta secci\u00f3n aprenderemos acerca de c\u00f3mo leer datos en python, as\u00ed como el manejo de datos con python. Para manejar datos en python se usan librer\u00edas especiales. En particular se usar\u00e1 la librer\u00eda pandas para realizar estas operaciones. El primer paso es llamar las librer\u00edas que se utilizar\u00e1n en la sesi\u00f3n. 1 2 3 import pandas as pd import numpy as np import os La librer\u00eda pandas es la que nos permite manejar objetos de tipo dataframe que es la estructura de datos usada en python para almacenar la informaci\u00f3n. La librer\u00eda numpy nos permitir\u00e1 crear arreglos y manipularlos de forma m\u00e1s f\u00e1cil. La librer\u00eda os nos ayudar\u00e1 a usar funciones y otras utilidades del sistema operativo. Los c\u00f3digos mostrados se realizaron en un cuaderno interactivo de python (archivo ipynb) usando Visual Studio Code. Para una referencia completa, visite la documentaci\u00f3n de pandas . Creando un objeto DataFrame \u00b6 La forma m\u00e1s sencilla de crear un dataframe es mediante la definici\u00f3n de un diccionario con las listas definidas y posteriormente se usa la funci\u00f3n DataFrame del paquete pandas para crear un objeto DataFrame en donde se almacenar\u00e1 la informaci\u00f3n. El objeto creado hereda las claves del diccionario y los valores se escriben en el dataset. Para introducir datos de manera manual, se puede usar la siguiente sintaxis: 1 2 3 4 5 6 7 8 9 10 import pandas as pd nombres = [ \"ANGELICA\" , \"BRENDA\" , \"LILIANA\" , \"MARCO\" , \"FABIAN\" , \"MAURICIO\" ] gpo = [ \"A\" , \"A\" , \"B\" , \"B\" , \"C\" , \"C\" ] puntajes = [ 10 , 9 , 8 , 8 , 9 , 7 ] dic = { \"nombre\" : nombres , \"grupo\" : gpo , \"puntaje\" : puntajes } mi_base = pd . DataFrame ( dic ) print ( mi_base ) La siguiente imagen muestra el dataframe definido. Note que el objeto creado es un objeto especial. Si escribimos en la consola el comando type(mi_base) , obtenemos la siguiente informaci\u00f3n. pandas.core.frame.DataFrame Como tal, este objeto va a tener diversos m\u00e9todos para manipularlo o conocer sus propiedades. Consulte la referencia de DataFrame para saber m\u00e1s de sus propiedades. Lectura de archivos externos \u00b6 Para leer archivos externos, por ejemplo de tipo csv, se usa la funci\u00f3n read_csv de la librer\u00eda pandas para leer los datos. El siguiente c\u00f3digo muestra c\u00f3mo leer un archivo que est\u00e1 almacenado en la misma carpeta del directorio de trabajo. 1 2 3 import pandas as pd datos = pd . read_csv ( \"census.csv\" ) Como puede observarse, datos es un objeto DataFrame que se define gracias a la funci\u00f3n read_csv() de pandas. En este caso, el archivo estaba en la misma carpeta que el directorio de trabajo. Para conocer cual es el directorio de trabajo, se puede usar el siguiente comando: 1 2 root=os.getcwd() print(root) El resultado devolver\u00e1 la ruta del directorio de trabajo, por ejemplo: \u2018c:\\Users\\Usuario\\Documents\\proyectos\\python\\src\u2019 Para modificar el directorio de trabajo, se puede usar el siguiente c\u00f3digo: 1 os . chdir ( \"C: \\\\ Users \\\\ Usuario \\\\ Documents \\\\ proyectos \\\\ python \\\\ datos\" ) Por lo que solo basta copiar los archivos a esta carpeta para poder importarlos sin problema. Exploraci\u00f3n de la base \u00b6 Se puede obtener informaci\u00f3n de un objeto DataFrame usando el siguiente comando. 1 datos . info () La siguiente imagen muestra el resultado obtenido de la consola. Para ver un an\u00e1lisis descriptivo de las variables num\u00e9ricas datos se puede usar el m\u00e9todo describe . 1 datos . describe () El resultado se muestra a continuaci\u00f3n M\u00e9todos sin argumentos Note que los m\u00e9todos anteriores no requieren ning\u00fan argumento, porlo que solo se ponen los par\u00e9ntesis vac\u00edos. Para visualizar los primeros 5 datos se puede usar este c\u00f3digo 1 datos . head ( n = 5 ) La siguiente imagen muestra las primeras 5 observaciones De manera similar, los \u00faltimos 5 registros se pueden ver con este c\u00f3digo 1 datos . tail ( n = 5 ) La siguiente imagen muestra las \u00faltimas 5 observaciones Argumentos opcionales Algunos m\u00e9todos no requieren argumentos, mientras que en otros son opcionales. Los m\u00e9todos head() y tail() tienen un valor predeterminado de 5. Al igual que otros lenguajes de programaci\u00f3n, es posible acceder a los elementos de un dataframe. Para ello se puede hacer uso del m\u00e9todo iloc . El siguiente c\u00f3digo muestra c\u00f3mo acceder al segundo rengl\u00f3n de un dataframe y el resultado que se obtiene. 1 mi_base . iloc [ 1 ,] El resultado se muestra a continuaci\u00f3n M\u00e9todo sin par\u00e9ntesis Note que el m\u00e9todo iloc no usa par\u00e9ntesis. Transformaci\u00f3n y manipulaci\u00f3n de un dataframe \u00b6 Al igual que en otros lenguajes de programaci\u00f3n, es posible modifcar las tablas en python a trav\u00e9s de los m\u00e9todos de los objetos dataframe proporcionados por el paquete pandas . En esta secci\u00f3n se abordar\u00e1n temas acerca de como manipular y transformar bases que est\u00e9n almacenadas en un objeto dataframe , tales como realizar filtros, unir tablas, agrupar datos, entre otras operaciones. Filtrado de base \u00b6 Para filtrar una base, se puede usar el m\u00e9todo where() . Ordenando una base \u00b6 Para ordenar una base, se usa el m\u00e9todo sort.values() en donde se le pasa una lista con los nombres de las variables a ordenar. El siguiente c\u00f3digo muestra su uso. Note que el m\u00e9todo requiere al menos el argumento by y se pide que guarde la base ordenada en un nuevo objeto dataframe . 1 2 base_ord = mi_base . sort_values ( by = [ \"nombre\" ]) print ( datos_ord ) La siguiente imagen muestra el resultado, note que la base se ha guardado en un nuevo objeto. Para m\u00e1s informaci\u00f3n acerca del m\u00e9todo sort.values() consulte la documentaci\u00f3n del m\u00e9todo sort_values . Datos agrupados \u00b6 En el paquete pandas tambi\u00e9n se incluye un m\u00e9todo para crear datos agrupados por una o m\u00e1s variables. El siguiente c\u00f3digo muestra su uso 1 mi_base_agrupada = mi_base . groupby ( by = [ \"grupo\" ]) objeto retornado El m\u00e9todo groupby regresa un objeto DataFrameGroupBy , por lo que no podr\u00eda ser visualizado. Este objeto se suele utilizar para realizar agregados por cada grupo. Los datos agrupados son \u00fatiles para obtener estad\u00edsticas descriptivas por grupos. El siguiente ejemplo ejemplifica su uso mediante el m\u00e9todo aggregate() . 1 mi_base_agrupada . aggregate ([ \"mean\" ]) Para m\u00e1s informaci\u00f3n visite la documentaci\u00f3n del m\u00e9todo groupby y c\u00f3mo realizar agregados.","title":"Python nivel b\u00e1sico"},{"location":"python/basico/#introduccion","text":"En esta secci\u00f3n aprenderemos acerca de c\u00f3mo leer datos en python, as\u00ed como el manejo de datos con python. Para manejar datos en python se usan librer\u00edas especiales. En particular se usar\u00e1 la librer\u00eda pandas para realizar estas operaciones. El primer paso es llamar las librer\u00edas que se utilizar\u00e1n en la sesi\u00f3n. 1 2 3 import pandas as pd import numpy as np import os La librer\u00eda pandas es la que nos permite manejar objetos de tipo dataframe que es la estructura de datos usada en python para almacenar la informaci\u00f3n. La librer\u00eda numpy nos permitir\u00e1 crear arreglos y manipularlos de forma m\u00e1s f\u00e1cil. La librer\u00eda os nos ayudar\u00e1 a usar funciones y otras utilidades del sistema operativo. Los c\u00f3digos mostrados se realizaron en un cuaderno interactivo de python (archivo ipynb) usando Visual Studio Code. Para una referencia completa, visite la documentaci\u00f3n de pandas .","title":"Introducci\u00f3n"},{"location":"python/basico/#creando-un-objeto-dataframe","text":"La forma m\u00e1s sencilla de crear un dataframe es mediante la definici\u00f3n de un diccionario con las listas definidas y posteriormente se usa la funci\u00f3n DataFrame del paquete pandas para crear un objeto DataFrame en donde se almacenar\u00e1 la informaci\u00f3n. El objeto creado hereda las claves del diccionario y los valores se escriben en el dataset. Para introducir datos de manera manual, se puede usar la siguiente sintaxis: 1 2 3 4 5 6 7 8 9 10 import pandas as pd nombres = [ \"ANGELICA\" , \"BRENDA\" , \"LILIANA\" , \"MARCO\" , \"FABIAN\" , \"MAURICIO\" ] gpo = [ \"A\" , \"A\" , \"B\" , \"B\" , \"C\" , \"C\" ] puntajes = [ 10 , 9 , 8 , 8 , 9 , 7 ] dic = { \"nombre\" : nombres , \"grupo\" : gpo , \"puntaje\" : puntajes } mi_base = pd . DataFrame ( dic ) print ( mi_base ) La siguiente imagen muestra el dataframe definido. Note que el objeto creado es un objeto especial. Si escribimos en la consola el comando type(mi_base) , obtenemos la siguiente informaci\u00f3n. pandas.core.frame.DataFrame Como tal, este objeto va a tener diversos m\u00e9todos para manipularlo o conocer sus propiedades. Consulte la referencia de DataFrame para saber m\u00e1s de sus propiedades.","title":"Creando un objeto DataFrame"},{"location":"python/basico/#lectura-de-archivos-externos","text":"Para leer archivos externos, por ejemplo de tipo csv, se usa la funci\u00f3n read_csv de la librer\u00eda pandas para leer los datos. El siguiente c\u00f3digo muestra c\u00f3mo leer un archivo que est\u00e1 almacenado en la misma carpeta del directorio de trabajo. 1 2 3 import pandas as pd datos = pd . read_csv ( \"census.csv\" ) Como puede observarse, datos es un objeto DataFrame que se define gracias a la funci\u00f3n read_csv() de pandas. En este caso, el archivo estaba en la misma carpeta que el directorio de trabajo. Para conocer cual es el directorio de trabajo, se puede usar el siguiente comando: 1 2 root=os.getcwd() print(root) El resultado devolver\u00e1 la ruta del directorio de trabajo, por ejemplo: \u2018c:\\Users\\Usuario\\Documents\\proyectos\\python\\src\u2019 Para modificar el directorio de trabajo, se puede usar el siguiente c\u00f3digo: 1 os . chdir ( \"C: \\\\ Users \\\\ Usuario \\\\ Documents \\\\ proyectos \\\\ python \\\\ datos\" ) Por lo que solo basta copiar los archivos a esta carpeta para poder importarlos sin problema.","title":"Lectura de archivos externos"},{"location":"python/basico/#exploracion-de-la-base","text":"Se puede obtener informaci\u00f3n de un objeto DataFrame usando el siguiente comando. 1 datos . info () La siguiente imagen muestra el resultado obtenido de la consola. Para ver un an\u00e1lisis descriptivo de las variables num\u00e9ricas datos se puede usar el m\u00e9todo describe . 1 datos . describe () El resultado se muestra a continuaci\u00f3n M\u00e9todos sin argumentos Note que los m\u00e9todos anteriores no requieren ning\u00fan argumento, porlo que solo se ponen los par\u00e9ntesis vac\u00edos. Para visualizar los primeros 5 datos se puede usar este c\u00f3digo 1 datos . head ( n = 5 ) La siguiente imagen muestra las primeras 5 observaciones De manera similar, los \u00faltimos 5 registros se pueden ver con este c\u00f3digo 1 datos . tail ( n = 5 ) La siguiente imagen muestra las \u00faltimas 5 observaciones Argumentos opcionales Algunos m\u00e9todos no requieren argumentos, mientras que en otros son opcionales. Los m\u00e9todos head() y tail() tienen un valor predeterminado de 5. Al igual que otros lenguajes de programaci\u00f3n, es posible acceder a los elementos de un dataframe. Para ello se puede hacer uso del m\u00e9todo iloc . El siguiente c\u00f3digo muestra c\u00f3mo acceder al segundo rengl\u00f3n de un dataframe y el resultado que se obtiene. 1 mi_base . iloc [ 1 ,] El resultado se muestra a continuaci\u00f3n M\u00e9todo sin par\u00e9ntesis Note que el m\u00e9todo iloc no usa par\u00e9ntesis.","title":"Exploraci\u00f3n de la base"},{"location":"python/basico/#transformacion-y-manipulacion-de-un-dataframe","text":"Al igual que en otros lenguajes de programaci\u00f3n, es posible modifcar las tablas en python a trav\u00e9s de los m\u00e9todos de los objetos dataframe proporcionados por el paquete pandas . En esta secci\u00f3n se abordar\u00e1n temas acerca de como manipular y transformar bases que est\u00e9n almacenadas en un objeto dataframe , tales como realizar filtros, unir tablas, agrupar datos, entre otras operaciones.","title":"Transformaci\u00f3n y manipulaci\u00f3n de un dataframe"},{"location":"python/basico/#filtrado-de-base","text":"Para filtrar una base, se puede usar el m\u00e9todo where() .","title":"Filtrado de base"},{"location":"python/basico/#ordenando-una-base","text":"Para ordenar una base, se usa el m\u00e9todo sort.values() en donde se le pasa una lista con los nombres de las variables a ordenar. El siguiente c\u00f3digo muestra su uso. Note que el m\u00e9todo requiere al menos el argumento by y se pide que guarde la base ordenada en un nuevo objeto dataframe . 1 2 base_ord = mi_base . sort_values ( by = [ \"nombre\" ]) print ( datos_ord ) La siguiente imagen muestra el resultado, note que la base se ha guardado en un nuevo objeto. Para m\u00e1s informaci\u00f3n acerca del m\u00e9todo sort.values() consulte la documentaci\u00f3n del m\u00e9todo sort_values .","title":"Ordenando una base"},{"location":"python/basico/#datos-agrupados","text":"En el paquete pandas tambi\u00e9n se incluye un m\u00e9todo para crear datos agrupados por una o m\u00e1s variables. El siguiente c\u00f3digo muestra su uso 1 mi_base_agrupada = mi_base . groupby ( by = [ \"grupo\" ]) objeto retornado El m\u00e9todo groupby regresa un objeto DataFrameGroupBy , por lo que no podr\u00eda ser visualizado. Este objeto se suele utilizar para realizar agregados por cada grupo. Los datos agrupados son \u00fatiles para obtener estad\u00edsticas descriptivas por grupos. El siguiente ejemplo ejemplifica su uso mediante el m\u00e9todo aggregate() . 1 mi_base_agrupada . aggregate ([ \"mean\" ]) Para m\u00e1s informaci\u00f3n visite la documentaci\u00f3n del m\u00e9todo groupby y c\u00f3mo realizar agregados.","title":"Datos agrupados"},{"location":"python/intro_python/","text":"Introducci\u00f3n \u00b6 Este es un tutorial r\u00e1pido sobre el programa enfocado principalmente al manejo de datos y temas relacionados con ciencias de datos. Python es un lenguaje que se emplea mucho en diversas \u00e1reas, sin embargo recientemente se ha vuelto muy popular en las \u00e1reas de ciencias de datos. Por esa raz\u00f3n hoy en d\u00eda es pr\u00e1cticamente indispensable tener conocimientos en el programa. Iconos dise\u00f1ados por Freepik from Flaticon Instalaci\u00f3n e interfaces gr\u00e1ficas \u00b6 El sitio oficial de Python es python.org , sin embargo se recomienda instalar Anaconda , una distribuci\u00f3n de Python que contiene muchos m\u00f3dulos y software adicional para trabajar con Python. Descarga Usted puede descargar el software gratuitamente. Visite la p\u00e1gina de Anaconda para m\u00e1s informaci\u00f3n. Python corre desde la consola de windows (cmd o powershell), aunque puede ser llamada desde Anaconda Prompt o Anaconda Powershell Prompt . Spyder es otra interfaz gr\u00e1fica destinada a desarrollar c\u00f3digo eficientemente, ya que cuenta con varias opciones de configuraci\u00f3n y ventanas con varias funciones. Esta interfaz gr\u00e1fica ya viene incluida en Anaconda. Python tiene unos cuadernos interactivos para correr c\u00f3digo al instante llamados Jupyter Notebooks , este software se instala junto con Anaconda y permite ejecutar no s\u00f3lo c\u00f3digo de python, sino que tiene plugins llamados kernel que permiten ejecutar c\u00f3digo de otros lenguajes. Tambi\u00e9n es posible usar python en Visual Studio Code , usando la extensi\u00f3n de Python . Cuando un c\u00f3digo de es ejecutado, se abre una consola que ejecuta el c\u00f3digo directamente en VSC. El uso del depurador tambi\u00e9n es una caracter\u00edstica importante que se puede usar. Tambi\u00e9n es posible crear, editar y ejecutar los cuadernos de Python desde VSC. Objetos \u00b6 Al ser Python un lenguaje orientado a objetos, es necesario conocer sus objetos y algunas de sus propiedades. Variables \u00b6 Las variables son objetos que permiten almacenar un valor. Se pueden declarar usando el operador = , por ejemplo 1 2 3 x = 5 y = 2.15 a = \"hola\" Para conocer el tipo de variable, se usa la funci\u00f3n type , por ejemplo 1 2 3 type ( x ) type ( y ) type ( a ) La siguiente tabla muestra algunos de los tipos de datos que existen. Ejemplo Tipo x = \u201cHola Mundo!\u201d str x = 20 int x = 20.5 float x = 1j complex x = True bool Los objetos tienen m\u00e9todos, por ejemplo, los objetos tipo str tienen m\u00e9todos que los convierten en may\u00fasculas, por ejemplo 1 a . upper () Consulte los m\u00e9todos de las cadenas para saber m\u00e1s acerca de sus propiedades. Listas \u00b6 Uno de los principales objetos en python son las listas. Las listas permiten guardar varios valores en una sola variable, adem\u00e1s sus elementos est\u00e1n ordenados y pueden ser intercambiables. Una lista puede ser vista como un arreglo que permite valores duplicados. Por ejemplo para crear una lista se puede declarar de la siguiente forma: 1 2 mi_lista = [ \"manzana\" , \"naranja\" , \"pera\" , \"uva\" ] print ( mi_lista ) El resultado que se obtiene es el siguiente: [\u2018manzana\u2019, \u2018naranja\u2019, \u2018pera\u2019, \u2018uva\u2019] \u00cdndices A diferencia de otros lenguajes de programaci\u00f3n, el primer elemento de un objeto es el 0 y no el 1. Para acceder a un elemento de una lista, se puede usar [] con el \u00edndice del elemento, tambi\u00e9n se puede definir un rango con : . 1 2 3 mi_lista [ 0 ] mi_lista [: 1 ] mi_lista [ 2 :] Para agregar un nuevo elemento a una lista, se puede usar el m\u00e9todo append . 1 2 mi_lista . append ( \"fresa\" ) mi_lista El resultado es el siguiente: [\u2018manzana\u2019, \u2018naranja\u2019, \u2018pera\u2019, \u2018uva\u2019, \u2018fresa\u2019] Para una referencia completa acerca de las lista consulte Listas de Python . Diccionarios \u00b6 Otro tipo de arreglo que existe en python son los diccionarios. Los diccionarios son un arreglo conformado por pares de claves y valores . Los elementos de un diccionario est\u00e1n dentro de llaves {} separados por comas, y se usa dos puntos para asignar el valor a la clave. El siguiente ejemplo muestra un diccionario. 1 2 3 4 5 dic = { \"nombre\" : \"Juan\" , \"apellido\" : \"P\u00e9rez\" , \"edad\" : 30 } Los valores pueden ser una lista, por ejemplo: 1 2 3 4 5 6 7 sexo = [ \"M\" , \"F\" , \"M\" ] dic = { \"nombre\" : [ \"Juan\" , \"Mar\u00eda\" , \"Jos\u00e9\" ], \"apellido\" : [ \"P\u00e9rez\" , \"Mart\u00ednez\" , \"P\u00e9rez\" ], \"edad\" : [ 30 , 50 , 45 ], \"genero\" : sexo } El resultado se muestra a continuaci\u00f3n. Claves \u00fanicas Los diccionarios no permiten tener claves duplicadas, si se agrega una clave ya existente, se mantendr\u00e1 la m\u00e1s reciente. Las claves funcionan como el nombre de variable en una tabla. Es posible acceder a los elementos de un diccionario mediante sus claves, por ejemplo, para saber el nombre, se puede escribir 1 dic [ \"nombre\" ] Para agregar nuevas claves, simplemente se agrega la nueva clave al diccionario con los valores deseados, por ejemplo 1 2 dic [ \"ocupacion\" ] = [ \"Contador\" , \"Gerente\" , \"Profesor\" ] dic Para una referencia completa acerca de los diccionarios consulte Diccionario de Python . Ciclos \u00b6 Los ciclos en python permiten iterar en cualquier secuencia, por ejemplo una cadena, una lista o un diccionario. El siguiente ejemplo muestra el funcionamiento de un ciclo sobre una lista. 1 2 3 frutas = [ \"manzana\" , \"naranja\" , \"pera\" , \"uva\" , \"papaya\" ] for x in frutas : print ( x ) Note que x toma el valor de cada elemento de la lista y en cada iteraci\u00f3n se imprime su valor. El ciclo termina cuando ya no hay elementos en la lista. El resultado de muestra a continuaci\u00f3n: Visite ciclos en python para saber m\u00e1s acerca de c\u00f3mo funcionan los ciclos. Paquetes \u00b6 La mayor\u00eda de los paquetes usados en ciencia de datos, son instalados mediante uando se instala Anaconda, por lo que solo es necesario llamar los paquetes necesarios. Por ejemplo, para usar las librer\u00edas pandas y numpy y otra librer\u00eda adicional llamada os se puede ejecutar el siguiente c\u00f3digo. 1 2 3 import pandas as pd import numpy as np import os Nota En ocasiones es preferible usar nombres m\u00e1s cortos para referirnos a los nombres de las librer\u00edas. Por ejemplo, a pandas le llamaremos pd y np para referirnos a numpy . si solo se desea llamar una funci\u00f3n , se puede ejecutar el siguiente c\u00f3digo. 1 from pandas import read_csv Sin embargo, se puede instalar paquetes adicionales desde la consola con los siguientes comandos: 1 pip install paquete","title":"Introducci\u00f3n a Python"},{"location":"python/intro_python/#introduccion","text":"Este es un tutorial r\u00e1pido sobre el programa enfocado principalmente al manejo de datos y temas relacionados con ciencias de datos. Python es un lenguaje que se emplea mucho en diversas \u00e1reas, sin embargo recientemente se ha vuelto muy popular en las \u00e1reas de ciencias de datos. Por esa raz\u00f3n hoy en d\u00eda es pr\u00e1cticamente indispensable tener conocimientos en el programa. Iconos dise\u00f1ados por Freepik from Flaticon","title":"Introducci\u00f3n"},{"location":"python/intro_python/#instalacion-e-interfaces-graficas","text":"El sitio oficial de Python es python.org , sin embargo se recomienda instalar Anaconda , una distribuci\u00f3n de Python que contiene muchos m\u00f3dulos y software adicional para trabajar con Python. Descarga Usted puede descargar el software gratuitamente. Visite la p\u00e1gina de Anaconda para m\u00e1s informaci\u00f3n. Python corre desde la consola de windows (cmd o powershell), aunque puede ser llamada desde Anaconda Prompt o Anaconda Powershell Prompt . Spyder es otra interfaz gr\u00e1fica destinada a desarrollar c\u00f3digo eficientemente, ya que cuenta con varias opciones de configuraci\u00f3n y ventanas con varias funciones. Esta interfaz gr\u00e1fica ya viene incluida en Anaconda. Python tiene unos cuadernos interactivos para correr c\u00f3digo al instante llamados Jupyter Notebooks , este software se instala junto con Anaconda y permite ejecutar no s\u00f3lo c\u00f3digo de python, sino que tiene plugins llamados kernel que permiten ejecutar c\u00f3digo de otros lenguajes. Tambi\u00e9n es posible usar python en Visual Studio Code , usando la extensi\u00f3n de Python . Cuando un c\u00f3digo de es ejecutado, se abre una consola que ejecuta el c\u00f3digo directamente en VSC. El uso del depurador tambi\u00e9n es una caracter\u00edstica importante que se puede usar. Tambi\u00e9n es posible crear, editar y ejecutar los cuadernos de Python desde VSC.","title":"Instalaci\u00f3n e interfaces gr\u00e1ficas"},{"location":"python/intro_python/#objetos","text":"Al ser Python un lenguaje orientado a objetos, es necesario conocer sus objetos y algunas de sus propiedades.","title":"Objetos"},{"location":"python/intro_python/#variables","text":"Las variables son objetos que permiten almacenar un valor. Se pueden declarar usando el operador = , por ejemplo 1 2 3 x = 5 y = 2.15 a = \"hola\" Para conocer el tipo de variable, se usa la funci\u00f3n type , por ejemplo 1 2 3 type ( x ) type ( y ) type ( a ) La siguiente tabla muestra algunos de los tipos de datos que existen. Ejemplo Tipo x = \u201cHola Mundo!\u201d str x = 20 int x = 20.5 float x = 1j complex x = True bool Los objetos tienen m\u00e9todos, por ejemplo, los objetos tipo str tienen m\u00e9todos que los convierten en may\u00fasculas, por ejemplo 1 a . upper () Consulte los m\u00e9todos de las cadenas para saber m\u00e1s acerca de sus propiedades.","title":"Variables"},{"location":"python/intro_python/#listas","text":"Uno de los principales objetos en python son las listas. Las listas permiten guardar varios valores en una sola variable, adem\u00e1s sus elementos est\u00e1n ordenados y pueden ser intercambiables. Una lista puede ser vista como un arreglo que permite valores duplicados. Por ejemplo para crear una lista se puede declarar de la siguiente forma: 1 2 mi_lista = [ \"manzana\" , \"naranja\" , \"pera\" , \"uva\" ] print ( mi_lista ) El resultado que se obtiene es el siguiente: [\u2018manzana\u2019, \u2018naranja\u2019, \u2018pera\u2019, \u2018uva\u2019] \u00cdndices A diferencia de otros lenguajes de programaci\u00f3n, el primer elemento de un objeto es el 0 y no el 1. Para acceder a un elemento de una lista, se puede usar [] con el \u00edndice del elemento, tambi\u00e9n se puede definir un rango con : . 1 2 3 mi_lista [ 0 ] mi_lista [: 1 ] mi_lista [ 2 :] Para agregar un nuevo elemento a una lista, se puede usar el m\u00e9todo append . 1 2 mi_lista . append ( \"fresa\" ) mi_lista El resultado es el siguiente: [\u2018manzana\u2019, \u2018naranja\u2019, \u2018pera\u2019, \u2018uva\u2019, \u2018fresa\u2019] Para una referencia completa acerca de las lista consulte Listas de Python .","title":"Listas"},{"location":"python/intro_python/#diccionarios","text":"Otro tipo de arreglo que existe en python son los diccionarios. Los diccionarios son un arreglo conformado por pares de claves y valores . Los elementos de un diccionario est\u00e1n dentro de llaves {} separados por comas, y se usa dos puntos para asignar el valor a la clave. El siguiente ejemplo muestra un diccionario. 1 2 3 4 5 dic = { \"nombre\" : \"Juan\" , \"apellido\" : \"P\u00e9rez\" , \"edad\" : 30 } Los valores pueden ser una lista, por ejemplo: 1 2 3 4 5 6 7 sexo = [ \"M\" , \"F\" , \"M\" ] dic = { \"nombre\" : [ \"Juan\" , \"Mar\u00eda\" , \"Jos\u00e9\" ], \"apellido\" : [ \"P\u00e9rez\" , \"Mart\u00ednez\" , \"P\u00e9rez\" ], \"edad\" : [ 30 , 50 , 45 ], \"genero\" : sexo } El resultado se muestra a continuaci\u00f3n. Claves \u00fanicas Los diccionarios no permiten tener claves duplicadas, si se agrega una clave ya existente, se mantendr\u00e1 la m\u00e1s reciente. Las claves funcionan como el nombre de variable en una tabla. Es posible acceder a los elementos de un diccionario mediante sus claves, por ejemplo, para saber el nombre, se puede escribir 1 dic [ \"nombre\" ] Para agregar nuevas claves, simplemente se agrega la nueva clave al diccionario con los valores deseados, por ejemplo 1 2 dic [ \"ocupacion\" ] = [ \"Contador\" , \"Gerente\" , \"Profesor\" ] dic Para una referencia completa acerca de los diccionarios consulte Diccionario de Python .","title":"Diccionarios"},{"location":"python/intro_python/#ciclos","text":"Los ciclos en python permiten iterar en cualquier secuencia, por ejemplo una cadena, una lista o un diccionario. El siguiente ejemplo muestra el funcionamiento de un ciclo sobre una lista. 1 2 3 frutas = [ \"manzana\" , \"naranja\" , \"pera\" , \"uva\" , \"papaya\" ] for x in frutas : print ( x ) Note que x toma el valor de cada elemento de la lista y en cada iteraci\u00f3n se imprime su valor. El ciclo termina cuando ya no hay elementos en la lista. El resultado de muestra a continuaci\u00f3n: Visite ciclos en python para saber m\u00e1s acerca de c\u00f3mo funcionan los ciclos.","title":"Ciclos"},{"location":"python/intro_python/#paquetes","text":"La mayor\u00eda de los paquetes usados en ciencia de datos, son instalados mediante uando se instala Anaconda, por lo que solo es necesario llamar los paquetes necesarios. Por ejemplo, para usar las librer\u00edas pandas y numpy y otra librer\u00eda adicional llamada os se puede ejecutar el siguiente c\u00f3digo. 1 2 3 import pandas as pd import numpy as np import os Nota En ocasiones es preferible usar nombres m\u00e1s cortos para referirnos a los nombres de las librer\u00edas. Por ejemplo, a pandas le llamaremos pd y np para referirnos a numpy . si solo se desea llamar una funci\u00f3n , se puede ejecutar el siguiente c\u00f3digo. 1 from pandas import read_csv Sin embargo, se puede instalar paquetes adicionales desde la consola con los siguientes comandos: 1 pip install paquete","title":"Paquetes"},{"location":"r/basico_r/","text":"Introducci\u00f3n \u00b6 En esta secci\u00f3n se aprender\u00e1 la forma de leer y manejar datos en R, ya sea usando las funciones o usando filtros para obtener la informaci\u00f3n deseada. Lectura de datos \u00b6 R tiene objetos dedicados al manejo de datos, por ejemplo el objeto data.frame , aunque tambien pueden usarse otros paquetes para el mismo fin. En esta secci\u00f3n se mostrar\u00e1 la forma de crear datasets y leer archivos externos en R. Lectura de datos externos en R \u00b6 R tiene muchos paquetes que permiten leer una gran cantidad de tipos de archivos externos. El tipo de archivos m\u00e1s com\u00fan es el archivo delimitado por comas o CSV. El siguiente c\u00f3digo muestra como leer un archivo externo. 1 census <- read.csv ( \"C:/Users/Usuario/census.csv\" ) El resultado se muestra a continuaci\u00f3n. Asistente de importaci\u00f3n RStudio cuenta un asistente de importaci\u00f3n que nos permite visualizar los datos que se van a importar o seleccionar el tipo de dato. Leer archivos de excel \u00b6 Para leer archivos es formato de Excel, se puede hacer uso de la librer\u00eda readxl y la funci\u00f3n read_excel . El siguiente c\u00f3digo muestra su uso: 1 2 library ( readxl ) census <- read_excel ( \"census.xlsx\" ) Para m\u00e1s informaci\u00f3n visite readxl . Importar datos otros softwares \u00b6 El paquete haven permite leer y escribir bases de diversos archivos. El siguiente c\u00f3digo muestra como importar un archivo de SAS \u00ae software . 1 2 library ( haven ) customer <- read_sas ( \"customer.sas7bdat\" , NULL ) Para m\u00e1s informaci\u00f3n visite haven . Manipulaci\u00f3n de datos \u00b6 En esta secci\u00f3n se abordar\u00e1 el tema de manejo y manipulaci\u00f3n de bases en R. Para ello es necesario conocer un poco acerca de la base con la que se estar\u00e1 trabajando. Posteriormente se conocer\u00e1n las distintas formas de filtrar datos y realizar otro tipo de operaciones. Exploraci\u00f3n de datos \u00b6 Una forma de saber el tipo de datos que se ha importado es mediante el comando class() , este comando nos devolver\u00e1 el nombre de la estructura correspondiente en R. Para conocer la dimensi\u00f3n del objeto, se puede usar el comando dim() . Dimensiones Otra forma de saber las dimensiones de una base es mediante los comandos nrow() y ncol() . Si se desea conocer un resumen con estad\u00edsticas descriptivas, se puede usar el comando summary . Los siguientes c\u00f3digos ilustran los comandos previos: 1 2 3 class ( census ) dim ( census ) summary ( census ) Para conocer el nombre de las variables de un dataset, se puede usar el comando names() , por ejemplo 1 names ( census ) Es posible referirse a los nombres de las variables usando el comando attach , es decir 1 attach ( census ) Cuidado con los nombres iguales Si dos o m\u00e1s variables tienen el mismo nombre, se usar\u00e1 la variable de la nueva base. Otra forma de visualizar los datos es mediante el uso de las funciones head() y tail() . Estas nos permiten ver el contenido de un dataset sin saturar la ventana de resultados. Las funciones solo requieren que se le pase el nombre del dataframe y opcionalmente el n\u00famero de registros a visualizar. Filtrado de datos \u00b6 Para realizar un filtrado de datos en R, se pueden usar los vectores l\u00f3gicos, de esta forma, aquellas observaciones que cumplan con la condici\u00f3n, ser\u00e1n las observaciones elegidas. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo elegir a los alumnos que pertenecen al grupo A 1 2 filtro = datos $ grupo == \"A\" grupo_A = datos [ filtro ,] Esto tambi\u00e9n se puede hacer en una sola operaci\u00f3n, pas\u00e1ndole directamente la expresi\u00f3n. 1 grupo_A = datos [ datos $ grupo == \"A\" ,] El siguiente cuadro muestra los operadores l\u00f3gicos que existen en R Operador Nombre Ejemplo == Igual a x == \"A\" < Menor que x < 5 > Mayor que x > 5 <= Menor o igual a x <= 5 >= Mayor o igual a x >= 5 != No es igual a x != \"A\" Adicionalmente existe el operador %in% que nos ayuda a seleccionar varios valores que est\u00e9n en un vector, por ejemplo para seleccionar alumnos que pertenezcan al grupo \u201cA\u201d o \u201cC\u201d, se puede usar el siguiente c\u00f3digo: 1 2 filtro = datos $ grupo %in% c ( \"A\" , \"C\" ) datos [ filtro ,] Para m\u00e1s informaci\u00f3n consulte la ayuda con el comando ?match . Recodificaci\u00f3n de variables \u00b6 Si se desea recodificar variables, se puede usar la funci\u00f3n ifelse() para crear una nueva variable en un dataframe. Por ejemplo, sup\u00f3ngase que la base datos contiene la variable sexo con el valor 1 para mujeres y el 2 para hombre, se puede crear la variable genero que tenga el valor \u201cF\u201d para mujeres y \u201cM\u201d para hombres, como se muestra en el siguiente c\u00f3digo. 1 datos $ genero = ifelse ( datos $ sexo == 1 , \"F\" , \"M\" ) Si se tienen m\u00e1s de 2 categor\u00edas, se pueden anexar dentro de la funci\u00f3n otra funci\u00f3n ifelse() en el tercer argumento, por ejemplo: 1 2 datos $ Calificacion = ifelse ( datos $ puntaje >= 9 , \"Excelente\" , ifelse ( datos $ puntaje == 8 , \"Bueno\" , \"Suficiente\" )) Para m\u00e1s informaci\u00f3n, vea la ayuda con el comando ?ifelse . Transformaci\u00f3n de bases \u00b6 En ocasiones es necesario ordenar los datos que est\u00e1n agrupados en formato largo o en formato amplio . Estos datos se usan usualmente cuando se tiene informaci\u00f3n de individuos a lo largo del tiempo. Considere la siguiente tabla que est\u00e1 en formato largo. nombre materia puntaje ANGELICA Espa\u00f1ol 10 ANGELICA Matem\u00e1ticas 9 ANGELICA Biolog\u00eda 8 BRENDA Espa\u00f1ol 8 BRENDA Matem\u00e1ticas 9 BRENDA Biolog\u00eda 7 LILIANA Espa\u00f1ol 10 LILIANA Matem\u00e1ticas 8 LILIANA Biolog\u00eda 9 Si se desea transformar esta base en formato amplio, se puede usar el siguiente c\u00f3digo. 1 datost = reshape ( datos , direction = \"wide\" , idvar = \"nombre\" , timevar = \"materia\" ) La funci\u00f3n reshape() transforma el dataset datos a un formato amplio, esto se logra con la instrucci\u00f3n direction = \"wide\" . El individuo considerado se especifica con idvar = \"nombre\" . Finalmente la variable que ser\u00e1 convertida a columna ser\u00e1 timevar = \"materia\" . Note que los valores de puntaje ser\u00e1n los que ser\u00e1n movidos en el orden correspondiente. El resultado se muestra a continuaci\u00f3n. Para conocer m\u00e1s sobre la funci\u00f3n escriba el comando ?reshape . Uniones de bases \u00b6 Cuando se tiene informaci\u00f3n en 2 o m\u00e1s bases, es posible unirlas mediante una variable llave. datos: nombre sex grupo puntaje ANGELICA 1 A 10 BRENDA 1 A 9 LILIANA 1 B 8 MARCO 2 B 8 FABIAN 2 C 9 MAURICIO 2 C 7 info: nombre apellido edad ANGELICA \u00c1lvarez 20 BRENDA Aguilar 19 LILIANA S\u00e1nchez 18 MARCO Z\u00fa\u00f1iga 18 FABIAN Castillo 29 MAURICIO P\u00e9rez 27 Para ejecutar esto en R, se puede usar la funci\u00f3n merge() . Esta funci\u00f3n requiere como argumentos, las base a unir as\u00ed como especificar el nombre de la llave. El siguiente ejemplo muestra c\u00f3mo unir las 2 tablas usando la variable nombre como llave. 1 datos2 = merge ( datos , info , by = \"nombre\" ) El resultado se muestra a continuaci\u00f3n. Para m\u00e1s informaci\u00f3n use el comando ?merge para conocer c\u00f3mo realizar otro tipo de uniones. Ordenando una base \u00b6 La forma de ordenar una base en R,es un poco distinta a otros lenguajes de programaci\u00f3n, debido a que R no tiene una funci\u00f3n para ordenar un dataframe, sin embargo se puede lograr con la instrucci\u00f3n order() y posteriormente pasarle el resultado como un \u00eddice de renglones, por lo que la base estar\u00e1 ordenada. El siguiente ejemplo muestra c\u00f3mo ordenar la base de alumnos por el nombre. 1 2 by_nombre = order ( datos $ nombre ) datos_ord = datos [ by_nombre ,] Primero se construye un vector que contiene los \u00edndices de las observaciones ya ordenadas. En la siguiente l\u00ednea se crea una copia del dataframe con dichos \u00edndices, por lo que el nuevo dataframe ya estar\u00e1 ordenado. Para saber m\u00e1s acerca del ordenamiento de variables, consulte la ayuda escribiendo ?order en la consola.","title":"R nivel b\u00e1sico"},{"location":"r/basico_r/#introduccion","text":"En esta secci\u00f3n se aprender\u00e1 la forma de leer y manejar datos en R, ya sea usando las funciones o usando filtros para obtener la informaci\u00f3n deseada.","title":"Introducci\u00f3n"},{"location":"r/basico_r/#lectura-de-datos","text":"R tiene objetos dedicados al manejo de datos, por ejemplo el objeto data.frame , aunque tambien pueden usarse otros paquetes para el mismo fin. En esta secci\u00f3n se mostrar\u00e1 la forma de crear datasets y leer archivos externos en R.","title":"Lectura de datos"},{"location":"r/basico_r/#lectura-de-datos-externos-en-r","text":"R tiene muchos paquetes que permiten leer una gran cantidad de tipos de archivos externos. El tipo de archivos m\u00e1s com\u00fan es el archivo delimitado por comas o CSV. El siguiente c\u00f3digo muestra como leer un archivo externo. 1 census <- read.csv ( \"C:/Users/Usuario/census.csv\" ) El resultado se muestra a continuaci\u00f3n. Asistente de importaci\u00f3n RStudio cuenta un asistente de importaci\u00f3n que nos permite visualizar los datos que se van a importar o seleccionar el tipo de dato.","title":"Lectura de datos externos en R"},{"location":"r/basico_r/#leer-archivos-de-excel","text":"Para leer archivos es formato de Excel, se puede hacer uso de la librer\u00eda readxl y la funci\u00f3n read_excel . El siguiente c\u00f3digo muestra su uso: 1 2 library ( readxl ) census <- read_excel ( \"census.xlsx\" ) Para m\u00e1s informaci\u00f3n visite readxl .","title":"Leer archivos de excel"},{"location":"r/basico_r/#importar-datos-otros-softwares","text":"El paquete haven permite leer y escribir bases de diversos archivos. El siguiente c\u00f3digo muestra como importar un archivo de SAS \u00ae software . 1 2 library ( haven ) customer <- read_sas ( \"customer.sas7bdat\" , NULL ) Para m\u00e1s informaci\u00f3n visite haven .","title":"Importar datos otros softwares"},{"location":"r/basico_r/#manipulacion-de-datos","text":"En esta secci\u00f3n se abordar\u00e1 el tema de manejo y manipulaci\u00f3n de bases en R. Para ello es necesario conocer un poco acerca de la base con la que se estar\u00e1 trabajando. Posteriormente se conocer\u00e1n las distintas formas de filtrar datos y realizar otro tipo de operaciones.","title":"Manipulaci\u00f3n de datos"},{"location":"r/basico_r/#exploracion-de-datos","text":"Una forma de saber el tipo de datos que se ha importado es mediante el comando class() , este comando nos devolver\u00e1 el nombre de la estructura correspondiente en R. Para conocer la dimensi\u00f3n del objeto, se puede usar el comando dim() . Dimensiones Otra forma de saber las dimensiones de una base es mediante los comandos nrow() y ncol() . Si se desea conocer un resumen con estad\u00edsticas descriptivas, se puede usar el comando summary . Los siguientes c\u00f3digos ilustran los comandos previos: 1 2 3 class ( census ) dim ( census ) summary ( census ) Para conocer el nombre de las variables de un dataset, se puede usar el comando names() , por ejemplo 1 names ( census ) Es posible referirse a los nombres de las variables usando el comando attach , es decir 1 attach ( census ) Cuidado con los nombres iguales Si dos o m\u00e1s variables tienen el mismo nombre, se usar\u00e1 la variable de la nueva base. Otra forma de visualizar los datos es mediante el uso de las funciones head() y tail() . Estas nos permiten ver el contenido de un dataset sin saturar la ventana de resultados. Las funciones solo requieren que se le pase el nombre del dataframe y opcionalmente el n\u00famero de registros a visualizar.","title":"Exploraci\u00f3n de datos"},{"location":"r/basico_r/#filtrado-de-datos","text":"Para realizar un filtrado de datos en R, se pueden usar los vectores l\u00f3gicos, de esta forma, aquellas observaciones que cumplan con la condici\u00f3n, ser\u00e1n las observaciones elegidas. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo elegir a los alumnos que pertenecen al grupo A 1 2 filtro = datos $ grupo == \"A\" grupo_A = datos [ filtro ,] Esto tambi\u00e9n se puede hacer en una sola operaci\u00f3n, pas\u00e1ndole directamente la expresi\u00f3n. 1 grupo_A = datos [ datos $ grupo == \"A\" ,] El siguiente cuadro muestra los operadores l\u00f3gicos que existen en R Operador Nombre Ejemplo == Igual a x == \"A\" < Menor que x < 5 > Mayor que x > 5 <= Menor o igual a x <= 5 >= Mayor o igual a x >= 5 != No es igual a x != \"A\" Adicionalmente existe el operador %in% que nos ayuda a seleccionar varios valores que est\u00e9n en un vector, por ejemplo para seleccionar alumnos que pertenezcan al grupo \u201cA\u201d o \u201cC\u201d, se puede usar el siguiente c\u00f3digo: 1 2 filtro = datos $ grupo %in% c ( \"A\" , \"C\" ) datos [ filtro ,] Para m\u00e1s informaci\u00f3n consulte la ayuda con el comando ?match .","title":"Filtrado de datos"},{"location":"r/basico_r/#recodificacion-de-variables","text":"Si se desea recodificar variables, se puede usar la funci\u00f3n ifelse() para crear una nueva variable en un dataframe. Por ejemplo, sup\u00f3ngase que la base datos contiene la variable sexo con el valor 1 para mujeres y el 2 para hombre, se puede crear la variable genero que tenga el valor \u201cF\u201d para mujeres y \u201cM\u201d para hombres, como se muestra en el siguiente c\u00f3digo. 1 datos $ genero = ifelse ( datos $ sexo == 1 , \"F\" , \"M\" ) Si se tienen m\u00e1s de 2 categor\u00edas, se pueden anexar dentro de la funci\u00f3n otra funci\u00f3n ifelse() en el tercer argumento, por ejemplo: 1 2 datos $ Calificacion = ifelse ( datos $ puntaje >= 9 , \"Excelente\" , ifelse ( datos $ puntaje == 8 , \"Bueno\" , \"Suficiente\" )) Para m\u00e1s informaci\u00f3n, vea la ayuda con el comando ?ifelse .","title":"Recodificaci\u00f3n de variables"},{"location":"r/basico_r/#transformacion-de-bases","text":"En ocasiones es necesario ordenar los datos que est\u00e1n agrupados en formato largo o en formato amplio . Estos datos se usan usualmente cuando se tiene informaci\u00f3n de individuos a lo largo del tiempo. Considere la siguiente tabla que est\u00e1 en formato largo. nombre materia puntaje ANGELICA Espa\u00f1ol 10 ANGELICA Matem\u00e1ticas 9 ANGELICA Biolog\u00eda 8 BRENDA Espa\u00f1ol 8 BRENDA Matem\u00e1ticas 9 BRENDA Biolog\u00eda 7 LILIANA Espa\u00f1ol 10 LILIANA Matem\u00e1ticas 8 LILIANA Biolog\u00eda 9 Si se desea transformar esta base en formato amplio, se puede usar el siguiente c\u00f3digo. 1 datost = reshape ( datos , direction = \"wide\" , idvar = \"nombre\" , timevar = \"materia\" ) La funci\u00f3n reshape() transforma el dataset datos a un formato amplio, esto se logra con la instrucci\u00f3n direction = \"wide\" . El individuo considerado se especifica con idvar = \"nombre\" . Finalmente la variable que ser\u00e1 convertida a columna ser\u00e1 timevar = \"materia\" . Note que los valores de puntaje ser\u00e1n los que ser\u00e1n movidos en el orden correspondiente. El resultado se muestra a continuaci\u00f3n. Para conocer m\u00e1s sobre la funci\u00f3n escriba el comando ?reshape .","title":"Transformaci\u00f3n de bases"},{"location":"r/basico_r/#uniones-de-bases","text":"Cuando se tiene informaci\u00f3n en 2 o m\u00e1s bases, es posible unirlas mediante una variable llave. datos: nombre sex grupo puntaje ANGELICA 1 A 10 BRENDA 1 A 9 LILIANA 1 B 8 MARCO 2 B 8 FABIAN 2 C 9 MAURICIO 2 C 7 info: nombre apellido edad ANGELICA \u00c1lvarez 20 BRENDA Aguilar 19 LILIANA S\u00e1nchez 18 MARCO Z\u00fa\u00f1iga 18 FABIAN Castillo 29 MAURICIO P\u00e9rez 27 Para ejecutar esto en R, se puede usar la funci\u00f3n merge() . Esta funci\u00f3n requiere como argumentos, las base a unir as\u00ed como especificar el nombre de la llave. El siguiente ejemplo muestra c\u00f3mo unir las 2 tablas usando la variable nombre como llave. 1 datos2 = merge ( datos , info , by = \"nombre\" ) El resultado se muestra a continuaci\u00f3n. Para m\u00e1s informaci\u00f3n use el comando ?merge para conocer c\u00f3mo realizar otro tipo de uniones.","title":"Uniones de bases"},{"location":"r/basico_r/#ordenando-una-base","text":"La forma de ordenar una base en R,es un poco distinta a otros lenguajes de programaci\u00f3n, debido a que R no tiene una funci\u00f3n para ordenar un dataframe, sin embargo se puede lograr con la instrucci\u00f3n order() y posteriormente pasarle el resultado como un \u00eddice de renglones, por lo que la base estar\u00e1 ordenada. El siguiente ejemplo muestra c\u00f3mo ordenar la base de alumnos por el nombre. 1 2 by_nombre = order ( datos $ nombre ) datos_ord = datos [ by_nombre ,] Primero se construye un vector que contiene los \u00edndices de las observaciones ya ordenadas. En la siguiente l\u00ednea se crea una copia del dataframe con dichos \u00edndices, por lo que el nuevo dataframe ya estar\u00e1 ordenado. Para saber m\u00e1s acerca del ordenamiento de variables, consulte la ayuda escribiendo ?order en la consola.","title":"Ordenando una base"},{"location":"r/intro_r/","text":"Introducci\u00f3n a R \u00b6 Este es un tutorial b\u00e1sico sobre el programa. Visite la p\u00e1gina de R para m\u00e1s informaci\u00f3n. R es un lenguaje de programaci\u00f3n para c\u00f3mputo estad\u00edstico. Tiene una gran cantidad de funciones que permiten ejecutar an\u00e1lisis estad\u00edsticos tradicionales, tales como regresi\u00f3n y modelos lineales, pruebas estad\u00edsticas, clasificaci\u00f3n, an\u00e1lisis de series de tiempo, entre otros. Una ventaja de R es que es altamente extensible a traves de paquetes que cualquier persona puede crear y aportar. R es un software libre y es ampliamente usado en el \u00e1mbito acad\u00e9mico e incluso en algunas empresas. Objetos de R \u00b6 R es un lenguaje de programaci\u00f3n que usa objetos. Estos objetos tienen identidad, atributos y propiedades. Tambien puede considerarse como un int\u00e9rprete, es decir que espera acciones del usuario. Cuando el usuario ejecuta comandos, R los ejecuta l\u00ednea por l\u00ednea. Los comandos o expresiones m\u00e1s comunes son las asignaciones, es decir se asigna un valor a una variables. Cada comando suele escribirse en una sola l\u00ednea o terminar con punto y coma. R es un lenguaje sensible a may\u00fasculas y min\u00fasculas, esto es un factor a tomar en cuenta para evitar errores. Interaz gr\u00e1fica R tiene una interfaz gr\u00e1fica para crear c\u00f3digo de forma m\u00e1s amigable. Visite R Studio para m\u00e1s informaci\u00f3n. Cuando se inicia una sesi\u00f3n, se asigna un espacio de trabajo (workspace) en memoria y un directorio de trabajo (working directory). El espacio de trabajo sirve para almacenar objetos creados, tales como vectores, funciones entre otros. Para conocer el directorio de trabajo puede escribir en consola: 1 getwd () Para cambiar use la funci\u00f3n setwd(\"dir\") , donde dir es el nuevo directorio. Barras verticales R no reconoce una sola barra / en los directorios de windows. Use doble barra // o una barra invertida \\ . Vectores \u00b6 Un vector es un objeto con uno o m\u00e1s elementos. Puede contener elementos num\u00e9ricos o caracteres. Se pueden crear vectores con la funci\u00f3n c() , por ejemplo: 1 2 x = c ( 2 , 1 , 5 ) z = c ( \"ABC\" , \"AEI\" , \"XYZ\" ) Los vectores permiten algunas operaciones, las m\u00e1s comunes son la suma + , resta - , multiplicaci\u00f3n * , divisi\u00f3n. / y potencia ^ , as\u00ed como valores booleanos. 1 2 y = m * x + n xy = x > y Operaci\u00f3n entre vectores Las operaciones entre vectores son elemento a elemento. Si los elementos no tuvieran el mismo tama\u00f1o, el de menor tama\u00f1o se recicla (repite sus elementos) hasta tener el mismo n\u00famero de elementos. Por ejemplo, la operaci\u00f3n nx = n + x dar\u00e1 como resultado: [1] 7 6 10 Los vectores tienen una dimensi\u00f3n y para conocerla se puede usar la funci\u00f3n length() . Por ejemplo length(x) nos dar\u00eda como resultado: [1] 3 ya que sus elementos son: [1] 2 1 5 Tambi\u00e9n se puede acceder a sus elementos mediante el operador [] , por ejemplo para conocer el segundo elemento de x se puede usar x[2] y el resultado es: [1] 1 Para acceder a m\u00e1s de un elemento, es posible apuntar a la posici\u00f3n del elemento, por ejemplo x[c(1,2)] o x[1:2] . En ambos, el resultado ser\u00eda: [1] 2 1 El operador : sirve para indicar una secuencia consecutiva. Por ejemplo i = 1:10 crear\u00eda un vector de 10 elementos del 1 al 10, esto es \u00fatil para crear sucesiones o \u00edndices. Para crear secuencias m\u00e1s complejas se puede usar la funci\u00f3n seq() . Por ejemplo con seq(from = 1,to = 10,by = 1) se crea una secuencia del 1 al 10 incrementando el valor en 1 y se obtiene el mismo resultado que con 1:10 . Otra forma de crear un vector es mediante la funci\u00f3n rep() . Por ejemplo la siguiente expresion: 1 u = rep ( x = x , each = 2 , times = 3 ) Crea un el vector u que contiene cada elemento del vector x 2 veces y esta secuencia se recrea 3 veces. [1] 2 2 1 1 5 5 2 2 1 1 5 5 2 2 1 1 5 5 Nombres de vector \u00b6 Una propiedad de los vectores es que sus elementos pueden tener un nombre. Se puede usar la funci\u00f3n names() para consultar o asignar nombres a un vector. El siguiente c\u00f3digo asignar\u00e1 nombres a los elementos del vector a1 . 1 2 nombres <- c ( \"uno\" , \"dos\" , \"tres\" ) names ( a1 ) <- nombres Los nombres tambi\u00e9n pueden ser usados para acceder a los elementos de un vector, por ejemplo para acceder al segundo elemento, se puede usar su nombre correspondiente, es decir a1[\"dos\"] . Escalares \u00b6 Un escalar es un vector con un solo elemento. Se pueden crear escalares con el s\u00edmbolo de asignaci\u00f3n <- o = . 1 2 3 n <- 5 m = n + 1 a = \"Hola mundo!\" Los escalares son \u00fatiles para guardar alg\u00fan valor. Pueden ser considerados como una variable. Tambi\u00e9n puede haber escalares l\u00f3gicos o booleanos, por ejemplo si se construye nm = n>m su valor ser\u00eda: [1] FALSE Matrices \u00b6 Una matriz es una arreglo de dos dimensiones (renglones y columnas) que contiene valores, especialmente num\u00e9ricos. Tiene n renglones y p columnas, es decir tiene np elementos. Para crea una matriz, se usa la funci\u00f3n matrix() cuya sintaxis es la siguiente: matrix( data = objeto, nrow = valor, ncol = valor <, byrow = FALSE> ) donde data representa un vector o una expresi\u00f3n, nrow el n\u00famero de renglones que se desean, ncol el n\u00famero de columnas y el argumento opcional byrow indica si se deber\u00edan llenar por columnas. Si se ejecuta el siguiente comando: 1 A1 = matrix ( data = u ) el resultado ser\u00eda una matriz de 18 renglones y una columna. Si se desea una matriz de otra dimensi\u00f3n se puede usar este c\u00f3digo. 1 A1 = matrix ( data = u , nrow = 6 , byrow = TRUE ) Tambi\u00e9n pueden crearse matrices a partir de vectores, mediante las funciones cbind() y rbind() . La primera permite concatenar columas y la segunda concatena renglones, por ejemplo 1 2 3 4 a1 = c ( 1 , 2 , 3 ) a2 = c ( 4 , 5 , 6 ) a3 = c ( 7 , 8 ) A = rbind ( cbind ( a1 , a2 ), a3 ) El resultado es el siguiente: Dimensiones \u00b6 Para conocer el tama\u00f1o o dimensiones de una matriz se puede usar la funci\u00f3n dim() 1 dim ( A ) Note que se desplegar\u00e1 en la consola el resultado mostrando la dimensi\u00f3n. 2 4 Para conocer el n\u00famero de renglones y columnas por separado se pueden usar las funciones nrow() y ncol() . 1 2 nrow ( A ) ncol ( A ) Esto es importante ya que como se ver\u00e1 m\u00e1s adelante, nos permitir\u00e1 hacer operaciones entre matrices. Elementos de una matriz \u00b6 Para acceder a los elementos de una matriz, podemos referirnos por medio de su posici\u00f3n [row,column] , por ejemplo para acceder al elemento ubicado en el rengl\u00f3n 1 de la columna 1 se usa: 1 A [ 1 , 1 ] Tambi\u00e9n se puede usar el n\u00famero de elemento, empezando de izquierda a derecha por columna, en este caso A[1] . Para obtener todo el rengl\u00f3n o toda la columna, \u00fanicamente se escribe el elemento que se quiere obtener, pero se debe dejar la coma, por ejemplo 1 2 A [ 1 ,] A [, 2 ] Traer\u00edan el primer rengl\u00f3n y la segunda columna respectivamente. Al igual que en el caso de los vectores para trae un rango espec\u00edfico se puede usar el operador : o un vector indicando los elemento deseados. 1 2 A [ 1 : 2 , 2 ] A [ c ( 1 , 3 ), 1 ] Nombres de una matriz \u00b6 De la misma forma que los vectores, las matrices pueden tener nombres en sus elementos. Adem\u00e1s se puede consultar y asignar un nombre a sus columnas y renglones usando las funciones colnames() y rownames() . De la misma forma, se pueden usar estos nombre para acceder a sus elementos. Operaciones \u00b6 Al igual que los vectores, se pueden hacer operaciones entre matrices. El siguiente cuadro resume las operaciones disponibles Nombre Operador Ejemplo Nota Suma + A + B Las matrices deben tener la misma dimensi\u00f3n Resta - A - B Las matrices deben tener la misma dimensi\u00f3n Multiplicaci\u00f3n (Elemento a elemento) * A * B Las matrices deben tener la misma dimensi\u00f3n Divisi\u00f3n (Elemento a elemento) / A / B Las matrices deben tener la misma dimensi\u00f3n Potencia ^ A ^ B Las matrices deben tener la misma dimensi\u00f3n Adicional a esto, se puede hacer la multiplicaci\u00f3n de matrices usando el operador %*% . Para poder realizar esta operaci\u00f3n, las matrices deben ser comformables , es decir, el n\u00famero de columnas de A, debe ser iguales al n\u00famero de renglones de B y el resultado ser\u00e1 una matriz de dimensiones iguales al n\u00famero de renglones de A y el mismo n\u00famero de columnas de B. Data Frames \u00b6 Los data fames son objetos usados para almacenar datos. Para conocer todas sus propiedades, vea la ayuda de R usando el comando help(\"data.frame\") . Una manera f\u00e1cil de crear conjunto de datos es mediante la funci\u00f3n data.frame() , pas\u00e1ndole vectores como argumentos. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo construir un conjunto de datos. 1 2 3 4 datos = data.frame ( nombre = c ( \"ANGELICA\" , \"BRENDA\" , \"LILIANA\" , \"MARCO\" , \"FABIAN\" , \"MAURICIO\" ), grupo = c ( \"A\" , \"A\" , \"B\" , \"B\" , \"C\" , \"C\" ), puntaje = c ( 10 , 9 , 8 , 8 , 9 , 7 )) El resultado es el siguiente. Un dataset comparte propiedades similares a las listas y vectores. Para acceder a sus valores, se puede usar los corchetes [rengl\u00f3n,columna] para seleccionar ya sea renglones, columnas o ambas. 1 2 3 datos [ 3 ,] datos [, 2 ] datos [ 1 : 3 , 1 ] Tambi\u00e9n es posible acceder a las variables mediante $ , seguido del nombre de la variable. Note que el resultado es un vector. 1 2 datos $ nombre datos $ nombre [ 1 : 3 ] Se pueden agregar nuevas variables usando el operador $ seguido del nuevo nombre, por ejemplo 1 datos $ sexo <- c ( \"F\" , \"F\" , \"F\" , \"M\" , \"M\" , \"M\" ) Es posible pasar de una matriz a un datafreme mediante la funci\u00f3n as.data.frame() , pas\u00e1ndole como argumento una matriz. 1 2 A = matrix ( 1 : 9 , 3 , 3 ) Adato = as.data.frame ( A ) Otros elementos \u00b6 Imagen de Innova Labs en Pixabay Debido a que R es un lenguaje muy amplio, posee diversas utilidades que permiten ampliar su uso. En esta secci\u00f3n se presentan otros elementos importantes del lenguaje R. Ayuda \u00b6 R dispone de un comando especial ? para obtener ayuda desde la consola. Por ejemplo para buscar ayuda sobre matrices, se puede escribir desde la consola el comando 1 ? matrix o bien con 1 help ( topic = \"matrix\" ) y con eso se abrir\u00e1 un documento de ayuda. Para realizar una b\u00fasqueda m\u00e1s general simplemente se deben escribir doble signo de interrogaci\u00f3n. 1 ?? matrix El sistema de ayuda nos mostrar\u00e1 los t\u00e9rminos relacionados en todos los paquetes que encuentre. Tambi\u00e9n se puede obtener ayuda acerca de una paquete en espec\u00edfico, por ejemplo 1 help ( package = \"ggplot2\" ) y con ello se obtendr\u00e1 la documentaci\u00f3n del paquete en espec\u00edfico. Funciones \u00b6 En R es posible definir funciones por el usuario. Estas funciones quedan almacenadas en el espacio de trabajo y est\u00e1r\u00e1n disponibles durante toda la sesi\u00f3n una vez definidas. La forma de definir una funci\u00f3n es la siguiente function( arglist ) expr donde arglist es una lista de argumentos de nombres o argumentos, puede ser vac\u00edo y expr es una expresi\u00f3n. El siguiente ejemplo muestra c\u00f3mo definir una funci\u00f3n simple. Al ingresar un n\u00famero, la funci\u00f3n nos devolver\u00e1 un mensaje con su signo. 1 2 3 4 5 mi_fun = function ( x ) ifelse ( x < 0 , \"Negativo\" , ifelse ( x > 0 , \"Positivo\" , \"Cero\" )) # uso de la funci\u00f3n mi_fun ( 0 ) mi_fun ( 2 ) mi_fun ( -3 ) El resultado es el siguiente. Para m\u00e1s ayuda vea la documentaci\u00f3n con el comando help(\"function\") . Paquetes \u00b6 R dispone de miles de paquetes que pueden descargarse libremente para enriquecerse son nuevas caracter\u00edsticas. Estos paquetes est\u00e1n almacenados en el CRAN y pueden instalarse f\u00e1cilmente desde la consola con el siguiente comando 1 install.packages () Por ejemplo, si se desea instalar el paquete ggplot2 se puede usar el siguiente comando. 1 install.packages ( \"ggplot2\" ) R almacenar\u00e1 los archivos en la carpeta personal llamada biblioteca del usuario o User library . Frecuentemente al instalar un paquete R descarga otros paquetes relacionados llamados dependencias que sirven para que las funciones del paquete trabajen adecuadamente. Sin embargo, a\u00fan no podr\u00e1 usarse debido a que es necesario cargarla mediante el comando library() , por ejemplo, para cargar el paquete ggplot2 se debe ejecutar 1 library ( ggplot2 ) Con esto, todas las funciones y objetos del paquete estar\u00e1n definidos y listos para usarse.","title":"Introducci\u00f3n a R"},{"location":"r/intro_r/#introduccion-a-r","text":"Este es un tutorial b\u00e1sico sobre el programa. Visite la p\u00e1gina de R para m\u00e1s informaci\u00f3n. R es un lenguaje de programaci\u00f3n para c\u00f3mputo estad\u00edstico. Tiene una gran cantidad de funciones que permiten ejecutar an\u00e1lisis estad\u00edsticos tradicionales, tales como regresi\u00f3n y modelos lineales, pruebas estad\u00edsticas, clasificaci\u00f3n, an\u00e1lisis de series de tiempo, entre otros. Una ventaja de R es que es altamente extensible a traves de paquetes que cualquier persona puede crear y aportar. R es un software libre y es ampliamente usado en el \u00e1mbito acad\u00e9mico e incluso en algunas empresas.","title":"Introducci\u00f3n a R"},{"location":"r/intro_r/#objetos-de-r","text":"R es un lenguaje de programaci\u00f3n que usa objetos. Estos objetos tienen identidad, atributos y propiedades. Tambien puede considerarse como un int\u00e9rprete, es decir que espera acciones del usuario. Cuando el usuario ejecuta comandos, R los ejecuta l\u00ednea por l\u00ednea. Los comandos o expresiones m\u00e1s comunes son las asignaciones, es decir se asigna un valor a una variables. Cada comando suele escribirse en una sola l\u00ednea o terminar con punto y coma. R es un lenguaje sensible a may\u00fasculas y min\u00fasculas, esto es un factor a tomar en cuenta para evitar errores. Interaz gr\u00e1fica R tiene una interfaz gr\u00e1fica para crear c\u00f3digo de forma m\u00e1s amigable. Visite R Studio para m\u00e1s informaci\u00f3n. Cuando se inicia una sesi\u00f3n, se asigna un espacio de trabajo (workspace) en memoria y un directorio de trabajo (working directory). El espacio de trabajo sirve para almacenar objetos creados, tales como vectores, funciones entre otros. Para conocer el directorio de trabajo puede escribir en consola: 1 getwd () Para cambiar use la funci\u00f3n setwd(\"dir\") , donde dir es el nuevo directorio. Barras verticales R no reconoce una sola barra / en los directorios de windows. Use doble barra // o una barra invertida \\ .","title":"Objetos de R"},{"location":"r/intro_r/#vectores","text":"Un vector es un objeto con uno o m\u00e1s elementos. Puede contener elementos num\u00e9ricos o caracteres. Se pueden crear vectores con la funci\u00f3n c() , por ejemplo: 1 2 x = c ( 2 , 1 , 5 ) z = c ( \"ABC\" , \"AEI\" , \"XYZ\" ) Los vectores permiten algunas operaciones, las m\u00e1s comunes son la suma + , resta - , multiplicaci\u00f3n * , divisi\u00f3n. / y potencia ^ , as\u00ed como valores booleanos. 1 2 y = m * x + n xy = x > y Operaci\u00f3n entre vectores Las operaciones entre vectores son elemento a elemento. Si los elementos no tuvieran el mismo tama\u00f1o, el de menor tama\u00f1o se recicla (repite sus elementos) hasta tener el mismo n\u00famero de elementos. Por ejemplo, la operaci\u00f3n nx = n + x dar\u00e1 como resultado: [1] 7 6 10 Los vectores tienen una dimensi\u00f3n y para conocerla se puede usar la funci\u00f3n length() . Por ejemplo length(x) nos dar\u00eda como resultado: [1] 3 ya que sus elementos son: [1] 2 1 5 Tambi\u00e9n se puede acceder a sus elementos mediante el operador [] , por ejemplo para conocer el segundo elemento de x se puede usar x[2] y el resultado es: [1] 1 Para acceder a m\u00e1s de un elemento, es posible apuntar a la posici\u00f3n del elemento, por ejemplo x[c(1,2)] o x[1:2] . En ambos, el resultado ser\u00eda: [1] 2 1 El operador : sirve para indicar una secuencia consecutiva. Por ejemplo i = 1:10 crear\u00eda un vector de 10 elementos del 1 al 10, esto es \u00fatil para crear sucesiones o \u00edndices. Para crear secuencias m\u00e1s complejas se puede usar la funci\u00f3n seq() . Por ejemplo con seq(from = 1,to = 10,by = 1) se crea una secuencia del 1 al 10 incrementando el valor en 1 y se obtiene el mismo resultado que con 1:10 . Otra forma de crear un vector es mediante la funci\u00f3n rep() . Por ejemplo la siguiente expresion: 1 u = rep ( x = x , each = 2 , times = 3 ) Crea un el vector u que contiene cada elemento del vector x 2 veces y esta secuencia se recrea 3 veces. [1] 2 2 1 1 5 5 2 2 1 1 5 5 2 2 1 1 5 5","title":"Vectores"},{"location":"r/intro_r/#nombres-de-vector","text":"Una propiedad de los vectores es que sus elementos pueden tener un nombre. Se puede usar la funci\u00f3n names() para consultar o asignar nombres a un vector. El siguiente c\u00f3digo asignar\u00e1 nombres a los elementos del vector a1 . 1 2 nombres <- c ( \"uno\" , \"dos\" , \"tres\" ) names ( a1 ) <- nombres Los nombres tambi\u00e9n pueden ser usados para acceder a los elementos de un vector, por ejemplo para acceder al segundo elemento, se puede usar su nombre correspondiente, es decir a1[\"dos\"] .","title":"Nombres de vector"},{"location":"r/intro_r/#escalares","text":"Un escalar es un vector con un solo elemento. Se pueden crear escalares con el s\u00edmbolo de asignaci\u00f3n <- o = . 1 2 3 n <- 5 m = n + 1 a = \"Hola mundo!\" Los escalares son \u00fatiles para guardar alg\u00fan valor. Pueden ser considerados como una variable. Tambi\u00e9n puede haber escalares l\u00f3gicos o booleanos, por ejemplo si se construye nm = n>m su valor ser\u00eda: [1] FALSE","title":"Escalares"},{"location":"r/intro_r/#matrices","text":"Una matriz es una arreglo de dos dimensiones (renglones y columnas) que contiene valores, especialmente num\u00e9ricos. Tiene n renglones y p columnas, es decir tiene np elementos. Para crea una matriz, se usa la funci\u00f3n matrix() cuya sintaxis es la siguiente: matrix( data = objeto, nrow = valor, ncol = valor <, byrow = FALSE> ) donde data representa un vector o una expresi\u00f3n, nrow el n\u00famero de renglones que se desean, ncol el n\u00famero de columnas y el argumento opcional byrow indica si se deber\u00edan llenar por columnas. Si se ejecuta el siguiente comando: 1 A1 = matrix ( data = u ) el resultado ser\u00eda una matriz de 18 renglones y una columna. Si se desea una matriz de otra dimensi\u00f3n se puede usar este c\u00f3digo. 1 A1 = matrix ( data = u , nrow = 6 , byrow = TRUE ) Tambi\u00e9n pueden crearse matrices a partir de vectores, mediante las funciones cbind() y rbind() . La primera permite concatenar columas y la segunda concatena renglones, por ejemplo 1 2 3 4 a1 = c ( 1 , 2 , 3 ) a2 = c ( 4 , 5 , 6 ) a3 = c ( 7 , 8 ) A = rbind ( cbind ( a1 , a2 ), a3 ) El resultado es el siguiente:","title":"Matrices"},{"location":"r/intro_r/#dimensiones","text":"Para conocer el tama\u00f1o o dimensiones de una matriz se puede usar la funci\u00f3n dim() 1 dim ( A ) Note que se desplegar\u00e1 en la consola el resultado mostrando la dimensi\u00f3n. 2 4 Para conocer el n\u00famero de renglones y columnas por separado se pueden usar las funciones nrow() y ncol() . 1 2 nrow ( A ) ncol ( A ) Esto es importante ya que como se ver\u00e1 m\u00e1s adelante, nos permitir\u00e1 hacer operaciones entre matrices.","title":"Dimensiones"},{"location":"r/intro_r/#elementos-de-una-matriz","text":"Para acceder a los elementos de una matriz, podemos referirnos por medio de su posici\u00f3n [row,column] , por ejemplo para acceder al elemento ubicado en el rengl\u00f3n 1 de la columna 1 se usa: 1 A [ 1 , 1 ] Tambi\u00e9n se puede usar el n\u00famero de elemento, empezando de izquierda a derecha por columna, en este caso A[1] . Para obtener todo el rengl\u00f3n o toda la columna, \u00fanicamente se escribe el elemento que se quiere obtener, pero se debe dejar la coma, por ejemplo 1 2 A [ 1 ,] A [, 2 ] Traer\u00edan el primer rengl\u00f3n y la segunda columna respectivamente. Al igual que en el caso de los vectores para trae un rango espec\u00edfico se puede usar el operador : o un vector indicando los elemento deseados. 1 2 A [ 1 : 2 , 2 ] A [ c ( 1 , 3 ), 1 ]","title":"Elementos de una matriz"},{"location":"r/intro_r/#nombres-de-una-matriz","text":"De la misma forma que los vectores, las matrices pueden tener nombres en sus elementos. Adem\u00e1s se puede consultar y asignar un nombre a sus columnas y renglones usando las funciones colnames() y rownames() . De la misma forma, se pueden usar estos nombre para acceder a sus elementos.","title":"Nombres de una matriz"},{"location":"r/intro_r/#operaciones","text":"Al igual que los vectores, se pueden hacer operaciones entre matrices. El siguiente cuadro resume las operaciones disponibles Nombre Operador Ejemplo Nota Suma + A + B Las matrices deben tener la misma dimensi\u00f3n Resta - A - B Las matrices deben tener la misma dimensi\u00f3n Multiplicaci\u00f3n (Elemento a elemento) * A * B Las matrices deben tener la misma dimensi\u00f3n Divisi\u00f3n (Elemento a elemento) / A / B Las matrices deben tener la misma dimensi\u00f3n Potencia ^ A ^ B Las matrices deben tener la misma dimensi\u00f3n Adicional a esto, se puede hacer la multiplicaci\u00f3n de matrices usando el operador %*% . Para poder realizar esta operaci\u00f3n, las matrices deben ser comformables , es decir, el n\u00famero de columnas de A, debe ser iguales al n\u00famero de renglones de B y el resultado ser\u00e1 una matriz de dimensiones iguales al n\u00famero de renglones de A y el mismo n\u00famero de columnas de B.","title":"Operaciones"},{"location":"r/intro_r/#data-frames","text":"Los data fames son objetos usados para almacenar datos. Para conocer todas sus propiedades, vea la ayuda de R usando el comando help(\"data.frame\") . Una manera f\u00e1cil de crear conjunto de datos es mediante la funci\u00f3n data.frame() , pas\u00e1ndole vectores como argumentos. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo construir un conjunto de datos. 1 2 3 4 datos = data.frame ( nombre = c ( \"ANGELICA\" , \"BRENDA\" , \"LILIANA\" , \"MARCO\" , \"FABIAN\" , \"MAURICIO\" ), grupo = c ( \"A\" , \"A\" , \"B\" , \"B\" , \"C\" , \"C\" ), puntaje = c ( 10 , 9 , 8 , 8 , 9 , 7 )) El resultado es el siguiente. Un dataset comparte propiedades similares a las listas y vectores. Para acceder a sus valores, se puede usar los corchetes [rengl\u00f3n,columna] para seleccionar ya sea renglones, columnas o ambas. 1 2 3 datos [ 3 ,] datos [, 2 ] datos [ 1 : 3 , 1 ] Tambi\u00e9n es posible acceder a las variables mediante $ , seguido del nombre de la variable. Note que el resultado es un vector. 1 2 datos $ nombre datos $ nombre [ 1 : 3 ] Se pueden agregar nuevas variables usando el operador $ seguido del nuevo nombre, por ejemplo 1 datos $ sexo <- c ( \"F\" , \"F\" , \"F\" , \"M\" , \"M\" , \"M\" ) Es posible pasar de una matriz a un datafreme mediante la funci\u00f3n as.data.frame() , pas\u00e1ndole como argumento una matriz. 1 2 A = matrix ( 1 : 9 , 3 , 3 ) Adato = as.data.frame ( A )","title":"Data Frames"},{"location":"r/intro_r/#otros-elementos","text":"Imagen de Innova Labs en Pixabay Debido a que R es un lenguaje muy amplio, posee diversas utilidades que permiten ampliar su uso. En esta secci\u00f3n se presentan otros elementos importantes del lenguaje R.","title":"Otros elementos"},{"location":"r/intro_r/#ayuda","text":"R dispone de un comando especial ? para obtener ayuda desde la consola. Por ejemplo para buscar ayuda sobre matrices, se puede escribir desde la consola el comando 1 ? matrix o bien con 1 help ( topic = \"matrix\" ) y con eso se abrir\u00e1 un documento de ayuda. Para realizar una b\u00fasqueda m\u00e1s general simplemente se deben escribir doble signo de interrogaci\u00f3n. 1 ?? matrix El sistema de ayuda nos mostrar\u00e1 los t\u00e9rminos relacionados en todos los paquetes que encuentre. Tambi\u00e9n se puede obtener ayuda acerca de una paquete en espec\u00edfico, por ejemplo 1 help ( package = \"ggplot2\" ) y con ello se obtendr\u00e1 la documentaci\u00f3n del paquete en espec\u00edfico.","title":"Ayuda"},{"location":"r/intro_r/#funciones","text":"En R es posible definir funciones por el usuario. Estas funciones quedan almacenadas en el espacio de trabajo y est\u00e1r\u00e1n disponibles durante toda la sesi\u00f3n una vez definidas. La forma de definir una funci\u00f3n es la siguiente function( arglist ) expr donde arglist es una lista de argumentos de nombres o argumentos, puede ser vac\u00edo y expr es una expresi\u00f3n. El siguiente ejemplo muestra c\u00f3mo definir una funci\u00f3n simple. Al ingresar un n\u00famero, la funci\u00f3n nos devolver\u00e1 un mensaje con su signo. 1 2 3 4 5 mi_fun = function ( x ) ifelse ( x < 0 , \"Negativo\" , ifelse ( x > 0 , \"Positivo\" , \"Cero\" )) # uso de la funci\u00f3n mi_fun ( 0 ) mi_fun ( 2 ) mi_fun ( -3 ) El resultado es el siguiente. Para m\u00e1s ayuda vea la documentaci\u00f3n con el comando help(\"function\") .","title":"Funciones"},{"location":"r/intro_r/#paquetes","text":"R dispone de miles de paquetes que pueden descargarse libremente para enriquecerse son nuevas caracter\u00edsticas. Estos paquetes est\u00e1n almacenados en el CRAN y pueden instalarse f\u00e1cilmente desde la consola con el siguiente comando 1 install.packages () Por ejemplo, si se desea instalar el paquete ggplot2 se puede usar el siguiente comando. 1 install.packages ( \"ggplot2\" ) R almacenar\u00e1 los archivos en la carpeta personal llamada biblioteca del usuario o User library . Frecuentemente al instalar un paquete R descarga otros paquetes relacionados llamados dependencias que sirven para que las funciones del paquete trabajen adecuadamente. Sin embargo, a\u00fan no podr\u00e1 usarse debido a que es necesario cargarla mediante el comando library() , por ejemplo, para cargar el paquete ggplot2 se debe ejecutar 1 library ( ggplot2 ) Con esto, todas las funciones y objetos del paquete estar\u00e1n definidos y listos para usarse.","title":"Paquetes"},{"location":"sas/basico_sas/","text":"Lectura de datos \u00b6 Los dataset son el insumo principal para analisis de datos en SAS, por ello iniciaremos con una r\u00e1pida exploraci\u00f3n. En esta secci\u00f3n se presentan temas para comenzar con la lectura y escritura de datos. Se explorar\u00e1n distintas formas de leer y escribir datos de distintas fuentes y formatos de archivo. La creaci\u00f3n de un dataset inicia con un bloque DATA y termina con un RUN . Sin embargo, aprenderemos el uso b\u00e1sico de un procedimiento para leer datos de fuentes externas. Creando datasets \u00b6 En esta secci\u00f3n se mostrar\u00e1n las principales formas de crear datasets: Introducci\u00f3n de forma manual Leyendo un archivo de texto externo El uso de PROC IMPORT Se mostrar\u00e1n las ideas y algunos ejemplos. Introducci\u00f3n de valores de forma manual \u00b6 La forma m\u00e1s f\u00e1cil de crear un dataset, es con el uso de la sentencia INPUT y DATALINES con el fin de introducir valores manualmente. Estos datos fueron copiados y pegados directamente de una hoja de excel. El siguiente ejemplo muestra como introducir datos manualmente. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 DATA EMPLEADOS( LABEL = \"Registro de empleados nuevos\" ); ATTRIB NOMBRE LENGTH = $ 16 LABEL = \"Nombre\" APELLIDO LENGTH = $ 12 LABEL = \"Apellido\" ID LABEL = \"ID empleado\" GENERO LENGTH = $ 1 . LABEL = \"G\u00e9nero\" FNAC INFORMAT = DDMMYY10. FORMAT = DATE10. LABEL = \"Fecha de nacimiento\" ; INPUT NOMBRE -- FNAC; DATALINES; Ezio Vanegas 1 m 04/06/1942 Katharina Res\u00e9ndez 2 f 12/08/1967 Tamara Monroy 3 f 02/01/1948 Dunstano Armend\u00e1riz 4 m 05/07/1985 Baldo Ayala 5 m 04/10/1952 Adri\u00e1n Rosales 6 m 8/28/1992 Helvia Viera 7 f 12/16/1994 Astor Cortez 8 m 12/04/1965 Giusto Carvajal 9 m 5/27/1986 Baal Alcal\u00e1 10 m 1/15/1961 ; RUN; La sentencia DATA especifica el nombre del dataset y entre parentesis est\u00e1n las opciones del dataset, en este caso el dataset empleados tendr\u00e1 una etiqueta para identificarlo. Es recomendable especificar las propiedades de las variables a crear mediante la sentencia ATTRIB en donde se especifican sus propiedades. Declaraci\u00f3n de variables Otra forma de declarar variables es mediante las sentencias LENGTH y FORMAT . Consulte la documentaci\u00f3n para m\u00e1s informaci\u00f3n. N\u00f3tese que para el caso de las variables de tipo caracter se hace uso de la opci\u00f3n LENGTH = seguido del signo de pesos para indicar que es de tipo caracter y la longitud deseada. Para el caso de variables num\u00e9ricas, se debe especificar al menos un atributo, en este caso se recomienda especificar el atributo LABEL = . En el caso de la variable fnac los datos estan almacenados en formato de fecha (ddmmyyyy) por lo que se usa el informato ddmmyy10. para que lo reconozca como fehca de sas, pero se desea visualizar con el formato de fecha (ddmmmyyyy). La sentencia INPUT sirve para indicar el nombre de las variables del dataset. Se puede poner el s\u00edmbolo $ para indicar que la variable es de tipo caracter. Sin embargo en este caso, como ya se han declarado las variables se puede usar una lista, es decir, solo poner el nombre de la primer variable declarada seguido de dos guiones -- y el nombre de la \u00faltima. La sentencia DATALINES indica el inicio de los datos y finaliza con un punto y coma. Con la sentencia RUN se cierra el bloque de instrucciones y comienza a ejecutar el proceso. Si los datos estuvieran acomodados secuencialmente, es posible leerlos usando @@ al final de la sentencia input , este doble signo arroba es \u00fatil cuando un registro tiene m\u00e1s de una observaci\u00f3n, por ejemplo si los datos estuvieran acomodados en esta forma 1 2 3 4 INPUT NOMBRE -- FNAC @@; DATALINES; Ezio Vanegas 1 m 04 / 06 / 1942 Katharina Res\u00e9ndez 2 f 12 / 08 / 1967 Tamara Monroy 3 f 02 / 01 / 1948 Dunstano Armend\u00e1riz 4 m 05 / 07 / 1985 Baldo Ayala 5 m 04 / 10 / 1952 Adri\u00e1n Rosales 6 m 8 / 28 / 1992 Helvia Viera 7 f 12 / 16 / 1994 Astor Cortez 8 m 12 / 04 / 1965 Giusto Carvajal 9 m 5 / 27 / 1986 Baal Alcal\u00e1 10 m 1 / 15 / 1961 la informaci\u00f3n podr\u00eda ser le\u00edda sin ning\u00fan problema. Lectura de datos desde un archivo externo \u00b6 SAS puede leer datos de archivos de texto almacenados en distintos formatos, por ejemplo de ancho fijo o delimitados. Para acceder a ellos es necesario usar la referencia para apuntar a ellos, algo similar a la declaraci\u00f3n de las librer\u00edas. Se puede hacer mediante la sentencia FILENAME : FILENAME fileref \u2018 nombre-archivo \u2019; donde fileref es un nombre sas que har\u00e1 referencia a un archivo y nombre-archivo es el nombre de un archivo f\u00edsico externo que incluye tanto la ruta como el nombre con su extensi\u00f3n. Por ejemplo la siguiente sentencia asigna con el nombre archivo al archivo \u201cdatos\u201d almacenados en formato .dat que est\u00e1n en la carpeta proyectos. 1 FILENAME archivo \"C:\\Users\\Usuario\\Documents\\Proyectos\\datos.dat\" ; Tambi\u00e9n ser\u00e1 necesario usar la sentencia INFILE . Esta sentencia le da las espeficicaciones a SAS sobre c\u00f3mo leer archivos externos. Para una mayor referencia consulte la sentencia INPUT . Lectura de un archivo de ancho fijo \u00b6 En ocasiones se tienen los datos almacenados en formato de texto pero los datos estan alineados de tal forma que es posible saber en que posici\u00f3n inicia cada variable. El ejemplo anterior muestra un ejemplo de un archivo de texto de ancho fijo, obs\u00e9rvese que el id comienza en la columna 1 mientras que el nombre inicia en la columna 8. El siguiente c\u00f3digo muestra c\u00f3mo leer datos de un archivo de ancho fijo. 1 2 3 4 DATA VENTAS; INFILE ARCHIVO; INPUT ID 1 - 7 NOMBRE $ 8 - 18 APELLIDO $ 19-33 POSICION $ 34 - 53 VOLUMEN 54 - 60 PAIS $ 61-62 ; RUN; La diferencia con ejemplos anteriores es la sentencia INFILE . Esta sentencia especifica que se va leer un archivo externo y se usa junto con la sentencia INPUT . En la sentencia INPUT se declaran las variables que va a contener el dataset VENTAS . SAS leer\u00e1 el archivo l\u00ednea por l\u00ednea y almacenar\u00e1 los valores que encuentre en la variable declarada seg\u00fan la posici\u00f3n indicada, por ejemplo los valores que encuentre de la l\u00ednea 1 a la 7 se guardar\u00e1n en la variable ID , mientras que los valores de la columna 8 a la 18 se almacenar\u00e1n en la variable NOMBRE , n\u00f3tese que despu\u00e9s de NOMBRE hay un signo de pesos, esto es para indicar que la variable es de tipo caracter. Cuidado con las posiciones de columna Se debe ser muy cuidadoso al especificar la posici\u00f3n de las columnas para no mezclar los valores. En el ejemplo anterior, si se hubiera declarado VOLUMEN 54 - 61 , SAS hubiera considerado la columna 61 y nos mostrar\u00eda un mensaje en el log: Debido a que la columna 61 contiene a la letra A, SAS estar\u00eda almacenando una cadena en una variable num\u00e9rica, por lo que lo que nos mostrar\u00eda el error y finalmente le asignar\u00eda un valor missing a volumen . Una forma alternativa de declarar las variables en la sentencia ser\u00eda usar el siguiente c\u00f3digo: 1 2 3 4 DATA VENTAS; INFILE ARCHIVO; INPUT ID NOMBRE $ 10 . APELLIDO $ 19-33 POSICION $ 34 - 53 VOLUMEN PAIS $ 3 . ; RUN; Note que en la sentencia INPUT se declaran a las variables de tipo caracter de dos formas: por posici\u00f3n (ejemplo APELLIDO $ 19-33 ) y por formato (ejemplo NOMBRE $10. ). Para una mayor referencia consulte leyendo datos en bruto en la documentaci\u00f3n de SAS. Lectura de un archivo de texto delimitado \u00b6 El delimitador predeterminado es un espacio en blanco. Sin embargo, los archivos de texto delimitados por otros caracteres (por ejemplo una coma, tabulador, o s\u00edmbolos especiales) tambien pueden ser le\u00eddos por SAS. Para especificar el tipo de delimitador, se utiliza la opci\u00f3n DLM = en la sentencia INFILE . Considere el siguiente archivo de texto. Puede notarse que est\u00e1 delimitado por el caracter \u201c/\u201d y adem\u00e1s tiene datos perdidos (resaltados en amarillo). De hecho, los valores perdidos al final de la l\u00ednea podr\u00edan hacer que SAS terminara antes de leer los datos. El siguiente c\u00f3digo puede ser usado para leer esos datos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 DATA gerentes; INFILE ARCHIVO DLM = \"/\" DSD TRUNCOVER; ATTRIB id label = \"ID gerente\" nombre LENGTH = $ 12 LABEL = \"Nombre\" apellido LENGTH = $ 18 LABEL = \"Apellido\" genero LENGTH = $ 2 LABEL = \"G\u00e9nero\" ventas LABEL = \"Ventas totales\" posicion LENGTH = $ 18 LABEL = \"Posici\u00f3n\" pais LENGTH = $ 2 LABEL = \"Pa\u00eds\" fnac INFORMAT = date12. FORMAT = ddmmyy10. LABEL = \"Fecha de nacimiento\" fingreso INFORMAT = anydtdte12. FORMAT = ddmmyy10. LABEL = \"Fecha de ingreso\" ; INPUT id -- fingreso ; RUN; La opci\u00f3n DSD es \u00fatil cuando hay un valor faltante en datos delimitados, de otra forma SAS no reconocer\u00eda dos delimitadores juntos y no leer\u00eda los datos correctamente. La opci\u00f3n MISSOVER evita que SAS salte a una nueva linea cuando no encuentra valores v\u00e1lidos y asigna valores faltantes a las variables que no encuentre. TRUNCOVER funciona de manera similar a MISSOVER pero la diferencia radica en que asignar\u00eda los valores que encuentre pasando el fin de l\u00ednea. Leyendo archivos desde web \u00b6 Para leer datos desde internet (usualmente en formato csv) se debe especificar el nombre del archivo con la sentencia FILENAME con la opci\u00f3n URL . FILENAME fileref URL \u2018 nombre-archivo \u2018 < opciones-url > ; Un ejemplo para descargar datos de covid se encuentran en el siguiente programa de sas: datos_covid_web.sas . Consulte la documentaci\u00f3n de la sentencia FILENAME con el m\u00e9todo de acceso URL para m\u00e1s informaci\u00f3n. Selecci\u00f3n de observaciones \u00b6 Es posible seleccionar las observaciones que se quieren escribir en un dataset, sobre todo aquellas que cumplan ciertas condiciones . Al igual que otros lenguajes de programaci\u00f3n SAS tiene expresiones l\u00f3gicas que eval\u00faan cierta condici\u00f3n. La sintaxis es la siguiente: IF expresi\u00f3n ; Esta sentencia nos permite continuar procesando aquellas observaciones que cumplen la condici\u00f3n, generalmente de comparaci\u00f3n. Una expresi\u00f3n puede ser el nombre de una varible y puede contener alg\u00fan operador l\u00f3gico y un operando. Pueden conectarse mediante conectores l\u00f3gicos, comunmente llamados booleanos. La siguiente tabla resume algunos operadores l\u00f3gicos y conectores. S\u00edmbolo Descripci\u00f3n Ejemplo = o EQ IGUAL A sex EQ \"F\" ^= o \u00ac= o ~= o NE NO IGUAL A sex NE \"F\" > o GT MAYOR QUE age GT 13 < o LT MENOR QUE age LT 13 >= o GE MAYOR O IGUAL A age GE 14 <= o LE MENOR QUE O IGUAL A age LE 14 IN (EST\u00c1) EN age in (12 14 15) o sex in (\"F\" \"M\") & o AND Y sex EQ \"F\" AND age GT 13 ! o OR o O sex EQ \"F\" OR age GT 13 ~ o ^ o \u00ac o NOT NO NOT(sex EQ \"F\" OR age GT 13) Por ejemplo el siguiente c\u00f3digo solo contendr\u00eda a empleados de Australia. 1 2 3 4 5 DATA VENTAS_AU; INFILE ARCHIVO; IF PAIS EQ \"AU\" ; INPUT ID 1 - 7 NOMBRE $ 8 - 18 APELLIDO $ 19-33 POSICION $ 34 - 53 VOLUMEN 54 - 60 PAIS $ 61-62 ; RUN; Para elegir observaciones que no sean nulas, se puede usar la siguiente sentencia. 1 2 3 4 5 DATA VENTAS_AU; INFILE ARCHIVO; IF VOLUMEN; INPUT ID 1 - 7 NOMBRE $ 8 - 18 APELLIDO $ 19-33 POSICION $ 34 - 53 VOLUMEN 54 - 60 PAIS $ 61-62 ; RUN; Usando un procedimiento para leer datos externos \u00b6 La forma m\u00e1s f\u00e1cil de leer archivos externos es mediante el procedimiento IMPORT . PROC IMPORT DATAFILE = \u201cfilename\u201d OUT = dataset; Este procedimiento no solo lee archivos de texto, sino tambien de Excel, SPSS, Stata e incluso tablas de Access. Para una mayor referencia vea el procedimiento IMPORT . El siguiente c\u00f3digo leer\u00e1 un archivo en formato excel. 1 2 3 4 PROC IMPORT OUT = WORK . censo DATAFILE = \"C:\\Users\\Usuario\\census.xlsx\" DBMS = XLSX REPLACE ; RUN; N\u00f3tese que se ha especificado la opci\u00f3n DBMS = XLSX para que sas utilice los par\u00e1metros correspondientes para leer un archivo de excel. La opci\u00f3n REPLACE reemplazar\u00eda el dataset que tuviera el mismo nombre, de otro modo SAS mostrar\u00eda un error y no crear\u00eda el dataset. El siguiente c\u00f3digo muestra c\u00f3mo leer un archivo en formato csv. 1 2 3 4 5 6 PROC IMPORT OUT = WORK . census DATAFILE = \"C:\\Users\\Usuario\\census.csv\" DBMS = CSV REPLACE ; GETNAMES = YES; DATAROW = 2 ; RUN; En el caso de archivos csv, hay dos sentencias adicionales, la sentencia GETNAMES = YES indica si los nombres de las variables se encuentran al inicio del archivo de texto, mientras que la sentencia DATAROW = 2 indica que los valores incian en el rengl\u00f3n 2. Escritura a un archivo externo \u00b6 SAS tambien puede ser utlizado para escribir archivos externos. En esta secci\u00f3n se mostrar\u00e1 como crear archivos de texto, asi como escribir mensaje del log a archivos externos. Escritura de un archivo delimitado \u00b6 El siguiente c\u00f3digo muestra como crear un archivo de texto. 1 2 3 4 5 6 FILENAME archivo \"C:\\Users\\Usuario\\alumnos.dat\" ; DATA _NULL_ ; FILE archivo; SET sashelp . class; PUT name age sex; RUN; Como se puede ver, se ha referenciado con la sentencia FILENAME el archivo con el nombre que en el que se desea escribir. N\u00f3tese que en la sentencia DATA se ha especificado _NULL_ , una palabra reservada para pedir que no cree ning\u00fan dataset. La sentencia FILE da las especificaciones para escribir los archivos de texto. Es muy similar a la sentencia INFILE , para mayor referencia consulte la sentencia FILE . Finalmente, la sentencia PUT indica lo que se va a escribir en el archivo externo, en este caso se especifican la variables de inter\u00e9s. Para una mayor referencia consulte la sentencia PUT . Archivos delimitados por un caracter SAS crea archivos delimitados por un espacio en blanco. Para crear un archivo delimitado por otro caracter (por ejemplo una coma) se puede usar la opci\u00f3n DLM = . Tambien se puede modificar la extensi\u00f3n del archivo con la sentencia FILENAME . El resultado ser\u00eda el siguiente. Escritura de un archivo de texto de ancho fijo \u00b6 Para crear un archivo de texto de ancho fijo, se puede especificar las posiciones en las que se escribiran las observaciones. 1 2 3 4 5 6 FILENAME archivo \"C:\\Users\\Usuario\\alumnos.txt\" ; DATA _NULL_ ; FILE archivo; SET sashelp . class; PUT name $ 8 . sex 10-12 age 2 . height 16-20 weight 22-25 ; RUN; N\u00f3tese que se han especificado los formatos de las variables y las columnas en las que se desea escribir el archivo, es algo muy similar cuando se le\u00edan los archivos con la sentencia INPUT . Crear archivos con encabezados \u00b6 Debido a que sas escribe directamente al archivo, es un poco complicado especificarle que en el rengl\u00f3n 1 escriba el nombre de las variables. Sin embargo, el siguiente c\u00f3digo logra especificar el nombre de los archivos en la primer l\u00ednea. 1 2 3 4 5 6 7 FILENAME archivo \"C:\\Users\\Usuario\\alumnos.txt\" ; DATA _NULL_ ; FILE archivo; IF _n_ EQ 1 THEN PUT \"name \" \"sex \" \"age \" \"height \" \"weight \" ; SET sashelp . class; PUT name -- weight; RUN; Esto se logra escribiendo la sentencia PUT justo al inicio e inmediatamente despues se carga el dataset que se quiere escribir. Las sentencias de la l\u00ednea 4 se estudiar\u00e1n en la secci\u00f3n filtrado de datos Leer y modificar archivos de texto \u00b6 Es posible manipular archivos de texto mediante SAS. para ellos es necesario leerlos y volver a escribir sobre ellos. El siguiente c\u00f3digo muestra como actualizar ciertas variables. 1 2 3 4 5 6 7 8 9 10 11 12 FILENAME ARCHIVO \"C:\\Users\\Usuario\\alumnos.txt\" ; DATA _NULL_ ; INFILE archivo SHAREBUFFERS FIRSTOBS = 2 TRUNCOVER; ATTRIB sex LENGTH = $ 1 sex2 LENGTH = $ 1 ; INPUT sex $ 9 ; IF sex = \"F\" THEN sex2 = \"M\" ; IF sex = \"M\" THEN sex2 = \"H\" ; FILE archivo TRUNCOVER PAD; PUT sex2 9 ; RUN; Note que se la sentencia LIBNAME apunta al mismo archivo que se est\u00e1 usando en las sentencias INFILE y FILE . La opci\u00f3n SHAREBUFFERS es \u00fatil para actualizar un archivo externo y solo actualiza ciertos campos. Esta opci\u00f3n se usa junto con las sentencias INFILE , FILE y PUT . La variable sex2 se usa para guardar el valor que se va a escribir en el archivo cuando sex toma cierto valor. Cuidado con las longitudes Se debe tener cuidado cuando se actualiza un archivo de texto. Se debe procurar que la variable que se lee como la que se escribe tengan la misma longitud, de otro modo pueden haber resultados inesperados. El resultado se muestra a continuaci\u00f3n Escritura de datos con el procedimiento EXPORT \u00b6 As\u00ed como es posible leer datos de forma externa con un procedimiento, tambien hay uno para escribir datos a archivos externos. La sintaxis es muy similar. PROC EXPORT OUTFILE = \u201cfilename\u201d DATA = dataset; El siguiente c\u00f3digo muestra la forma de escribir un dataset a un archivo csv. 1 2 3 4 PROC EXPORT DATA= SASHELP . Class OUTFILE= \"C:\\Users\\Usuario\\alumnos.csv\" DBMS = CSV REPLACE ; RUN; Para mayores referencias consulte el procedimiento EXPORT .","title":"Lectura y escritura de datos"},{"location":"sas/basico_sas/#lectura-de-datos","text":"Los dataset son el insumo principal para analisis de datos en SAS, por ello iniciaremos con una r\u00e1pida exploraci\u00f3n. En esta secci\u00f3n se presentan temas para comenzar con la lectura y escritura de datos. Se explorar\u00e1n distintas formas de leer y escribir datos de distintas fuentes y formatos de archivo. La creaci\u00f3n de un dataset inicia con un bloque DATA y termina con un RUN . Sin embargo, aprenderemos el uso b\u00e1sico de un procedimiento para leer datos de fuentes externas.","title":"Lectura de datos"},{"location":"sas/basico_sas/#creando-datasets","text":"En esta secci\u00f3n se mostrar\u00e1n las principales formas de crear datasets: Introducci\u00f3n de forma manual Leyendo un archivo de texto externo El uso de PROC IMPORT Se mostrar\u00e1n las ideas y algunos ejemplos.","title":"Creando datasets"},{"location":"sas/basico_sas/#introduccion-de-valores-de-forma-manual","text":"La forma m\u00e1s f\u00e1cil de crear un dataset, es con el uso de la sentencia INPUT y DATALINES con el fin de introducir valores manualmente. Estos datos fueron copiados y pegados directamente de una hoja de excel. El siguiente ejemplo muestra como introducir datos manualmente. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 DATA EMPLEADOS( LABEL = \"Registro de empleados nuevos\" ); ATTRIB NOMBRE LENGTH = $ 16 LABEL = \"Nombre\" APELLIDO LENGTH = $ 12 LABEL = \"Apellido\" ID LABEL = \"ID empleado\" GENERO LENGTH = $ 1 . LABEL = \"G\u00e9nero\" FNAC INFORMAT = DDMMYY10. FORMAT = DATE10. LABEL = \"Fecha de nacimiento\" ; INPUT NOMBRE -- FNAC; DATALINES; Ezio Vanegas 1 m 04/06/1942 Katharina Res\u00e9ndez 2 f 12/08/1967 Tamara Monroy 3 f 02/01/1948 Dunstano Armend\u00e1riz 4 m 05/07/1985 Baldo Ayala 5 m 04/10/1952 Adri\u00e1n Rosales 6 m 8/28/1992 Helvia Viera 7 f 12/16/1994 Astor Cortez 8 m 12/04/1965 Giusto Carvajal 9 m 5/27/1986 Baal Alcal\u00e1 10 m 1/15/1961 ; RUN; La sentencia DATA especifica el nombre del dataset y entre parentesis est\u00e1n las opciones del dataset, en este caso el dataset empleados tendr\u00e1 una etiqueta para identificarlo. Es recomendable especificar las propiedades de las variables a crear mediante la sentencia ATTRIB en donde se especifican sus propiedades. Declaraci\u00f3n de variables Otra forma de declarar variables es mediante las sentencias LENGTH y FORMAT . Consulte la documentaci\u00f3n para m\u00e1s informaci\u00f3n. N\u00f3tese que para el caso de las variables de tipo caracter se hace uso de la opci\u00f3n LENGTH = seguido del signo de pesos para indicar que es de tipo caracter y la longitud deseada. Para el caso de variables num\u00e9ricas, se debe especificar al menos un atributo, en este caso se recomienda especificar el atributo LABEL = . En el caso de la variable fnac los datos estan almacenados en formato de fecha (ddmmyyyy) por lo que se usa el informato ddmmyy10. para que lo reconozca como fehca de sas, pero se desea visualizar con el formato de fecha (ddmmmyyyy). La sentencia INPUT sirve para indicar el nombre de las variables del dataset. Se puede poner el s\u00edmbolo $ para indicar que la variable es de tipo caracter. Sin embargo en este caso, como ya se han declarado las variables se puede usar una lista, es decir, solo poner el nombre de la primer variable declarada seguido de dos guiones -- y el nombre de la \u00faltima. La sentencia DATALINES indica el inicio de los datos y finaliza con un punto y coma. Con la sentencia RUN se cierra el bloque de instrucciones y comienza a ejecutar el proceso. Si los datos estuvieran acomodados secuencialmente, es posible leerlos usando @@ al final de la sentencia input , este doble signo arroba es \u00fatil cuando un registro tiene m\u00e1s de una observaci\u00f3n, por ejemplo si los datos estuvieran acomodados en esta forma 1 2 3 4 INPUT NOMBRE -- FNAC @@; DATALINES; Ezio Vanegas 1 m 04 / 06 / 1942 Katharina Res\u00e9ndez 2 f 12 / 08 / 1967 Tamara Monroy 3 f 02 / 01 / 1948 Dunstano Armend\u00e1riz 4 m 05 / 07 / 1985 Baldo Ayala 5 m 04 / 10 / 1952 Adri\u00e1n Rosales 6 m 8 / 28 / 1992 Helvia Viera 7 f 12 / 16 / 1994 Astor Cortez 8 m 12 / 04 / 1965 Giusto Carvajal 9 m 5 / 27 / 1986 Baal Alcal\u00e1 10 m 1 / 15 / 1961 la informaci\u00f3n podr\u00eda ser le\u00edda sin ning\u00fan problema.","title":"Introducci\u00f3n de valores de forma manual"},{"location":"sas/basico_sas/#lectura-de-datos-desde-un-archivo-externo","text":"SAS puede leer datos de archivos de texto almacenados en distintos formatos, por ejemplo de ancho fijo o delimitados. Para acceder a ellos es necesario usar la referencia para apuntar a ellos, algo similar a la declaraci\u00f3n de las librer\u00edas. Se puede hacer mediante la sentencia FILENAME : FILENAME fileref \u2018 nombre-archivo \u2019; donde fileref es un nombre sas que har\u00e1 referencia a un archivo y nombre-archivo es el nombre de un archivo f\u00edsico externo que incluye tanto la ruta como el nombre con su extensi\u00f3n. Por ejemplo la siguiente sentencia asigna con el nombre archivo al archivo \u201cdatos\u201d almacenados en formato .dat que est\u00e1n en la carpeta proyectos. 1 FILENAME archivo \"C:\\Users\\Usuario\\Documents\\Proyectos\\datos.dat\" ; Tambi\u00e9n ser\u00e1 necesario usar la sentencia INFILE . Esta sentencia le da las espeficicaciones a SAS sobre c\u00f3mo leer archivos externos. Para una mayor referencia consulte la sentencia INPUT .","title":"Lectura de datos desde un archivo externo"},{"location":"sas/basico_sas/#lectura-de-un-archivo-de-ancho-fijo","text":"En ocasiones se tienen los datos almacenados en formato de texto pero los datos estan alineados de tal forma que es posible saber en que posici\u00f3n inicia cada variable. El ejemplo anterior muestra un ejemplo de un archivo de texto de ancho fijo, obs\u00e9rvese que el id comienza en la columna 1 mientras que el nombre inicia en la columna 8. El siguiente c\u00f3digo muestra c\u00f3mo leer datos de un archivo de ancho fijo. 1 2 3 4 DATA VENTAS; INFILE ARCHIVO; INPUT ID 1 - 7 NOMBRE $ 8 - 18 APELLIDO $ 19-33 POSICION $ 34 - 53 VOLUMEN 54 - 60 PAIS $ 61-62 ; RUN; La diferencia con ejemplos anteriores es la sentencia INFILE . Esta sentencia especifica que se va leer un archivo externo y se usa junto con la sentencia INPUT . En la sentencia INPUT se declaran las variables que va a contener el dataset VENTAS . SAS leer\u00e1 el archivo l\u00ednea por l\u00ednea y almacenar\u00e1 los valores que encuentre en la variable declarada seg\u00fan la posici\u00f3n indicada, por ejemplo los valores que encuentre de la l\u00ednea 1 a la 7 se guardar\u00e1n en la variable ID , mientras que los valores de la columna 8 a la 18 se almacenar\u00e1n en la variable NOMBRE , n\u00f3tese que despu\u00e9s de NOMBRE hay un signo de pesos, esto es para indicar que la variable es de tipo caracter. Cuidado con las posiciones de columna Se debe ser muy cuidadoso al especificar la posici\u00f3n de las columnas para no mezclar los valores. En el ejemplo anterior, si se hubiera declarado VOLUMEN 54 - 61 , SAS hubiera considerado la columna 61 y nos mostrar\u00eda un mensaje en el log: Debido a que la columna 61 contiene a la letra A, SAS estar\u00eda almacenando una cadena en una variable num\u00e9rica, por lo que lo que nos mostrar\u00eda el error y finalmente le asignar\u00eda un valor missing a volumen . Una forma alternativa de declarar las variables en la sentencia ser\u00eda usar el siguiente c\u00f3digo: 1 2 3 4 DATA VENTAS; INFILE ARCHIVO; INPUT ID NOMBRE $ 10 . APELLIDO $ 19-33 POSICION $ 34 - 53 VOLUMEN PAIS $ 3 . ; RUN; Note que en la sentencia INPUT se declaran a las variables de tipo caracter de dos formas: por posici\u00f3n (ejemplo APELLIDO $ 19-33 ) y por formato (ejemplo NOMBRE $10. ). Para una mayor referencia consulte leyendo datos en bruto en la documentaci\u00f3n de SAS.","title":"Lectura de un archivo de ancho fijo"},{"location":"sas/basico_sas/#lectura-de-un-archivo-de-texto-delimitado","text":"El delimitador predeterminado es un espacio en blanco. Sin embargo, los archivos de texto delimitados por otros caracteres (por ejemplo una coma, tabulador, o s\u00edmbolos especiales) tambien pueden ser le\u00eddos por SAS. Para especificar el tipo de delimitador, se utiliza la opci\u00f3n DLM = en la sentencia INFILE . Considere el siguiente archivo de texto. Puede notarse que est\u00e1 delimitado por el caracter \u201c/\u201d y adem\u00e1s tiene datos perdidos (resaltados en amarillo). De hecho, los valores perdidos al final de la l\u00ednea podr\u00edan hacer que SAS terminara antes de leer los datos. El siguiente c\u00f3digo puede ser usado para leer esos datos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 DATA gerentes; INFILE ARCHIVO DLM = \"/\" DSD TRUNCOVER; ATTRIB id label = \"ID gerente\" nombre LENGTH = $ 12 LABEL = \"Nombre\" apellido LENGTH = $ 18 LABEL = \"Apellido\" genero LENGTH = $ 2 LABEL = \"G\u00e9nero\" ventas LABEL = \"Ventas totales\" posicion LENGTH = $ 18 LABEL = \"Posici\u00f3n\" pais LENGTH = $ 2 LABEL = \"Pa\u00eds\" fnac INFORMAT = date12. FORMAT = ddmmyy10. LABEL = \"Fecha de nacimiento\" fingreso INFORMAT = anydtdte12. FORMAT = ddmmyy10. LABEL = \"Fecha de ingreso\" ; INPUT id -- fingreso ; RUN; La opci\u00f3n DSD es \u00fatil cuando hay un valor faltante en datos delimitados, de otra forma SAS no reconocer\u00eda dos delimitadores juntos y no leer\u00eda los datos correctamente. La opci\u00f3n MISSOVER evita que SAS salte a una nueva linea cuando no encuentra valores v\u00e1lidos y asigna valores faltantes a las variables que no encuentre. TRUNCOVER funciona de manera similar a MISSOVER pero la diferencia radica en que asignar\u00eda los valores que encuentre pasando el fin de l\u00ednea.","title":"Lectura de un archivo de texto delimitado"},{"location":"sas/basico_sas/#leyendo-archivos-desde-web","text":"Para leer datos desde internet (usualmente en formato csv) se debe especificar el nombre del archivo con la sentencia FILENAME con la opci\u00f3n URL . FILENAME fileref URL \u2018 nombre-archivo \u2018 < opciones-url > ; Un ejemplo para descargar datos de covid se encuentran en el siguiente programa de sas: datos_covid_web.sas . Consulte la documentaci\u00f3n de la sentencia FILENAME con el m\u00e9todo de acceso URL para m\u00e1s informaci\u00f3n.","title":"Leyendo archivos desde web"},{"location":"sas/basico_sas/#seleccion-de-observaciones","text":"Es posible seleccionar las observaciones que se quieren escribir en un dataset, sobre todo aquellas que cumplan ciertas condiciones . Al igual que otros lenguajes de programaci\u00f3n SAS tiene expresiones l\u00f3gicas que eval\u00faan cierta condici\u00f3n. La sintaxis es la siguiente: IF expresi\u00f3n ; Esta sentencia nos permite continuar procesando aquellas observaciones que cumplen la condici\u00f3n, generalmente de comparaci\u00f3n. Una expresi\u00f3n puede ser el nombre de una varible y puede contener alg\u00fan operador l\u00f3gico y un operando. Pueden conectarse mediante conectores l\u00f3gicos, comunmente llamados booleanos. La siguiente tabla resume algunos operadores l\u00f3gicos y conectores. S\u00edmbolo Descripci\u00f3n Ejemplo = o EQ IGUAL A sex EQ \"F\" ^= o \u00ac= o ~= o NE NO IGUAL A sex NE \"F\" > o GT MAYOR QUE age GT 13 < o LT MENOR QUE age LT 13 >= o GE MAYOR O IGUAL A age GE 14 <= o LE MENOR QUE O IGUAL A age LE 14 IN (EST\u00c1) EN age in (12 14 15) o sex in (\"F\" \"M\") & o AND Y sex EQ \"F\" AND age GT 13 ! o OR o O sex EQ \"F\" OR age GT 13 ~ o ^ o \u00ac o NOT NO NOT(sex EQ \"F\" OR age GT 13) Por ejemplo el siguiente c\u00f3digo solo contendr\u00eda a empleados de Australia. 1 2 3 4 5 DATA VENTAS_AU; INFILE ARCHIVO; IF PAIS EQ \"AU\" ; INPUT ID 1 - 7 NOMBRE $ 8 - 18 APELLIDO $ 19-33 POSICION $ 34 - 53 VOLUMEN 54 - 60 PAIS $ 61-62 ; RUN; Para elegir observaciones que no sean nulas, se puede usar la siguiente sentencia. 1 2 3 4 5 DATA VENTAS_AU; INFILE ARCHIVO; IF VOLUMEN; INPUT ID 1 - 7 NOMBRE $ 8 - 18 APELLIDO $ 19-33 POSICION $ 34 - 53 VOLUMEN 54 - 60 PAIS $ 61-62 ; RUN;","title":"Selecci\u00f3n de observaciones"},{"location":"sas/basico_sas/#usando-un-procedimiento-para-leer-datos-externos","text":"La forma m\u00e1s f\u00e1cil de leer archivos externos es mediante el procedimiento IMPORT . PROC IMPORT DATAFILE = \u201cfilename\u201d OUT = dataset; Este procedimiento no solo lee archivos de texto, sino tambien de Excel, SPSS, Stata e incluso tablas de Access. Para una mayor referencia vea el procedimiento IMPORT . El siguiente c\u00f3digo leer\u00e1 un archivo en formato excel. 1 2 3 4 PROC IMPORT OUT = WORK . censo DATAFILE = \"C:\\Users\\Usuario\\census.xlsx\" DBMS = XLSX REPLACE ; RUN; N\u00f3tese que se ha especificado la opci\u00f3n DBMS = XLSX para que sas utilice los par\u00e1metros correspondientes para leer un archivo de excel. La opci\u00f3n REPLACE reemplazar\u00eda el dataset que tuviera el mismo nombre, de otro modo SAS mostrar\u00eda un error y no crear\u00eda el dataset. El siguiente c\u00f3digo muestra c\u00f3mo leer un archivo en formato csv. 1 2 3 4 5 6 PROC IMPORT OUT = WORK . census DATAFILE = \"C:\\Users\\Usuario\\census.csv\" DBMS = CSV REPLACE ; GETNAMES = YES; DATAROW = 2 ; RUN; En el caso de archivos csv, hay dos sentencias adicionales, la sentencia GETNAMES = YES indica si los nombres de las variables se encuentran al inicio del archivo de texto, mientras que la sentencia DATAROW = 2 indica que los valores incian en el rengl\u00f3n 2.","title":"Usando un procedimiento para leer datos externos"},{"location":"sas/basico_sas/#escritura-a-un-archivo-externo","text":"SAS tambien puede ser utlizado para escribir archivos externos. En esta secci\u00f3n se mostrar\u00e1 como crear archivos de texto, asi como escribir mensaje del log a archivos externos.","title":"Escritura a un archivo externo"},{"location":"sas/basico_sas/#escritura-de-un-archivo-delimitado","text":"El siguiente c\u00f3digo muestra como crear un archivo de texto. 1 2 3 4 5 6 FILENAME archivo \"C:\\Users\\Usuario\\alumnos.dat\" ; DATA _NULL_ ; FILE archivo; SET sashelp . class; PUT name age sex; RUN; Como se puede ver, se ha referenciado con la sentencia FILENAME el archivo con el nombre que en el que se desea escribir. N\u00f3tese que en la sentencia DATA se ha especificado _NULL_ , una palabra reservada para pedir que no cree ning\u00fan dataset. La sentencia FILE da las especificaciones para escribir los archivos de texto. Es muy similar a la sentencia INFILE , para mayor referencia consulte la sentencia FILE . Finalmente, la sentencia PUT indica lo que se va a escribir en el archivo externo, en este caso se especifican la variables de inter\u00e9s. Para una mayor referencia consulte la sentencia PUT . Archivos delimitados por un caracter SAS crea archivos delimitados por un espacio en blanco. Para crear un archivo delimitado por otro caracter (por ejemplo una coma) se puede usar la opci\u00f3n DLM = . Tambien se puede modificar la extensi\u00f3n del archivo con la sentencia FILENAME . El resultado ser\u00eda el siguiente.","title":"Escritura de un archivo delimitado"},{"location":"sas/basico_sas/#escritura-de-un-archivo-de-texto-de-ancho-fijo","text":"Para crear un archivo de texto de ancho fijo, se puede especificar las posiciones en las que se escribiran las observaciones. 1 2 3 4 5 6 FILENAME archivo \"C:\\Users\\Usuario\\alumnos.txt\" ; DATA _NULL_ ; FILE archivo; SET sashelp . class; PUT name $ 8 . sex 10-12 age 2 . height 16-20 weight 22-25 ; RUN; N\u00f3tese que se han especificado los formatos de las variables y las columnas en las que se desea escribir el archivo, es algo muy similar cuando se le\u00edan los archivos con la sentencia INPUT .","title":"Escritura de un archivo de texto de ancho fijo"},{"location":"sas/basico_sas/#crear-archivos-con-encabezados","text":"Debido a que sas escribe directamente al archivo, es un poco complicado especificarle que en el rengl\u00f3n 1 escriba el nombre de las variables. Sin embargo, el siguiente c\u00f3digo logra especificar el nombre de los archivos en la primer l\u00ednea. 1 2 3 4 5 6 7 FILENAME archivo \"C:\\Users\\Usuario\\alumnos.txt\" ; DATA _NULL_ ; FILE archivo; IF _n_ EQ 1 THEN PUT \"name \" \"sex \" \"age \" \"height \" \"weight \" ; SET sashelp . class; PUT name -- weight; RUN; Esto se logra escribiendo la sentencia PUT justo al inicio e inmediatamente despues se carga el dataset que se quiere escribir. Las sentencias de la l\u00ednea 4 se estudiar\u00e1n en la secci\u00f3n filtrado de datos","title":"Crear archivos con encabezados"},{"location":"sas/basico_sas/#leer-y-modificar-archivos-de-texto","text":"Es posible manipular archivos de texto mediante SAS. para ellos es necesario leerlos y volver a escribir sobre ellos. El siguiente c\u00f3digo muestra como actualizar ciertas variables. 1 2 3 4 5 6 7 8 9 10 11 12 FILENAME ARCHIVO \"C:\\Users\\Usuario\\alumnos.txt\" ; DATA _NULL_ ; INFILE archivo SHAREBUFFERS FIRSTOBS = 2 TRUNCOVER; ATTRIB sex LENGTH = $ 1 sex2 LENGTH = $ 1 ; INPUT sex $ 9 ; IF sex = \"F\" THEN sex2 = \"M\" ; IF sex = \"M\" THEN sex2 = \"H\" ; FILE archivo TRUNCOVER PAD; PUT sex2 9 ; RUN; Note que se la sentencia LIBNAME apunta al mismo archivo que se est\u00e1 usando en las sentencias INFILE y FILE . La opci\u00f3n SHAREBUFFERS es \u00fatil para actualizar un archivo externo y solo actualiza ciertos campos. Esta opci\u00f3n se usa junto con las sentencias INFILE , FILE y PUT . La variable sex2 se usa para guardar el valor que se va a escribir en el archivo cuando sex toma cierto valor. Cuidado con las longitudes Se debe tener cuidado cuando se actualiza un archivo de texto. Se debe procurar que la variable que se lee como la que se escribe tengan la misma longitud, de otro modo pueden haber resultados inesperados. El resultado se muestra a continuaci\u00f3n","title":"Leer y modificar archivos de texto"},{"location":"sas/basico_sas/#escritura-de-datos-con-el-procedimiento-export","text":"As\u00ed como es posible leer datos de forma externa con un procedimiento, tambien hay uno para escribir datos a archivos externos. La sintaxis es muy similar. PROC EXPORT OUTFILE = \u201cfilename\u201d DATA = dataset; El siguiente c\u00f3digo muestra la forma de escribir un dataset a un archivo csv. 1 2 3 4 PROC EXPORT DATA= SASHELP . Class OUTFILE= \"C:\\Users\\Usuario\\alumnos.csv\" DBMS = CSV REPLACE ; RUN; Para mayores referencias consulte el procedimiento EXPORT .","title":"Escritura de datos con el procedimiento EXPORT"},{"location":"sas/conexion/","text":"Conexi\u00f3n con SAS \u00b6 Existen muchas formas de conectar SAS con otros lenguajes de programaci\u00f3n. En esta secci\u00f3n se mostrar\u00e1n algunas maneras de conectarse a con otros programas, ya sea de manera local o remota. Conexi\u00f3n con Python y Jupyter Notebooks \u00b6 Es posible usar SAS \u00ae OnDemand for Academics y conectarlo con los cuadernos de Jupyter. Para ello se requiere lo siguiente: Crear una cuenta en SAS \u00ae OnDemand for Academics para obtener un nombre de usuario y establecer una contrase\u00f1a. Tener instalada la versi\u00f3n m\u00e1s reciente de Anaconda . Tambi\u00e9n se requiere tener instalado Java versi\u00f3n 1.8.0_162 o mayor. Instalar el paquete saspy . Tambi\u00e9n se recomienda instalar el sas kernel para los cuadernos de python. Realizar las configuraciones necesarias . Consulte la ayuda de SAS OnDemand para una referencia completa y detallada. Configuraci\u00f3n de saspy \u00b6 Se puede instalar el paquete saspy desde la consola (cmd o powershell) escribiendo el siguiente comando: 1 pip install saspy Incluye pip La distribuci\u00f3n de Anaconda ya incluye pip, por lo que solo basta escribir el nombre del paquete en la consola. Para comprobar que se ha instalado correctamente, se debe escribir en la consola 1 python Debe de aparecer algo similar a esto: 1 2 3 4 5 6 7 8 9 Python 3.8.8 (default, Apr 13 2021, 15:08:03) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32 Warning: This Python interpreter is in a conda environment, but the environment has not been activated. Libraries may fail to load. To activate this environment please see https://conda.io/activation Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Para comprobar la correcta instalaci\u00f3n de la librer\u00eda, se puede escribir en la consola el siguiente comando: 1 2 import saspy saspy El resultado nos arrojar\u00eda el directorio donde est\u00e1 el archivo de configuraci\u00f3n sascfg.py , por ejemplo: 1 < module 'saspy' from 'C: \\\\ Users \\\\ Usuario \\\\ anaconda3 \\\\ lib \\\\ site-packages \\\\ saspy \\\\ __init__.py' > En dicho directorio se debe crear una copia del archivo sascfg.py nombr\u00e1ndolo sascfg_personal.py . A continuaci\u00f3n se debe borrar el contenido y pegar esto en sascfg_personal.py : 1 2 3 4 5 6 7 8 9 10 11 12 SAS_config_names = [ 'oda' ] oda = { 'java' : 'C: \\\\ Program Files (x86) \\\\ Common Files \\\\ Oracle \\\\ Java \\\\ javapath \\\\ java.exe' , #US Home Region 'iomhost' : [ 'odaws01-usw2.oda.sas.com' , 'odaws02-usw2.oda.sas.com' , 'odaws03-usw2.oda.sas.com' , 'odaws04-usw2.oda.sas.com' ], #European Home Region #'iomhost' : ['odaws01-euw1.oda.sas.com','odaws02-euw1.oda.sas.com'], #Asia Pacific Home Region #'iomhost' : ['odaws01-apse1.oda.sas.com','odaws02-apse1.oda.sas.com'], 'iomport' : 8591 , 'authkey' : 'oda' , 'encoding' : 'utf-8' } Java Verifique que el directorio de Java realmente existe, de otra forma no funcionar\u00e1 correctamente. Posteriormente se debe crear en la carpeta personal (usualmente C:\\Users\\Usuario ) el archivo _authinfo que contenga la informaci\u00f3n de las credenciales de SAS \u00ae OnDemand de la siguiente forma, sustituyendo por los valores que correspondan: 1 oda user usuario password contrase\u00f1a Archivo sin extensi\u00f3n El archivo _authinfo no tiene extensi\u00f3n y debe ser guardado en formato UTF-8 . Si la contrase\u00f1a contiene espacios, se debe poner entre comillas. Una vez realizados estos pasos, puede escribir nuevamente en la consola esta instrucci\u00f3n para comprobar que se puede acceder a SAS OnDemand: 1 2 sas = saspy . SASsession () sas El resultado que se mostrar\u00eda en la pantalla es el siguiente: 1 2 Using SAS Config named : oda SAS Connection established . Subprocess id is 3500 Adicionalmente se puede instalar el sas kernel para los cuadernos de python usando la consola CMD o Powershell. 1 pip install sas_kernel Para comprobar que se ha instalado exitosamente, se puede ejecutar el siguiente comando: 1 jupyter kernelspec list Usando SAS en un cuaderno Jupyter \u00b6 En esta secci\u00f3n se muestra c\u00f3mo usar un cuaderno de Jupyter y conectarlo con SAS. Se usar\u00e1 Visual Studio Code versi\u00f3n 1.62 usando la extensi\u00f3n Jupyter para la generaci\u00f3n del archivo ipynb . Para hacer uso de esta funcionalidad, se debe crear un cuaderno de jupyter con un kernel de SAS. Revise la configuraci\u00f3n de saspy para tener lsito tanto el kernel como el paquete saspy. Nuevo archivo Puede crearse un nuevo cuaderno de jupyter desde el menu Archivo , Seleccionar la opci\u00f3n Nuevo Archivo \u2026 , aparecer\u00e1 la opci\u00f3n de crear opci\u00f3n de crear un nuevo archivo de jupyter. Para pode usarlo, se debe elegir el kernel de SAS y se puede escribir tanto c\u00f3digo de SAS como Markdown el el cuaderno. Los resultados estar\u00e1n dentro del cuaderno de Jupyter y dependiendo de los procedimientos, los resultados ser\u00e1n mostrados en formato HTML. La siguiente imagen muestra el funcionamiento de SAS en un cuaderno de Jupyter. Consulte la documentaci\u00f3n de sas kernel para m\u00e1s informaci\u00f3n. Usando el paquete saspy en un cuaderno Jupyter \u00b6 Las librer\u00eda y datasets de SAS pueden usarse dentro de Python a trav\u00e9s del paquete saspy. Para hacer uso de la librer\u00eda, se debe crear un cuaderno de jupyter con un kernel de python. Revise la configuraci\u00f3n de saspy para tener todo listo y evitar alg\u00fan error. El primer paso es cargar el paquete saspy escribiendo el siguiente c\u00f3digo en una celda de c\u00f3digo python: 1 2 3 import saspy sas = saspy . SASsession () sas Se desplegar\u00e1 informaci\u00f3n acerca de la conexi\u00f3n a SAS \u00ae OnDemand y sus configuraciones. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Using SAS Config named : oda SAS Connection established . Subprocess id is 2816 Access Method = IOM SAS Config name = oda SAS Config file = C : \\ Users \\ Usuario \\ anaconda3 \\ lib \\ site - packages \\ saspy \\ sascfg_personal . py WORK Path = / saswork / SAS_work32430000E59D_odaws01 - usw2 . oda . sas . com / SAS_work6D2A0000E59D_odaws01 - usw2 . oda . sas . com / SAS Version = 9.04.01 M6P11072018 SASPy Version = 3.7.5 Teach me SAS = False Batch = False Results = Pandas SAS Session Encoding = utf - 8 Python Encoding value = utf - 8 SAS process Pid value = 58781 La siguiente imagen muestra algunas funcionalidades del paquete saspy. Consulte la documentaci\u00f3n de saspy para una referencia completa de los m\u00e9todos del paquete. Usando c\u00f3digo SAS usando cualquier kernel de Jupyter \u00b6 Es posible usar c\u00f3digo SAS en un cuaderno de Jupyter directamente, aunque el kernel no sea de SAS. Para hacer esto, se hace uso de los SAS MAGICS , que son trozos de c\u00f3digo de otro lenguaje que se ejecutan. Simplemente en una celda nueva se debe colocar al inicio %%SAS y debajo el c\u00f3digo SAS que se desea realizar. La siguiente muestra su uso. N\u00f3tese que a pesar de estar en un cuaderno con kernel python, se ha realizado una conexi\u00f3n con SAS y se ha ejecutado el c\u00f3digo de la celda. Activar el paquete No olvide activar el paquete saspy antes de usar el sas magic para evitar errores.","title":"Conexi\u00f3n con otros programas"},{"location":"sas/conexion/#conexion-con-sas","text":"Existen muchas formas de conectar SAS con otros lenguajes de programaci\u00f3n. En esta secci\u00f3n se mostrar\u00e1n algunas maneras de conectarse a con otros programas, ya sea de manera local o remota.","title":"Conexi\u00f3n con SAS"},{"location":"sas/conexion/#conexion-con-python-y-jupyter-notebooks","text":"Es posible usar SAS \u00ae OnDemand for Academics y conectarlo con los cuadernos de Jupyter. Para ello se requiere lo siguiente: Crear una cuenta en SAS \u00ae OnDemand for Academics para obtener un nombre de usuario y establecer una contrase\u00f1a. Tener instalada la versi\u00f3n m\u00e1s reciente de Anaconda . Tambi\u00e9n se requiere tener instalado Java versi\u00f3n 1.8.0_162 o mayor. Instalar el paquete saspy . Tambi\u00e9n se recomienda instalar el sas kernel para los cuadernos de python. Realizar las configuraciones necesarias . Consulte la ayuda de SAS OnDemand para una referencia completa y detallada.","title":"Conexi\u00f3n con Python y Jupyter Notebooks"},{"location":"sas/conexion/#configuracion-de-saspy","text":"Se puede instalar el paquete saspy desde la consola (cmd o powershell) escribiendo el siguiente comando: 1 pip install saspy Incluye pip La distribuci\u00f3n de Anaconda ya incluye pip, por lo que solo basta escribir el nombre del paquete en la consola. Para comprobar que se ha instalado correctamente, se debe escribir en la consola 1 python Debe de aparecer algo similar a esto: 1 2 3 4 5 6 7 8 9 Python 3.8.8 (default, Apr 13 2021, 15:08:03) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32 Warning: This Python interpreter is in a conda environment, but the environment has not been activated. Libraries may fail to load. To activate this environment please see https://conda.io/activation Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Para comprobar la correcta instalaci\u00f3n de la librer\u00eda, se puede escribir en la consola el siguiente comando: 1 2 import saspy saspy El resultado nos arrojar\u00eda el directorio donde est\u00e1 el archivo de configuraci\u00f3n sascfg.py , por ejemplo: 1 < module 'saspy' from 'C: \\\\ Users \\\\ Usuario \\\\ anaconda3 \\\\ lib \\\\ site-packages \\\\ saspy \\\\ __init__.py' > En dicho directorio se debe crear una copia del archivo sascfg.py nombr\u00e1ndolo sascfg_personal.py . A continuaci\u00f3n se debe borrar el contenido y pegar esto en sascfg_personal.py : 1 2 3 4 5 6 7 8 9 10 11 12 SAS_config_names = [ 'oda' ] oda = { 'java' : 'C: \\\\ Program Files (x86) \\\\ Common Files \\\\ Oracle \\\\ Java \\\\ javapath \\\\ java.exe' , #US Home Region 'iomhost' : [ 'odaws01-usw2.oda.sas.com' , 'odaws02-usw2.oda.sas.com' , 'odaws03-usw2.oda.sas.com' , 'odaws04-usw2.oda.sas.com' ], #European Home Region #'iomhost' : ['odaws01-euw1.oda.sas.com','odaws02-euw1.oda.sas.com'], #Asia Pacific Home Region #'iomhost' : ['odaws01-apse1.oda.sas.com','odaws02-apse1.oda.sas.com'], 'iomport' : 8591 , 'authkey' : 'oda' , 'encoding' : 'utf-8' } Java Verifique que el directorio de Java realmente existe, de otra forma no funcionar\u00e1 correctamente. Posteriormente se debe crear en la carpeta personal (usualmente C:\\Users\\Usuario ) el archivo _authinfo que contenga la informaci\u00f3n de las credenciales de SAS \u00ae OnDemand de la siguiente forma, sustituyendo por los valores que correspondan: 1 oda user usuario password contrase\u00f1a Archivo sin extensi\u00f3n El archivo _authinfo no tiene extensi\u00f3n y debe ser guardado en formato UTF-8 . Si la contrase\u00f1a contiene espacios, se debe poner entre comillas. Una vez realizados estos pasos, puede escribir nuevamente en la consola esta instrucci\u00f3n para comprobar que se puede acceder a SAS OnDemand: 1 2 sas = saspy . SASsession () sas El resultado que se mostrar\u00eda en la pantalla es el siguiente: 1 2 Using SAS Config named : oda SAS Connection established . Subprocess id is 3500 Adicionalmente se puede instalar el sas kernel para los cuadernos de python usando la consola CMD o Powershell. 1 pip install sas_kernel Para comprobar que se ha instalado exitosamente, se puede ejecutar el siguiente comando: 1 jupyter kernelspec list","title":"Configuraci\u00f3n de saspy"},{"location":"sas/conexion/#usando-sas-en-un-cuaderno-jupyter","text":"En esta secci\u00f3n se muestra c\u00f3mo usar un cuaderno de Jupyter y conectarlo con SAS. Se usar\u00e1 Visual Studio Code versi\u00f3n 1.62 usando la extensi\u00f3n Jupyter para la generaci\u00f3n del archivo ipynb . Para hacer uso de esta funcionalidad, se debe crear un cuaderno de jupyter con un kernel de SAS. Revise la configuraci\u00f3n de saspy para tener lsito tanto el kernel como el paquete saspy. Nuevo archivo Puede crearse un nuevo cuaderno de jupyter desde el menu Archivo , Seleccionar la opci\u00f3n Nuevo Archivo \u2026 , aparecer\u00e1 la opci\u00f3n de crear opci\u00f3n de crear un nuevo archivo de jupyter. Para pode usarlo, se debe elegir el kernel de SAS y se puede escribir tanto c\u00f3digo de SAS como Markdown el el cuaderno. Los resultados estar\u00e1n dentro del cuaderno de Jupyter y dependiendo de los procedimientos, los resultados ser\u00e1n mostrados en formato HTML. La siguiente imagen muestra el funcionamiento de SAS en un cuaderno de Jupyter. Consulte la documentaci\u00f3n de sas kernel para m\u00e1s informaci\u00f3n.","title":"Usando SAS en un cuaderno Jupyter"},{"location":"sas/conexion/#usando-el-paquete-saspy-en-un-cuaderno-jupyter","text":"Las librer\u00eda y datasets de SAS pueden usarse dentro de Python a trav\u00e9s del paquete saspy. Para hacer uso de la librer\u00eda, se debe crear un cuaderno de jupyter con un kernel de python. Revise la configuraci\u00f3n de saspy para tener todo listo y evitar alg\u00fan error. El primer paso es cargar el paquete saspy escribiendo el siguiente c\u00f3digo en una celda de c\u00f3digo python: 1 2 3 import saspy sas = saspy . SASsession () sas Se desplegar\u00e1 informaci\u00f3n acerca de la conexi\u00f3n a SAS \u00ae OnDemand y sus configuraciones. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Using SAS Config named : oda SAS Connection established . Subprocess id is 2816 Access Method = IOM SAS Config name = oda SAS Config file = C : \\ Users \\ Usuario \\ anaconda3 \\ lib \\ site - packages \\ saspy \\ sascfg_personal . py WORK Path = / saswork / SAS_work32430000E59D_odaws01 - usw2 . oda . sas . com / SAS_work6D2A0000E59D_odaws01 - usw2 . oda . sas . com / SAS Version = 9.04.01 M6P11072018 SASPy Version = 3.7.5 Teach me SAS = False Batch = False Results = Pandas SAS Session Encoding = utf - 8 Python Encoding value = utf - 8 SAS process Pid value = 58781 La siguiente imagen muestra algunas funcionalidades del paquete saspy. Consulte la documentaci\u00f3n de saspy para una referencia completa de los m\u00e9todos del paquete.","title":"Usando el paquete saspy en un cuaderno Jupyter"},{"location":"sas/conexion/#usando-codigo-sas-usando-cualquier-kernel-de-jupyter","text":"Es posible usar c\u00f3digo SAS en un cuaderno de Jupyter directamente, aunque el kernel no sea de SAS. Para hacer esto, se hace uso de los SAS MAGICS , que son trozos de c\u00f3digo de otro lenguaje que se ejecutan. Simplemente en una celda nueva se debe colocar al inicio %%SAS y debajo el c\u00f3digo SAS que se desea realizar. La siguiente muestra su uso. N\u00f3tese que a pesar de estar en un cuaderno con kernel python, se ha realizado una conexi\u00f3n con SAS y se ha ejecutado el c\u00f3digo de la celda. Activar el paquete No olvide activar el paquete saspy antes de usar el sas magic para evitar errores.","title":"Usando c\u00f3digo SAS usando cualquier kernel de Jupyter"},{"location":"sas/intro_sas/","text":"Elementos esenciales \u00b6 Este es un tutorial breve sobre el programa, se muestran los principales conceptos de SAS para iniciarse en SAS. En esta secci\u00f3n se aprender\u00e1n los principios sobre los cuales se basa SAS, as\u00ed como algunas definiciones importantes como datasets o librer\u00edas. Finalmente se muestran algunas pinceladas de lo que se puede hacer con SAS mediante el uso lenguaje m\u00e1s avanzado. Instalaci\u00f3n e interfaces gr\u00e1ficas \u00b6 Consulte el sitio web de sas para m\u00e1s detalles. SAS \u00ae OnDemand for Academics SAS \u00ae software no es libre ni de c\u00f3digo abierto, sin embargo usted puede usarlo gratuitamente con fines de aprendizaje. Visite SAS \u00ae OnDemand for Academics para m\u00e1s informaci\u00f3n. SAS \u00ae BASE es la interfaz gr\u00e1fica cl\u00e1sica de SAS. Contiene una verntana lateral con una lista de librer\u00edas, mientras que hay una ventana principal de mensajes (log) y otra para escribir c\u00f3digo. Esta interfaz fue de las primeras en desarrollarse y por ello ya no ha sido mejorada por lo que podr\u00eda carecer de nuevas caracter\u00edsticas. Su principal ventaja es que gasta pocos recurso y es bastante r\u00e1pida. SAS \u00ae Enterprise Guide es la interfaz gr\u00e1fica m\u00e1s reciente y es constantemente mejorada. Esta versi\u00f3n tiene muchas caracter\u00edsticas y adem\u00e1s permite crear distintos perfiles de usuario. Tiene un panel principal en el cual se muestra el flujo de trabajo. La idea b\u00e1sica es ir trabajando en peque\u00f1os programas y se conectan entre s\u00ed, con el fin de tener una visi\u00f3n m\u00e1s global de lo que se est\u00e1 realizando. Tambi\u00e9n puede usarse la interfaz de SAS \u00ae Studio Conceptos b\u00e1sicos \u00b6 En esta secci\u00f3n se mostrar\u00e1n los elementos b\u00e1sicos de SAS, tales como los bloques b\u00e1sico de programaci\u00f3n (pasos DATA y PROC), conceptos como bibliotecas, datasets, entre otros. Procedimientos y pasos DATA \u00b6 SAS se compone de dos grandes bloques: el paso DATA y el paso PROC. El bloque DATA sirve para leer o generar datos, mientras que el bloque PROC generalmente sirve para analizar dichos datos, aunque hay muchos procedimientos. Este sencillo ejemplo muestra el flujo general de los programas de sas. Primero se crear\u00e1 un dataset con el bloque de instrucciones DATA. 1 2 3 4 5 6 7 8 9 10 11 DATA calificaciones; INPUT nombre $ Grupo $ puntaje; DATALINES; ANGELICA A 10 BRENDA A 9 MARCO B 8 LILIANA B 8 FABIAN C 9 MAURICIO C 7 ; RUN; SAS no muestra directamente los resultados, en su lugar, se escribe un mensaje en la ventana de log. Para visualizar el dataset creado, se debe ejecutar el siguiente c\u00f3digo, que constituye el paso PROC: 1 2 PROC PRINT DATA = calificaciones ; RUN; El resultado se muestra a continuaci\u00f3n Aunque se ha producido un resultado, nuevamente aparece un mensaje en la ventana del log: En el log aparecen las instrucciones que se ejecutaron, seguido de un mensaje indicando que los resultados se estan escribiendo en un archivo html. Finalmente en el log se nos indica el n\u00famero de observaciones le\u00eddas y el tiempo de ejecuci\u00f3n del procedimiento. Como puede verse, el log siempre est\u00e1 activo y registra todas las acciones ejecutadas. Posteriormente se ver\u00e1n como nos puede ayudar a encontrar errores y nos apoyar\u00e1 en la resoluci\u00f3n de estos. Datasets \u00b6 SAS almacena los datos en tablas llamadas datasets, los cuales son archivos que se almacenan en bibliotecas (library). SAS maneja dos tipos de datos: num\u00e9ricos y caracter. Los dataset permiten almacenar un tipo de dato en cada variable. Para crear un dataset, se utiliza el bloque de instrucciones conocido como paso DATA. El paso DATA inicia con la sentencia DATA seguido del nombre del dataset y termina con la palabra clave RUN. Por ejemplo el siguiente c\u00f3digo crea un dataset con 1 observaci\u00f3n y tres variables (2 num\u00e9ricas y otra caracter). 1 2 3 4 5 6 7 8 DATA EJEMPLO; FORMAT FECHA DATE.; FECHA = TODAY( ); INPUT X GRUPO $; DATALINES; 12.5 azul ; RUN; La primer sentencia define el nombre del dataset. La segunda le asigna un formato de fecha a la variable fecha. Esto a se debe a que internamente SAS almacena el resultado como un valor num\u00e9rico, pero quisieramos visualizarlo como una fecha. En la tercer sentencia se define una variable num\u00e9rica mediante una funci\u00f3n, la cual obtiene la fecha de hoy (n\u00famero de d\u00edas transcurridos desde el 1 de enero de 1960). En la siguiente sentencia se declaran 2 variables que sas va a recibir, la segunda se define como caracter al agregarle el signo $ . La sentencia DATALINES le dice al programa que se introducir\u00e1n valores de manera manual (cada rengl\u00f3n representa la primera observaci\u00f3n y cada variable est\u00e1 separada por un espacio). El punto y coma dicta el fin de la introducci\u00f3n de datos. Finalmente la palabra RUN define el fin del paso DATA. Un dataset consiste de dos partes: Una porci\u00f3n descriptora Una porci\u00f3n de datos La porci\u00f3n de datos es una colecci\u00f3n de datos arreglados en una tabla rectangular. Cada rengl\u00f3n o observaci\u00f3n representa mediciones de un individuo. La porci\u00f3n descriptora de un dataset contiene informaci\u00f3n del descriptor, por ejemplo, el nombre, fecha y hora de creaci\u00f3n, n\u00famero de observaciones y n\u00famero de variables. La porci\u00f3n descriptora tambien contiene informaci\u00f3n de los atributos de cada variable en el dataset. Los atributos contienen informaci\u00f3n como el nombre de la variable, el tipo, longitud, formato, informato y etiqueta. El siguiente cuadro resume los atributos de las variables. Atributo Valor Ejemplo Requerido Nota Nombre Nombre SAS _nombre_alumno2 S\u00ed Hasta 32 car\u00e1cteres, iniciando con _ o una letras, puede contener valores num\u00e9ricos. Tipo char o num num S\u00ed Los valores perdidos (missing) para variables num\u00e9ricas se representan con . o con \"\" para caracter. Longitud Hasta 32,767 bytes para caracter, 8 para variables num\u00e9ricas 8 S\u00ed Las variables num\u00e9ricas se almacenan como valores de punto flotante en 8 bytes de longitud. Formato Nombre de formato date10. No Consulte Formatos de SAS para una referencia completa Informato Nombre de Informato dollar10. No Consulte Informatos de SAS para una referencia completa Etiqueta Una cadena de hasta 256 caracteres \u201cSegundo nombre del alumno\u201d No Algunos procedimientos o reportes usan la etiqueta en lugar del nombre de la variable. Es posible conocer las propiedades de un dataset usando el PROCEDIMIENTO CONTENTS para conocer la porci\u00f3n descriptora de un dataset. El siguiente c\u00f3digo nos muestra c\u00f3mo saber las propiedades de un dataset almacenado en sas. 1 2 PROC CONTENTS DATA = SASHELP . HEART VARNUM ; RUN; El resultado se muestra a continuaci\u00f3n Librer\u00edas \u00b6 Las librer\u00edas o bibliotecas son rutas donde se almacenan los datasets. Librer\u00eda Una librer\u00eda de SAS es una colecci\u00f3n de archivos de SAS. Es el nivel m\u00e1s alto de organizaci\u00f3n para la informaci\u00f3n dentro de SAS. En el sistema operativo Windows o UNIX, una librer\u00eda es t\u00edpicamente un grupo de archivos de SAS en el mismo folder o directorio. Si no se define una librer\u00eda, sas define una librer\u00eda temporal llamada WORK, la cual eliminar\u00e1 todos los datasets al finalizar la sesi\u00f3n. Para definir una librer\u00eda, se puede asignar una librer\u00eda a un ruta de la forma: LIBNAME libref \u2018 sas-library \u2019; donde libref es el nombre de la librer\u00eda (un nombre de sas de 1 a 8 caracteres que inicia con una letra o gui\u00f3n bajo y contiene solo letras, n\u00fameros o gui\u00f3n bajo) y sas-library es la ruta donde se almacenar\u00e1n los dataset, por ejemplo: 1 LIBNAME TAREAS \"C:\\Users\\Default\\Documents\" ; asignar\u00eda dicho directorio a la librer\u00eda TAREAS . Para referirse a un dataset almacenado en dicha librer\u00eda, se utiliza el siguiente nombre LIBRARY.DATASET , por ejemplo TAREAS.TABLA . Macros y variables macro \u00b6 Adem\u00e1s de los pasos PROC y DATA, SAS tiene un lenguaje especial llamado lenguaje macro, el cual especie de procesador de instrucciones que compila y ejecuta. Este lenguaje es muy \u00fatil para ejecutar tareas comunes o repetitivas A diferencia de otros lenguajes de programaci\u00f3n, SAS no permite definir variables de forma directa. Sin embargo, es posible definir variables macro , las cuales almacenan un valor ya sea un n\u00famero o un texto. Dichas variables son evaluadas y pueden ser llamadas en cualquier procedimiento macro. Hay tres formas de crear variables macro: Con la sentencia %let . Con la llamada symput() . con la sentencia INTO dentro de un procedimiento SQL. Se usa la sentencia %let macro-variable = <value>; y para mandar llamar el valor de dicha variable maro se usa &macro-variable . Por ejemplo si se desea definir ciertas variables a analizar, se puede crear la siguiente sentencia; 1 2 3 4 5 %let x = age weight height ; PROC MEANS DATA = SASHELP . CLASS; VAR &X ; RUN; Para ver el valor de la variable macro, se puede usar la sentencia macro %PUT <&macro-variable> , por ejemplo: 1 %PUT &x ; y el resultado ser\u00e1 age weight height Para m\u00e1s informaci\u00f3n acerca de sentencias y variables macro visite la documentaci\u00f3n de SAS . Consiguiendo ayuda \u00b6 En internet existe muchos recursos para encontrar ayuda acerca de SAS. Una de los mejores sitios para encontrar ayuda es en el foro de sas communities . Tambi\u00e9n existe una versi\u00f3n en espa\u00f1ol enfocada en usuarios de M\u00e9xico y Latinoam\u00e9rica. Tambi\u00e9n hay un blog en donde se abordan distintos temas especializados tales como gr\u00e1ficos , programaci\u00f3n , entre otros.","title":"Introducci\u00f3n a SAS"},{"location":"sas/intro_sas/#elementos-esenciales","text":"Este es un tutorial breve sobre el programa, se muestran los principales conceptos de SAS para iniciarse en SAS. En esta secci\u00f3n se aprender\u00e1n los principios sobre los cuales se basa SAS, as\u00ed como algunas definiciones importantes como datasets o librer\u00edas. Finalmente se muestran algunas pinceladas de lo que se puede hacer con SAS mediante el uso lenguaje m\u00e1s avanzado.","title":"Elementos esenciales"},{"location":"sas/intro_sas/#instalacion-e-interfaces-graficas","text":"Consulte el sitio web de sas para m\u00e1s detalles. SAS \u00ae OnDemand for Academics SAS \u00ae software no es libre ni de c\u00f3digo abierto, sin embargo usted puede usarlo gratuitamente con fines de aprendizaje. Visite SAS \u00ae OnDemand for Academics para m\u00e1s informaci\u00f3n. SAS \u00ae BASE es la interfaz gr\u00e1fica cl\u00e1sica de SAS. Contiene una verntana lateral con una lista de librer\u00edas, mientras que hay una ventana principal de mensajes (log) y otra para escribir c\u00f3digo. Esta interfaz fue de las primeras en desarrollarse y por ello ya no ha sido mejorada por lo que podr\u00eda carecer de nuevas caracter\u00edsticas. Su principal ventaja es que gasta pocos recurso y es bastante r\u00e1pida. SAS \u00ae Enterprise Guide es la interfaz gr\u00e1fica m\u00e1s reciente y es constantemente mejorada. Esta versi\u00f3n tiene muchas caracter\u00edsticas y adem\u00e1s permite crear distintos perfiles de usuario. Tiene un panel principal en el cual se muestra el flujo de trabajo. La idea b\u00e1sica es ir trabajando en peque\u00f1os programas y se conectan entre s\u00ed, con el fin de tener una visi\u00f3n m\u00e1s global de lo que se est\u00e1 realizando. Tambi\u00e9n puede usarse la interfaz de SAS \u00ae Studio","title":"Instalaci\u00f3n e interfaces gr\u00e1ficas"},{"location":"sas/intro_sas/#conceptos-basicos","text":"En esta secci\u00f3n se mostrar\u00e1n los elementos b\u00e1sicos de SAS, tales como los bloques b\u00e1sico de programaci\u00f3n (pasos DATA y PROC), conceptos como bibliotecas, datasets, entre otros.","title":"Conceptos b\u00e1sicos"},{"location":"sas/intro_sas/#procedimientos-y-pasos-data","text":"SAS se compone de dos grandes bloques: el paso DATA y el paso PROC. El bloque DATA sirve para leer o generar datos, mientras que el bloque PROC generalmente sirve para analizar dichos datos, aunque hay muchos procedimientos. Este sencillo ejemplo muestra el flujo general de los programas de sas. Primero se crear\u00e1 un dataset con el bloque de instrucciones DATA. 1 2 3 4 5 6 7 8 9 10 11 DATA calificaciones; INPUT nombre $ Grupo $ puntaje; DATALINES; ANGELICA A 10 BRENDA A 9 MARCO B 8 LILIANA B 8 FABIAN C 9 MAURICIO C 7 ; RUN; SAS no muestra directamente los resultados, en su lugar, se escribe un mensaje en la ventana de log. Para visualizar el dataset creado, se debe ejecutar el siguiente c\u00f3digo, que constituye el paso PROC: 1 2 PROC PRINT DATA = calificaciones ; RUN; El resultado se muestra a continuaci\u00f3n Aunque se ha producido un resultado, nuevamente aparece un mensaje en la ventana del log: En el log aparecen las instrucciones que se ejecutaron, seguido de un mensaje indicando que los resultados se estan escribiendo en un archivo html. Finalmente en el log se nos indica el n\u00famero de observaciones le\u00eddas y el tiempo de ejecuci\u00f3n del procedimiento. Como puede verse, el log siempre est\u00e1 activo y registra todas las acciones ejecutadas. Posteriormente se ver\u00e1n como nos puede ayudar a encontrar errores y nos apoyar\u00e1 en la resoluci\u00f3n de estos.","title":"Procedimientos y pasos DATA"},{"location":"sas/intro_sas/#datasets","text":"SAS almacena los datos en tablas llamadas datasets, los cuales son archivos que se almacenan en bibliotecas (library). SAS maneja dos tipos de datos: num\u00e9ricos y caracter. Los dataset permiten almacenar un tipo de dato en cada variable. Para crear un dataset, se utiliza el bloque de instrucciones conocido como paso DATA. El paso DATA inicia con la sentencia DATA seguido del nombre del dataset y termina con la palabra clave RUN. Por ejemplo el siguiente c\u00f3digo crea un dataset con 1 observaci\u00f3n y tres variables (2 num\u00e9ricas y otra caracter). 1 2 3 4 5 6 7 8 DATA EJEMPLO; FORMAT FECHA DATE.; FECHA = TODAY( ); INPUT X GRUPO $; DATALINES; 12.5 azul ; RUN; La primer sentencia define el nombre del dataset. La segunda le asigna un formato de fecha a la variable fecha. Esto a se debe a que internamente SAS almacena el resultado como un valor num\u00e9rico, pero quisieramos visualizarlo como una fecha. En la tercer sentencia se define una variable num\u00e9rica mediante una funci\u00f3n, la cual obtiene la fecha de hoy (n\u00famero de d\u00edas transcurridos desde el 1 de enero de 1960). En la siguiente sentencia se declaran 2 variables que sas va a recibir, la segunda se define como caracter al agregarle el signo $ . La sentencia DATALINES le dice al programa que se introducir\u00e1n valores de manera manual (cada rengl\u00f3n representa la primera observaci\u00f3n y cada variable est\u00e1 separada por un espacio). El punto y coma dicta el fin de la introducci\u00f3n de datos. Finalmente la palabra RUN define el fin del paso DATA. Un dataset consiste de dos partes: Una porci\u00f3n descriptora Una porci\u00f3n de datos La porci\u00f3n de datos es una colecci\u00f3n de datos arreglados en una tabla rectangular. Cada rengl\u00f3n o observaci\u00f3n representa mediciones de un individuo. La porci\u00f3n descriptora de un dataset contiene informaci\u00f3n del descriptor, por ejemplo, el nombre, fecha y hora de creaci\u00f3n, n\u00famero de observaciones y n\u00famero de variables. La porci\u00f3n descriptora tambien contiene informaci\u00f3n de los atributos de cada variable en el dataset. Los atributos contienen informaci\u00f3n como el nombre de la variable, el tipo, longitud, formato, informato y etiqueta. El siguiente cuadro resume los atributos de las variables. Atributo Valor Ejemplo Requerido Nota Nombre Nombre SAS _nombre_alumno2 S\u00ed Hasta 32 car\u00e1cteres, iniciando con _ o una letras, puede contener valores num\u00e9ricos. Tipo char o num num S\u00ed Los valores perdidos (missing) para variables num\u00e9ricas se representan con . o con \"\" para caracter. Longitud Hasta 32,767 bytes para caracter, 8 para variables num\u00e9ricas 8 S\u00ed Las variables num\u00e9ricas se almacenan como valores de punto flotante en 8 bytes de longitud. Formato Nombre de formato date10. No Consulte Formatos de SAS para una referencia completa Informato Nombre de Informato dollar10. No Consulte Informatos de SAS para una referencia completa Etiqueta Una cadena de hasta 256 caracteres \u201cSegundo nombre del alumno\u201d No Algunos procedimientos o reportes usan la etiqueta en lugar del nombre de la variable. Es posible conocer las propiedades de un dataset usando el PROCEDIMIENTO CONTENTS para conocer la porci\u00f3n descriptora de un dataset. El siguiente c\u00f3digo nos muestra c\u00f3mo saber las propiedades de un dataset almacenado en sas. 1 2 PROC CONTENTS DATA = SASHELP . HEART VARNUM ; RUN; El resultado se muestra a continuaci\u00f3n","title":"Datasets"},{"location":"sas/intro_sas/#librerias","text":"Las librer\u00edas o bibliotecas son rutas donde se almacenan los datasets. Librer\u00eda Una librer\u00eda de SAS es una colecci\u00f3n de archivos de SAS. Es el nivel m\u00e1s alto de organizaci\u00f3n para la informaci\u00f3n dentro de SAS. En el sistema operativo Windows o UNIX, una librer\u00eda es t\u00edpicamente un grupo de archivos de SAS en el mismo folder o directorio. Si no se define una librer\u00eda, sas define una librer\u00eda temporal llamada WORK, la cual eliminar\u00e1 todos los datasets al finalizar la sesi\u00f3n. Para definir una librer\u00eda, se puede asignar una librer\u00eda a un ruta de la forma: LIBNAME libref \u2018 sas-library \u2019; donde libref es el nombre de la librer\u00eda (un nombre de sas de 1 a 8 caracteres que inicia con una letra o gui\u00f3n bajo y contiene solo letras, n\u00fameros o gui\u00f3n bajo) y sas-library es la ruta donde se almacenar\u00e1n los dataset, por ejemplo: 1 LIBNAME TAREAS \"C:\\Users\\Default\\Documents\" ; asignar\u00eda dicho directorio a la librer\u00eda TAREAS . Para referirse a un dataset almacenado en dicha librer\u00eda, se utiliza el siguiente nombre LIBRARY.DATASET , por ejemplo TAREAS.TABLA .","title":"Librer\u00edas"},{"location":"sas/intro_sas/#macros-y-variables-macro","text":"Adem\u00e1s de los pasos PROC y DATA, SAS tiene un lenguaje especial llamado lenguaje macro, el cual especie de procesador de instrucciones que compila y ejecuta. Este lenguaje es muy \u00fatil para ejecutar tareas comunes o repetitivas A diferencia de otros lenguajes de programaci\u00f3n, SAS no permite definir variables de forma directa. Sin embargo, es posible definir variables macro , las cuales almacenan un valor ya sea un n\u00famero o un texto. Dichas variables son evaluadas y pueden ser llamadas en cualquier procedimiento macro. Hay tres formas de crear variables macro: Con la sentencia %let . Con la llamada symput() . con la sentencia INTO dentro de un procedimiento SQL. Se usa la sentencia %let macro-variable = <value>; y para mandar llamar el valor de dicha variable maro se usa &macro-variable . Por ejemplo si se desea definir ciertas variables a analizar, se puede crear la siguiente sentencia; 1 2 3 4 5 %let x = age weight height ; PROC MEANS DATA = SASHELP . CLASS; VAR &X ; RUN; Para ver el valor de la variable macro, se puede usar la sentencia macro %PUT <&macro-variable> , por ejemplo: 1 %PUT &x ; y el resultado ser\u00e1 age weight height Para m\u00e1s informaci\u00f3n acerca de sentencias y variables macro visite la documentaci\u00f3n de SAS .","title":"Macros y variables macro"},{"location":"sas/intro_sas/#consiguiendo-ayuda","text":"En internet existe muchos recursos para encontrar ayuda acerca de SAS. Una de los mejores sitios para encontrar ayuda es en el foro de sas communities . Tambi\u00e9n existe una versi\u00f3n en espa\u00f1ol enfocada en usuarios de M\u00e9xico y Latinoam\u00e9rica. Tambi\u00e9n hay un blog en donde se abordan distintos temas especializados tales como gr\u00e1ficos , programaci\u00f3n , entre otros.","title":"Consiguiendo ayuda"},{"location":"sas/manejo_variables/","text":"Manejo de bases \u00b6 En esta secci\u00f3n se presentan temas m\u00e1s profundos acerca del procesamiento de datos. Se explorar\u00e1n distintas formas de manejar bases mediante uso de variables, seleccionar observaciones as\u00ed como el uso de ciclos y arreglos que nos permitan tener un mayor control de la informaci\u00f3n que se tenga. Primero se ver\u00e1 la forma de crear variables con el fin de realizar c\u00e1lculos posteriores, estas variables pueden ser usadas incluso para crear varios datasets, crear contadores o acumuladores, entre otras. Tambi\u00e9n se conocer\u00e1n t\u00e9cnicas de selecci\u00f3n de observaciones con el fin de manipular mejor las bases. Despu\u00e9s se explorar\u00e1 un poco el tema del ordenamiento con el fin de crear ya sea grupos o realizar otras operciones como uniones, transposiciones entre otras. Antes de continuar con temas mas complejos, es importante comprender de forma general el funcionamiento del paso DATA. Para una explicaci\u00f3n m\u00e1s detallada consulte C\u00f3mo funciona el paso DATA . El paso DATA tiene dos fases: Fase de compilaci\u00f3n Fase de ejecuci\u00f3n A continuaci\u00f3n se describir\u00b4n de forma breve estas fases. Durante la fase de compilaci\u00f3n, SAS revisa la sintaxis y si es correcta, se manda a c\u00f3digo m\u00e1quina en dondese procesa el c\u00f3digo y se generan los siguientes objetos: Memoria de entrada . Es un lugar en la memoria donde SAS lee registros de un archivo de texto cuando el programa se ejecute. Vector de datos del programa . Es un lugar en la memoria donde SAS construye un conjunto de datos, una observaci\u00f3n a la vez. Porci\u00f3n descriptora . Es la informaci\u00f3n general del dataset como el nombre de la base y los atributos de las variables a crear. La memoria de entrada solo aplica en el caso en que se lean archivos externos. En este caso, los datos se leen de la memoria de entrada al vector de datos del programa. El vector de datos del programa (VDP) es importante porque en \u00e9ste se realizar\u00edan los c\u00e1lculos de las sentencias de SAS o funciones. Contiene el nombre de todas las variables declaradas o inicializadas. Es como un paso intermedio entre lo que se lee y calcula con lo que se se escribe al dataset. Al inicio de cada iteraci\u00f3n los valores en el VDP son iniciados con valor missing y son llenados seg\u00fan lea o ejecuten sentencias. Durante la fase de compilaci\u00f3n tambien se crean dos variables auxiliares en el VDP que no se escribir\u00e1n en el dataset: _N_ y _ERROR_ . La primera cuenta el n\u00famero de veces que el paso DATA itera y la segunda registra si hubo alg\u00fan problema en la fase de ejecuci\u00f3n. Una vez conclu\u00edda esta etapa, se procede a la siguiente fase. En la fase de ejecuci\u00f3n se realizan las siguientes acciones: Se leen las observaciones del VDP. Se ejecutan las sentencias (c\u00e1lculo de variables). Se escriben al dataset. La variables en el VDP son reiniciadas y se colocan valores missing. Debido a que es un procesos repetitivo, SAS realiza los pasos mencionados tantas veces como observaciones haya en el archivo externo o dataset le\u00eddo. El proceso termina cuando ya no hay registros que leer y en ese momento el dataset es cerrado y se concluye el paso DATA. Creando variables \u00b6 Hasta ahora solo conoc\u00edamos las sentencias ATTRIB , LENGTH y FORMAT para declarar o iniciar variables. Otra forma de crearlas es mediante la asignaci\u00f3n de variables de la siguiente forma: variable = expresi\u00f3n sas ; Esta sentencia se conoce como sentencias de asignaci\u00f3n . Su funci\u00f3n es evaluar y almacenar el resultado en alguna variable que est\u00e1 al lado izquierdo del signo = . Una forma muy com\u00fan de crear variables es mediante el uso de operadores matem\u00e1ticos. La siguiente tabla muestra algunos de los operadores aritm\u00e9ticos en SAS. Para una referencia consulte Operadores SAS en expresiones y Funciones SAS en expresiones . S\u00edmbolo Descripci\u00f3n Ejemplo + Adici\u00f3n fecha + 1 - Sustracci\u00f3n fecha - 7 * Multiplicaci\u00f3n height * 2.54 / Divisi\u00f3n suma / total ** Exponenciaci\u00f3n metros ** 2 Considere las siguientes sentencias: 1 2 3 4 5 fecha = '10Jun20' d; version = 1 ; status = \"ok\" ; altura = height * 2.54 ; nombre2 = SUBSTR( name, 1 , 3 ); En esas sentencias se han creado las variables simplemente asignando un valor o una expresi\u00f3n SAS. Las primeras tres sentencias crear\u00edan variables de tipo num\u00e9rico; la expresi\u00f3n '10Jun20'd es interpretada por sas como un valor num\u00e9rico. La cuarta sentencia realiza una multiplicaci\u00f3n de una variable por una constante. Finalmente, la quinta aplica una funci\u00f3n a una variable de tipo caracter que extraer\u00e1 los 3 primeros caracteres de una cadena. Para conocer un poco m\u00e1s vea la secci\u00f3n . A continuaci\u00f3n se presentan algunas variables que ser\u00e1n muy \u00fatiles. Variables acumuladoras y contadoras \u00b6 En SAS es posible crear una variable que sume o vaya acumulando. Considere la siguiente tabla donde se representan la informaci\u00f3n de los empleados de una compa\u00f1\u00eda. Se desea obtener un acumulado de las ventas de los empleados y un contador para tener en cuenta el n\u00famero de empleados. El siguiente c\u00f3digo muestra la forma de crear el acumulador y el contador de forma muy b\u00e1sica. 1 2 3 4 5 DATA ventas_au2; SET ventas_au; contador = _N_ ; salario_acum + salary ; RUN; La tercer l\u00ednea guarda el n\u00famero de veces que se ha iterado, es decir el n\u00famero de registros le\u00eddos. Debido a que la variable _N_ es temporal y no se escribe en el dataset, se guarda en la variable contador . En la cuarta se muestra c\u00f3mo acumular en la variable salario_acum , en cada iteraci\u00f3n se le suma la variable salary a la variable salario_acum . Esta sentencia es conocida como sentencia SUM . Cuidado con el operador + Se debe tener cuidado al usar el operador + debido a que si alguno de los operandos tiene un valor missing , el resultado ser\u00eda missing . Se recomienda usar la funci\u00f3n SUM para evitar esos imprevistos. Si se hubiese definido salario_acum = salario_acum + salary en la l\u00ednea 4, el resultado en cada observacion nos resultar\u00eda un valor missing . Como se mencion\u00f3 previamente, durante la fase de compilaci\u00f3n los valores en el VDP se reinician a valor missing causando que el resultado en dicha expresi\u00f3n sea missing . Para evitar que eso ocurra, se puede usar la sentencia RETAIN con el fin de que SAS conserve el valor en cada iteraci\u00f3n. 1 2 3 4 5 DATA ventas_au2; SET ventas_au; RETAIN salario_acum2 0 ; salario_acum2 = salario_acum2 + salary ; RUN; En la l\u00ednea 3 se pide que SAS retenga la variable salario_acum2 en cada iteraci\u00f3n y que su valor inicial sea 0. De esta manera se podr\u00eda sumar de manera normal. Consulte la sentencia RETAIN para m\u00e1s informaci\u00f3n. Funciones y llamadas a rutinas \u00b6 Ya hab\u00edamos mencionado que las funciones pod\u00edan usarse para crear variables, sin embargo ahora se profundizar\u00e1 un poco m\u00e1s en su uso. Las funciones permiten realizar c\u00e1lculos y operaciones en ocasiones muy complejas, \u00e9stas pueden requerir de cierta informaci\u00f3n o argumentos con el fin de traer el resultado. Generalmente son almacenadas en variables, aunque pudieran usarse como una expresi\u00f3n en una sentencia WHERE o IF . Su sintaxis es la siguiente: < variable = > funcion(< argumento1,argumento2 ,\u2026, argumenton >); Las llamadas a rutinas, en cambio en lugar de arrojar un resultado, realizan una acci\u00f3n u operacion. Su sintaxis es la siguiente: CALL rutina(< argumento1,argumento2 ,\u2026, argumenton >); Para m\u00e1s informaci\u00f3n acerca de las llamadas a rutinas y funciones consulte Funciones SAS y rutinas . Filtrado de datos \u00b6 En ocasiones, se tiene una basta cantidad de datos y solo nos interesa un subconjunto de estos. Para eso se pueden elegir observaciones de un dataset con la sentencia WHERE . WHERE vs IF No debe confundirse la sentencia WHERE con IF . La sentencia IF trabaja con observaciones despu\u00e9s de ser le\u00eddas en el VDP, mietras que WHERE selecciona las observaciones antes de pasar al VDP. La sintaxis es la siguiente: WHERE expresi\u00f3n ; donde expresi\u00f3n es una condici\u00f3n a evaluar, vea la secci\u00f3n selecci\u00f3n de observaciones para una referencia de los operadores l\u00f3gicos y booleanos. La siguiente tabla muestra expresiones v\u00e1lidas para la sentencia WHERE Operador Descripci\u00f3n Ejemplo BETWEEN - AND Un rango inclusivo WHERE age BETWEEN 12 AND 15; ? o CONTAINS Una cadena de caracteres WHERE name ? \"Ja\"; IS NULL o IS MISSING Valores faltantes WHERE volumen IS NULL; LIKE Combinaci\u00f3n de patrones WHERE name LIKE \"J%\"; =* Suena como (S\u00f3lo palabras en ingl\u00e9s) WHERE name =* \"jeims\"; SAME - AND Agrega cl\u00e1usulas a una sentencia WHERE existente WHERE sex = \"F\"; WHERE SAME AND age >= 13; En el siguiente ejemplo se muestra el filtrado usando la sentencia WHERE usando los datos de covid para tener s\u00f3lo la informaci\u00f3n de M\u00e9xico. 1 2 3 4 DATA mexico; SET covid; WHERE iso_code EQ \"MEX\" ; RUN; El log muestra el siguiente mensaje: NOTE: There were 609 observations read from the data set WORK.COVID. WHERE iso_code=\u2019MEX\u2019 Si se hubiese usado la sentencia IF en lugar de WHERE el resultado hubiera sido el siguiente: NOTE: There were 113406 observations read from the data set WORK.COVID. NOTE: The data set WORK.MEXICO has 609 observations and 60 variables. El ejemplo anterior muestra las diferencias entre las sentencias IF y WHERE . WHERE como opci\u00f3n de dataset Es posible usar la opci\u00f3n WHERE = para filtrar observaciones para un dataset especificado, esto es \u00fatil cuando se leen m\u00e1s de un dataset. Vea la documentaci\u00f3n para m\u00e1s informaci\u00f3n. Sentencias condicionales \u00b6 Anteriormente se hab\u00eda usado la sentencia IF para seleccionar variables, ahora se usar\u00e1 en conjunto con la palabra THEN con el fin de que realice una acci\u00f3n. Esta sentencia se conoce como sentencia IF-ELSE . La sintaxis es la siguiente: IF expresi\u00f3n THEN acci\u00f3n1 ; ELSE acci\u00f3n2 ; El siguiente ejemplo muestra c\u00f3mo crear una variable a partir de ciertos valores. 1 2 3 4 5 6 DATA clase; SET SASHELP . CLASS; LENGTH sexo $ 8 ; IF sex = \"F\" THEN sexo = \"Mujer\" ; ELSE sexo = \"Hombre\" ; RUN; Note que la sentencia IF-ELSE solo permite una acci\u00f3n a la vez. Para realizar m\u00e1s de una acci\u00f3n se debe usar el bloque DO . Consulte la documentaci\u00f3n para m\u00e1s informaci\u00f3n. 1 2 3 4 5 6 7 8 9 DATA clase; SET SASHELP . CLASS; sexo = \"Hombre\" ; genero = \"Masculino\" ; IF sex = \"F\" THEN DO ; sexo = \"Mujer\" ; genero = \"Femenino\" ; END ; RUN; Estas sentencias pueden anidarse para formar sentencias m\u00e1s complejas, por ejemplo. 1 2 3 4 5 6 7 DATA clase; SET SASHELP . CLASS; LENGTH escuela $ 12 .; IF age LE 12 THEN escuela = \"Primaria\" ; ELSE IF age GE 16 THEN escuela = \"Preparatoria\" ; ELSE escuela = \"Secundaria\" ; RUN; Cuidado con las estructuras anidadas Se debe tener cuidado al usar sentencias anidadas ya que deben ser cerradas correctamente. De no ser as\u00ed, se pueden cometer errores. Otra forma de crear sentencias condicionales es mediante el uso de la sentencia SELECT . Consulte la ayuda para m\u00e1s informaci\u00f3n. 1 2 3 4 5 6 7 8 9 DATA clase; SET SASHELP . CLASS; LENGTH escuela $ 12 .; SELECT ; WHEN (age LE 12 ) escuela = \"Primaria\" ; WHEN (age GE 16 ) escuela = \"Preparatoria\" ; OTHERWISE escuela = \"Secundaria\" ; END ; RUN; No confundirse Esta sentencia no debe confundirse con la sentencia SELECT de SQL . Para hacer algo similar en SQL, revise este ejemplo . Ciclos \u00b6 Al igual que otros lenguajes de programaci\u00f3n SAS dispone de sentencias de ciclo repetitivos. Estas sentencias son \u00fatiles para simulaci\u00f3n de datos o para ingreso de datos repetitivos. DO iterativo \u00b6 Es el equivalente al FOR de algunos programas La sintaxis es la siguiente: DO variable-\u00edndice = lista ; sentencias sas ; END; donde lista puede ser un rango de valores consecutivos (indicando inicio, fin e incremento) o una lista de valores. Consulte la documentaci\u00f3n para una mayor referencia. El siguiente ejemplo muestra su uso 1 2 3 4 5 6 7 8 9 10 11 12 13 DATA ejemplo; INPUT color :$ 8 .; DO i = 1 , 3 , 5 ; j = _N_ ; OUTPUT ; END ; DATALINES; azul verde rojo amarillo ; RUN; El dataset anterior lee los datos se\u00f1alados por la sentencia INPUT . En la primer iteraci\u00f3n (es decir,cuando lee \u201cazul\u201d) entra al ciclo DO y se escribe en el VDP el primer valor de la secuencia (i). La instrucci\u00f3n OUTPUT indica que se debe escribir ese valor al DATASET. Esto se repite para los valores restantes (3 y 5). Note que a\u00fan estamos en la primer iteraci\u00f3n (es decir _N_ = 1 ). Cuando se terminan los valores del ciclo DO, se lee la segunda observaci\u00f3n del DATALINES y se repite lo mismo. Esta estructura tambi\u00e9n es \u00fatil para leer datos consecutivos y hacer secuencias, por ejemplo 1 2 3 4 5 6 7 8 9 10 11 12 13 DATA colores; DO i = 1 to 4 ; INPUT color :$ 8 . @@; j = _N_ ; OUTPUT ; END ; DATALINES; azul verde rojo amarillo verde rojo amarillo azul rojo amarillo azul verde amarillo azul verde rojo ; RUN; Note que derante la primer iteraci\u00f3n ( _N_ = 1 ) se inicia el ciclo DO con valores del 1 al 4. Una vez dentro del ciclo, SAS empezar\u00e1 a leer los 4 primeros valores del DATALINES y los escribir\u00e1 al dataset. Esto se repetir\u00e1 hasta que ya no haya observaciones por leer. DO CONTINUE \u00b6 SAS tiene una sentencia especial que permite, dentro de un ciclo, saltar al siguiente valor de la variable \u00edndice. Esto puede ser \u00fatil para prevenir que otras sentencias se ejecuten. El siguiente ejemplo muestra su uso. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 DATA colores; DO i = 1 to 4 ; INPUT color :$ 8 . @@; j = _N_ ; IF color IN ( \"blanco\" \"negro\" ) THEN CONTINUE ; OUTPUT ; END ; DATALINES; negro azul rojo amarillo azul verde rojo amarillo verde rojo amarillo azul rojo amarillo azul verde blanco azul rojo amarillo amarillo azul verde rojo ; RUN; El c\u00f3digo anterior evita que en el dataset se ingresen los colores blanco o negro, ya que al cumplirse la condici\u00f3n no se ejecuta la sentencia OUTPUT; . Consulte la ayuda de SAS para m\u00e1s informaci\u00f3n acerca de la sentencia CONTINUE . DO LEAVE \u00b6 A diferencia de la sentencia CONTINUE , la sentencia LEAVE permite salir del ciclo DO . El siguiente ejemplo muestra el uso de la sentencia LEAVE . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 DATA colores; DO i = 1 to 4 ; INPUT color :$ 8 . @@; j = _N_ ; IF color IN ( \"blanco\" \"negro\" ) THEN LEAVE ; OUTPUT ; END ; DATALINES; azul verde rojo amarillo verde rojo amarillo azul negro color1 color2 color3 azul rojo amarillo verde rojo amarillo azul verde blanco color1 color2 color3 azul rojo amarillo verde amarillo azul verde rojo ; RUN; En este caso, cuando se cumple la condici\u00f3n, sale del ciclo DO y esto implica que se lea la siguiente l\u00ednea por lo que no se toma en cuenta los valores que hay en las l\u00edneas 11 y 14. Consulte la sentencia LEAVE para m\u00e1s informaci\u00f3n. DO WHILE \u00b6 La sentencia DO WHILE es un bloque de instrucciones que se ejecuta siempre que se est\u00e9 cumpliendo la condici\u00f3n, dicha condici\u00f3n debe cumplirse forzosamente antes de entrar al ciclo, de otra forma no se ejecutar\u00e1. El siguiente ejemplo muestra el uso de la estructura DO WHILE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 DATA colores; contador = 1 ; alto = 100 ; DO WHILE (contador < alto); INPUT color :$ 8 . @@; j = _N_ ; IF color IN ( \"blanco\" \"negro\" ) THEN alto = contador; OUTPUT ; contador + 1 ; END ; DATALINES; azul negro rojo amarillo verde rojo amarillo azul negro azul rojo amarillo azul verde rojo amarillo verde rojo amarillo azul rojo amarillo azul verde blanco azul rojo amarillo amarillo azul verde rojo ; RUN; En el c\u00f3digo anterior, se define un contador con el valor de 1 y una variable de paro con el valor de 100. Al entrar al ciclo, se leen las l\u00edneas con la sentencia INPUT . Cuando el color es blanco o negro, se modifica el criterio de alto con el fin de salir del ciclo y con ello se pasa a la segunda iteraci\u00f3n, reinici\u00e1ndose tanto el contador (1) como el criterio de alto (100). Condici\u00f3n de alto Siempre es importante definir una expresi\u00f3n o condici\u00f3n de alto, de otra forma, se entrar\u00eda en un ciclo infinito. Para conocer m\u00e1s vea la ayuda de SAS sobre esta sentencia. DO UNTIL \u00b6 A diferencia de las instrucciones anteriores, la sentencia DO UNTIL asegura que al menos se ejecuta una vez. La expresi\u00f3n se eval\u00faa al final de las sentencias del bloque. Si la expresi\u00f3n es verdadera, el ciclo ya no itera. Usando el mismo c\u00f3digo que en la secci\u00f3n anterior, se muestran los resultados: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 DATA colores; contador = 0 ; alto = 100 ; DO UNTIL (contador >= alto); contador + 1 ; INPUT color :$ 8 . @@; j = _N_ ; IF color IN ( \"blanco\" \"negro\" ) THEN DO ; contador = 0 ; alto = contador; END ; OUTPUT ; END ; DATALINES; azul negro rojo amarillo blanco rojo amarillo azul negro azul rojo amarillo azul verde rojo blanco verde rojo amarillo azul rojo amarillo azul verde blanco azul rojo amarillo amarillo azul verde rojo ; RUN; Note que en la primer iteraci\u00f3n se entra al ciclo y se escriben los valores al dataset. En el segundo valor le\u00eddo ( negro ) se cumple la condici\u00f3n pero ya ha cambiado el valor de las variables contador y alto a cero y se salta a la siguiente iteraci\u00f3n. Con la nueva iteraci\u00f3n se reinician los valores iniciales hasta que se cumpla la condici\u00f3n. Para m\u00e1s informaci\u00f3n vea la secci\u00f3n DO UNTIL . Arreglos \u00b6 Sup\u00f3ngase que se desea tener informaci\u00f3n de ventas acomodada en columnas, donde cada una represente un trimestre. Una forma de introducir esta informaci\u00f3n es mediante el uso de arreglos o arrays , los arreglos nos ayudan a crear variables de forma f\u00e1cil ya que sus elementos ser\u00e1n usados como nombres de variables. El siguiente ejemplo muestra c\u00f3mo definir un arreglo. 1 2 3 4 5 6 7 8 9 10 11 DATA ventas; ARRAY Tri{ 4 } T1 - T4; INFILE datalines ; INPUT periodo T1--T4; DATALINES; 2018 1718 1755 1777 2100 2019 1760 1769 1799 2195 2020 1790 1230 1300 1685 2021 1375 1420 1498 1965 ; RUN; En la l\u00ednea 2 se define un arreglo de nombre Tri cuyos elementos son T1 , T2 , T3 y T4 , estos elementos son usados en la l\u00ednea 4 en la sentencia INPUT . No confundir con otros lenguajes A pesar de que tienen un nombre id\u00e9ntico, los arreglos no son iguales a los objetos de otros lenguajes de programaci\u00f3n. Los arreglos tambien son \u00fatiles para crear variables de forma iterativa y pueden ser usadas dentro de un ciclo. 1 2 3 4 5 6 7 8 9 DATA DATOS; ARRAY vector{ 3 } x1 - x3 ( 0 0 0 ); DO i = 1 TO 5 ; DO j = 1 TO 3 ; vector{j} = j*i; OUTPUT ; END ; END ; RUN; En el ejemplo anterior,en la l\u00ednea 2 se define un vector con 3 elementos y sus valores iniciales son cero. Se ha usado un doble ciclo y el valor calculado en la l\u00ednea 5 se guarda en la variable correspondiente de acuerdo a los \u00edndices i y j . El resultado se muestra a continuaci\u00f3n Para conocer m\u00e1s acerca del uso de arreglos visite la ayuda de SAS sobre arreglos . Manipulaci\u00f3n y transformaci\u00f3n de bases \u00b6 Cuando se tiene la informaci\u00f3n almacenada, en ocasiones es necesario modificarla seg\u00fan las necesidades, por ejemplo para segmentarla, agruparla o realizar ciertas operaciones para an\u00e1lisis posteriores. En esta secci\u00f3n se estudiar\u00e1n las formas de transformar las bases de datos, tales como ordenar una base, transponerla, unir una base a otras y modificar una base. Ordenando una base \u00b6 SAS posee un procedimiento especializado en ordenar bases por una o m\u00e1s variables. El procedimiento SORT, permite entre otras cosas, ordenar una base por una o m\u00e1s variables ya sea num\u00e9rica o de tipo caracter. La sintaxis b\u00e1sica es la siguiente: PROC SORT < collating-sequence-option > < other options >; BY < DESCENDING > variable-1 << DESCENDING > variable-2 \u2026>; Consulte secuencia de cotejado para conocer m\u00e1s acerca de c\u00f3mo SAS ordena las variables. Por ejemplo, sup\u00f3ngase que se tiene la tabla calificaciones y se desea ordenar la base por el nombre y grupo del estudiante. Nombre Grupo Puntaje ANG\u00c9LICA A 10 BRENDA A 9 MARCO B 8 LILIANA B 8 FABI\u00c1N C 9 MAURICIO C 7 \u00c1LVARO A 8 \u00d3SCAR B 9 BEL\u00c9N C 10 1 2 3 PROC SORT data=calificaciones; BY nombre grupo ; RUN; El resultado del c\u00f3digo anterior se presenta a continucaci\u00f3n. Sin embargo se puede observar que los nombres no est\u00e1n ordenados correctamente, debido a que los nombres acentuados est\u00e1n al final. Para solucionar eso, se puede usar otra opci\u00f3n de secuencia de cotejado para que se ordene de manera correcta, en este caso se usar\u00e1 la opci\u00f3n SORTSEQ = LINGUISTIC para que SAS ordene los nombres correctamente. 1 2 3 PROC SORT SORTSEQ = LINGUISTIC data=calificaciones; BY nombre grupo ; RUN; Ordenamiento en espa\u00f1ol Al usar la opci\u00f3n de secuencia de cotejado SORTSEQ = SPANISH , las letras con acento se ordenar\u00edan primero y no seguir\u00edan un \u00f3rden l\u00f3gico. El resultado se presenta a continuaci\u00f3n. Eliminaci\u00f3n de datos duplicados \u00b6 Cuando se tiene informaci\u00f3n en donde cada individuo posee un identificador o clave \u00fanica, es importante quitar duplicados con el fin de evitar informaci\u00f3n redundate. El procedimiento SORT , no solo ordena, sino que tambi\u00e9n permite eliminar datos duplicados. Considere esta tabla con informaci\u00f3n de clientes de una compa\u00f1ia Number GivenName Surname Birthday Age Occupation 1 Ezio Vanegas 04/06/1942 79 Labor economist 2 Katharina Res\u00e9ndez 12/08/1967 53 Support clerk 3 Tamara Monroy 02/01/1948 73 Analytical chemist 4 Dunstano Armend\u00e1riz 05/07/1985 36 Specification inspector 5 Baldo Ayala 04/10/1952 69 Sportscaster 6 Adri\u00e1n Rosales 8/28/1992 29 Gas appliance repairer 7 Helvia Viera 12/16/1994 26 Hostler 8 Astor Cortez 12/04/1965 55 Adult secondary education teacher 9 Giusto Carvajal 5/27/1986 35 Fish and game warden 10 Baal Alcal\u00e1 1/15/1961 60 Conciliator 1 Ezio Vanegas 04/06/1942 79 Labor economist 4 Dunstano Armend\u00e1riz 05/07/1985 36 Specification inspector 5 Baldo Ayala 04/10/1952 69 Sportscaster 10 Baal Alcal\u00e1 1/15/1961 60 Conciliator 10 Baal Alcal\u00e1 1/15/1961 60 Conciliator El siguiente ejemplo muestra como desduplicar los clientes de la tabla anterior y la informaci\u00f3n de los clientes duplicados se guardar\u00e1 en un tabla para un an\u00e1lisis posterior. 1 2 3 PROC SORT data=clientes dupout=repetidos NODUPKEY; BY number ; RUN; La tabla ordenada y sin duplicados se muestra a continuaci\u00f3n. Por otro lado, la tabla con los clientes duplicados se ha guardo y podr\u00eda servir para un otro an\u00e1lisis del por qu\u00e9 hay informaci\u00f3n duplicada.","title":"Manipulaci\u00f3n de bases"},{"location":"sas/manejo_variables/#manejo-de-bases","text":"En esta secci\u00f3n se presentan temas m\u00e1s profundos acerca del procesamiento de datos. Se explorar\u00e1n distintas formas de manejar bases mediante uso de variables, seleccionar observaciones as\u00ed como el uso de ciclos y arreglos que nos permitan tener un mayor control de la informaci\u00f3n que se tenga. Primero se ver\u00e1 la forma de crear variables con el fin de realizar c\u00e1lculos posteriores, estas variables pueden ser usadas incluso para crear varios datasets, crear contadores o acumuladores, entre otras. Tambi\u00e9n se conocer\u00e1n t\u00e9cnicas de selecci\u00f3n de observaciones con el fin de manipular mejor las bases. Despu\u00e9s se explorar\u00e1 un poco el tema del ordenamiento con el fin de crear ya sea grupos o realizar otras operciones como uniones, transposiciones entre otras. Antes de continuar con temas mas complejos, es importante comprender de forma general el funcionamiento del paso DATA. Para una explicaci\u00f3n m\u00e1s detallada consulte C\u00f3mo funciona el paso DATA . El paso DATA tiene dos fases: Fase de compilaci\u00f3n Fase de ejecuci\u00f3n A continuaci\u00f3n se describir\u00b4n de forma breve estas fases. Durante la fase de compilaci\u00f3n, SAS revisa la sintaxis y si es correcta, se manda a c\u00f3digo m\u00e1quina en dondese procesa el c\u00f3digo y se generan los siguientes objetos: Memoria de entrada . Es un lugar en la memoria donde SAS lee registros de un archivo de texto cuando el programa se ejecute. Vector de datos del programa . Es un lugar en la memoria donde SAS construye un conjunto de datos, una observaci\u00f3n a la vez. Porci\u00f3n descriptora . Es la informaci\u00f3n general del dataset como el nombre de la base y los atributos de las variables a crear. La memoria de entrada solo aplica en el caso en que se lean archivos externos. En este caso, los datos se leen de la memoria de entrada al vector de datos del programa. El vector de datos del programa (VDP) es importante porque en \u00e9ste se realizar\u00edan los c\u00e1lculos de las sentencias de SAS o funciones. Contiene el nombre de todas las variables declaradas o inicializadas. Es como un paso intermedio entre lo que se lee y calcula con lo que se se escribe al dataset. Al inicio de cada iteraci\u00f3n los valores en el VDP son iniciados con valor missing y son llenados seg\u00fan lea o ejecuten sentencias. Durante la fase de compilaci\u00f3n tambien se crean dos variables auxiliares en el VDP que no se escribir\u00e1n en el dataset: _N_ y _ERROR_ . La primera cuenta el n\u00famero de veces que el paso DATA itera y la segunda registra si hubo alg\u00fan problema en la fase de ejecuci\u00f3n. Una vez conclu\u00edda esta etapa, se procede a la siguiente fase. En la fase de ejecuci\u00f3n se realizan las siguientes acciones: Se leen las observaciones del VDP. Se ejecutan las sentencias (c\u00e1lculo de variables). Se escriben al dataset. La variables en el VDP son reiniciadas y se colocan valores missing. Debido a que es un procesos repetitivo, SAS realiza los pasos mencionados tantas veces como observaciones haya en el archivo externo o dataset le\u00eddo. El proceso termina cuando ya no hay registros que leer y en ese momento el dataset es cerrado y se concluye el paso DATA.","title":"Manejo de bases"},{"location":"sas/manejo_variables/#creando-variables","text":"Hasta ahora solo conoc\u00edamos las sentencias ATTRIB , LENGTH y FORMAT para declarar o iniciar variables. Otra forma de crearlas es mediante la asignaci\u00f3n de variables de la siguiente forma: variable = expresi\u00f3n sas ; Esta sentencia se conoce como sentencias de asignaci\u00f3n . Su funci\u00f3n es evaluar y almacenar el resultado en alguna variable que est\u00e1 al lado izquierdo del signo = . Una forma muy com\u00fan de crear variables es mediante el uso de operadores matem\u00e1ticos. La siguiente tabla muestra algunos de los operadores aritm\u00e9ticos en SAS. Para una referencia consulte Operadores SAS en expresiones y Funciones SAS en expresiones . S\u00edmbolo Descripci\u00f3n Ejemplo + Adici\u00f3n fecha + 1 - Sustracci\u00f3n fecha - 7 * Multiplicaci\u00f3n height * 2.54 / Divisi\u00f3n suma / total ** Exponenciaci\u00f3n metros ** 2 Considere las siguientes sentencias: 1 2 3 4 5 fecha = '10Jun20' d; version = 1 ; status = \"ok\" ; altura = height * 2.54 ; nombre2 = SUBSTR( name, 1 , 3 ); En esas sentencias se han creado las variables simplemente asignando un valor o una expresi\u00f3n SAS. Las primeras tres sentencias crear\u00edan variables de tipo num\u00e9rico; la expresi\u00f3n '10Jun20'd es interpretada por sas como un valor num\u00e9rico. La cuarta sentencia realiza una multiplicaci\u00f3n de una variable por una constante. Finalmente, la quinta aplica una funci\u00f3n a una variable de tipo caracter que extraer\u00e1 los 3 primeros caracteres de una cadena. Para conocer un poco m\u00e1s vea la secci\u00f3n . A continuaci\u00f3n se presentan algunas variables que ser\u00e1n muy \u00fatiles.","title":"Creando variables"},{"location":"sas/manejo_variables/#variables-acumuladoras-y-contadoras","text":"En SAS es posible crear una variable que sume o vaya acumulando. Considere la siguiente tabla donde se representan la informaci\u00f3n de los empleados de una compa\u00f1\u00eda. Se desea obtener un acumulado de las ventas de los empleados y un contador para tener en cuenta el n\u00famero de empleados. El siguiente c\u00f3digo muestra la forma de crear el acumulador y el contador de forma muy b\u00e1sica. 1 2 3 4 5 DATA ventas_au2; SET ventas_au; contador = _N_ ; salario_acum + salary ; RUN; La tercer l\u00ednea guarda el n\u00famero de veces que se ha iterado, es decir el n\u00famero de registros le\u00eddos. Debido a que la variable _N_ es temporal y no se escribe en el dataset, se guarda en la variable contador . En la cuarta se muestra c\u00f3mo acumular en la variable salario_acum , en cada iteraci\u00f3n se le suma la variable salary a la variable salario_acum . Esta sentencia es conocida como sentencia SUM . Cuidado con el operador + Se debe tener cuidado al usar el operador + debido a que si alguno de los operandos tiene un valor missing , el resultado ser\u00eda missing . Se recomienda usar la funci\u00f3n SUM para evitar esos imprevistos. Si se hubiese definido salario_acum = salario_acum + salary en la l\u00ednea 4, el resultado en cada observacion nos resultar\u00eda un valor missing . Como se mencion\u00f3 previamente, durante la fase de compilaci\u00f3n los valores en el VDP se reinician a valor missing causando que el resultado en dicha expresi\u00f3n sea missing . Para evitar que eso ocurra, se puede usar la sentencia RETAIN con el fin de que SAS conserve el valor en cada iteraci\u00f3n. 1 2 3 4 5 DATA ventas_au2; SET ventas_au; RETAIN salario_acum2 0 ; salario_acum2 = salario_acum2 + salary ; RUN; En la l\u00ednea 3 se pide que SAS retenga la variable salario_acum2 en cada iteraci\u00f3n y que su valor inicial sea 0. De esta manera se podr\u00eda sumar de manera normal. Consulte la sentencia RETAIN para m\u00e1s informaci\u00f3n.","title":"Variables acumuladoras y contadoras"},{"location":"sas/manejo_variables/#funciones-y-llamadas-a-rutinas","text":"Ya hab\u00edamos mencionado que las funciones pod\u00edan usarse para crear variables, sin embargo ahora se profundizar\u00e1 un poco m\u00e1s en su uso. Las funciones permiten realizar c\u00e1lculos y operaciones en ocasiones muy complejas, \u00e9stas pueden requerir de cierta informaci\u00f3n o argumentos con el fin de traer el resultado. Generalmente son almacenadas en variables, aunque pudieran usarse como una expresi\u00f3n en una sentencia WHERE o IF . Su sintaxis es la siguiente: < variable = > funcion(< argumento1,argumento2 ,\u2026, argumenton >); Las llamadas a rutinas, en cambio en lugar de arrojar un resultado, realizan una acci\u00f3n u operacion. Su sintaxis es la siguiente: CALL rutina(< argumento1,argumento2 ,\u2026, argumenton >); Para m\u00e1s informaci\u00f3n acerca de las llamadas a rutinas y funciones consulte Funciones SAS y rutinas .","title":"Funciones y llamadas a rutinas"},{"location":"sas/manejo_variables/#filtrado-de-datos","text":"En ocasiones, se tiene una basta cantidad de datos y solo nos interesa un subconjunto de estos. Para eso se pueden elegir observaciones de un dataset con la sentencia WHERE . WHERE vs IF No debe confundirse la sentencia WHERE con IF . La sentencia IF trabaja con observaciones despu\u00e9s de ser le\u00eddas en el VDP, mietras que WHERE selecciona las observaciones antes de pasar al VDP. La sintaxis es la siguiente: WHERE expresi\u00f3n ; donde expresi\u00f3n es una condici\u00f3n a evaluar, vea la secci\u00f3n selecci\u00f3n de observaciones para una referencia de los operadores l\u00f3gicos y booleanos. La siguiente tabla muestra expresiones v\u00e1lidas para la sentencia WHERE Operador Descripci\u00f3n Ejemplo BETWEEN - AND Un rango inclusivo WHERE age BETWEEN 12 AND 15; ? o CONTAINS Una cadena de caracteres WHERE name ? \"Ja\"; IS NULL o IS MISSING Valores faltantes WHERE volumen IS NULL; LIKE Combinaci\u00f3n de patrones WHERE name LIKE \"J%\"; =* Suena como (S\u00f3lo palabras en ingl\u00e9s) WHERE name =* \"jeims\"; SAME - AND Agrega cl\u00e1usulas a una sentencia WHERE existente WHERE sex = \"F\"; WHERE SAME AND age >= 13; En el siguiente ejemplo se muestra el filtrado usando la sentencia WHERE usando los datos de covid para tener s\u00f3lo la informaci\u00f3n de M\u00e9xico. 1 2 3 4 DATA mexico; SET covid; WHERE iso_code EQ \"MEX\" ; RUN; El log muestra el siguiente mensaje: NOTE: There were 609 observations read from the data set WORK.COVID. WHERE iso_code=\u2019MEX\u2019 Si se hubiese usado la sentencia IF en lugar de WHERE el resultado hubiera sido el siguiente: NOTE: There were 113406 observations read from the data set WORK.COVID. NOTE: The data set WORK.MEXICO has 609 observations and 60 variables. El ejemplo anterior muestra las diferencias entre las sentencias IF y WHERE . WHERE como opci\u00f3n de dataset Es posible usar la opci\u00f3n WHERE = para filtrar observaciones para un dataset especificado, esto es \u00fatil cuando se leen m\u00e1s de un dataset. Vea la documentaci\u00f3n para m\u00e1s informaci\u00f3n.","title":"Filtrado de datos"},{"location":"sas/manejo_variables/#sentencias-condicionales","text":"Anteriormente se hab\u00eda usado la sentencia IF para seleccionar variables, ahora se usar\u00e1 en conjunto con la palabra THEN con el fin de que realice una acci\u00f3n. Esta sentencia se conoce como sentencia IF-ELSE . La sintaxis es la siguiente: IF expresi\u00f3n THEN acci\u00f3n1 ; ELSE acci\u00f3n2 ; El siguiente ejemplo muestra c\u00f3mo crear una variable a partir de ciertos valores. 1 2 3 4 5 6 DATA clase; SET SASHELP . CLASS; LENGTH sexo $ 8 ; IF sex = \"F\" THEN sexo = \"Mujer\" ; ELSE sexo = \"Hombre\" ; RUN; Note que la sentencia IF-ELSE solo permite una acci\u00f3n a la vez. Para realizar m\u00e1s de una acci\u00f3n se debe usar el bloque DO . Consulte la documentaci\u00f3n para m\u00e1s informaci\u00f3n. 1 2 3 4 5 6 7 8 9 DATA clase; SET SASHELP . CLASS; sexo = \"Hombre\" ; genero = \"Masculino\" ; IF sex = \"F\" THEN DO ; sexo = \"Mujer\" ; genero = \"Femenino\" ; END ; RUN; Estas sentencias pueden anidarse para formar sentencias m\u00e1s complejas, por ejemplo. 1 2 3 4 5 6 7 DATA clase; SET SASHELP . CLASS; LENGTH escuela $ 12 .; IF age LE 12 THEN escuela = \"Primaria\" ; ELSE IF age GE 16 THEN escuela = \"Preparatoria\" ; ELSE escuela = \"Secundaria\" ; RUN; Cuidado con las estructuras anidadas Se debe tener cuidado al usar sentencias anidadas ya que deben ser cerradas correctamente. De no ser as\u00ed, se pueden cometer errores. Otra forma de crear sentencias condicionales es mediante el uso de la sentencia SELECT . Consulte la ayuda para m\u00e1s informaci\u00f3n. 1 2 3 4 5 6 7 8 9 DATA clase; SET SASHELP . CLASS; LENGTH escuela $ 12 .; SELECT ; WHEN (age LE 12 ) escuela = \"Primaria\" ; WHEN (age GE 16 ) escuela = \"Preparatoria\" ; OTHERWISE escuela = \"Secundaria\" ; END ; RUN; No confundirse Esta sentencia no debe confundirse con la sentencia SELECT de SQL . Para hacer algo similar en SQL, revise este ejemplo .","title":"Sentencias condicionales"},{"location":"sas/manejo_variables/#ciclos","text":"Al igual que otros lenguajes de programaci\u00f3n SAS dispone de sentencias de ciclo repetitivos. Estas sentencias son \u00fatiles para simulaci\u00f3n de datos o para ingreso de datos repetitivos.","title":"Ciclos"},{"location":"sas/manejo_variables/#do-iterativo","text":"Es el equivalente al FOR de algunos programas La sintaxis es la siguiente: DO variable-\u00edndice = lista ; sentencias sas ; END; donde lista puede ser un rango de valores consecutivos (indicando inicio, fin e incremento) o una lista de valores. Consulte la documentaci\u00f3n para una mayor referencia. El siguiente ejemplo muestra su uso 1 2 3 4 5 6 7 8 9 10 11 12 13 DATA ejemplo; INPUT color :$ 8 .; DO i = 1 , 3 , 5 ; j = _N_ ; OUTPUT ; END ; DATALINES; azul verde rojo amarillo ; RUN; El dataset anterior lee los datos se\u00f1alados por la sentencia INPUT . En la primer iteraci\u00f3n (es decir,cuando lee \u201cazul\u201d) entra al ciclo DO y se escribe en el VDP el primer valor de la secuencia (i). La instrucci\u00f3n OUTPUT indica que se debe escribir ese valor al DATASET. Esto se repite para los valores restantes (3 y 5). Note que a\u00fan estamos en la primer iteraci\u00f3n (es decir _N_ = 1 ). Cuando se terminan los valores del ciclo DO, se lee la segunda observaci\u00f3n del DATALINES y se repite lo mismo. Esta estructura tambi\u00e9n es \u00fatil para leer datos consecutivos y hacer secuencias, por ejemplo 1 2 3 4 5 6 7 8 9 10 11 12 13 DATA colores; DO i = 1 to 4 ; INPUT color :$ 8 . @@; j = _N_ ; OUTPUT ; END ; DATALINES; azul verde rojo amarillo verde rojo amarillo azul rojo amarillo azul verde amarillo azul verde rojo ; RUN; Note que derante la primer iteraci\u00f3n ( _N_ = 1 ) se inicia el ciclo DO con valores del 1 al 4. Una vez dentro del ciclo, SAS empezar\u00e1 a leer los 4 primeros valores del DATALINES y los escribir\u00e1 al dataset. Esto se repetir\u00e1 hasta que ya no haya observaciones por leer.","title":"DO iterativo"},{"location":"sas/manejo_variables/#do-continue","text":"SAS tiene una sentencia especial que permite, dentro de un ciclo, saltar al siguiente valor de la variable \u00edndice. Esto puede ser \u00fatil para prevenir que otras sentencias se ejecuten. El siguiente ejemplo muestra su uso. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 DATA colores; DO i = 1 to 4 ; INPUT color :$ 8 . @@; j = _N_ ; IF color IN ( \"blanco\" \"negro\" ) THEN CONTINUE ; OUTPUT ; END ; DATALINES; negro azul rojo amarillo azul verde rojo amarillo verde rojo amarillo azul rojo amarillo azul verde blanco azul rojo amarillo amarillo azul verde rojo ; RUN; El c\u00f3digo anterior evita que en el dataset se ingresen los colores blanco o negro, ya que al cumplirse la condici\u00f3n no se ejecuta la sentencia OUTPUT; . Consulte la ayuda de SAS para m\u00e1s informaci\u00f3n acerca de la sentencia CONTINUE .","title":"DO CONTINUE"},{"location":"sas/manejo_variables/#do-leave","text":"A diferencia de la sentencia CONTINUE , la sentencia LEAVE permite salir del ciclo DO . El siguiente ejemplo muestra el uso de la sentencia LEAVE . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 DATA colores; DO i = 1 to 4 ; INPUT color :$ 8 . @@; j = _N_ ; IF color IN ( \"blanco\" \"negro\" ) THEN LEAVE ; OUTPUT ; END ; DATALINES; azul verde rojo amarillo verde rojo amarillo azul negro color1 color2 color3 azul rojo amarillo verde rojo amarillo azul verde blanco color1 color2 color3 azul rojo amarillo verde amarillo azul verde rojo ; RUN; En este caso, cuando se cumple la condici\u00f3n, sale del ciclo DO y esto implica que se lea la siguiente l\u00ednea por lo que no se toma en cuenta los valores que hay en las l\u00edneas 11 y 14. Consulte la sentencia LEAVE para m\u00e1s informaci\u00f3n.","title":"DO LEAVE"},{"location":"sas/manejo_variables/#do-while","text":"La sentencia DO WHILE es un bloque de instrucciones que se ejecuta siempre que se est\u00e9 cumpliendo la condici\u00f3n, dicha condici\u00f3n debe cumplirse forzosamente antes de entrar al ciclo, de otra forma no se ejecutar\u00e1. El siguiente ejemplo muestra el uso de la estructura DO WHILE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 DATA colores; contador = 1 ; alto = 100 ; DO WHILE (contador < alto); INPUT color :$ 8 . @@; j = _N_ ; IF color IN ( \"blanco\" \"negro\" ) THEN alto = contador; OUTPUT ; contador + 1 ; END ; DATALINES; azul negro rojo amarillo verde rojo amarillo azul negro azul rojo amarillo azul verde rojo amarillo verde rojo amarillo azul rojo amarillo azul verde blanco azul rojo amarillo amarillo azul verde rojo ; RUN; En el c\u00f3digo anterior, se define un contador con el valor de 1 y una variable de paro con el valor de 100. Al entrar al ciclo, se leen las l\u00edneas con la sentencia INPUT . Cuando el color es blanco o negro, se modifica el criterio de alto con el fin de salir del ciclo y con ello se pasa a la segunda iteraci\u00f3n, reinici\u00e1ndose tanto el contador (1) como el criterio de alto (100). Condici\u00f3n de alto Siempre es importante definir una expresi\u00f3n o condici\u00f3n de alto, de otra forma, se entrar\u00eda en un ciclo infinito. Para conocer m\u00e1s vea la ayuda de SAS sobre esta sentencia.","title":"DO WHILE"},{"location":"sas/manejo_variables/#do-until","text":"A diferencia de las instrucciones anteriores, la sentencia DO UNTIL asegura que al menos se ejecuta una vez. La expresi\u00f3n se eval\u00faa al final de las sentencias del bloque. Si la expresi\u00f3n es verdadera, el ciclo ya no itera. Usando el mismo c\u00f3digo que en la secci\u00f3n anterior, se muestran los resultados: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 DATA colores; contador = 0 ; alto = 100 ; DO UNTIL (contador >= alto); contador + 1 ; INPUT color :$ 8 . @@; j = _N_ ; IF color IN ( \"blanco\" \"negro\" ) THEN DO ; contador = 0 ; alto = contador; END ; OUTPUT ; END ; DATALINES; azul negro rojo amarillo blanco rojo amarillo azul negro azul rojo amarillo azul verde rojo blanco verde rojo amarillo azul rojo amarillo azul verde blanco azul rojo amarillo amarillo azul verde rojo ; RUN; Note que en la primer iteraci\u00f3n se entra al ciclo y se escriben los valores al dataset. En el segundo valor le\u00eddo ( negro ) se cumple la condici\u00f3n pero ya ha cambiado el valor de las variables contador y alto a cero y se salta a la siguiente iteraci\u00f3n. Con la nueva iteraci\u00f3n se reinician los valores iniciales hasta que se cumpla la condici\u00f3n. Para m\u00e1s informaci\u00f3n vea la secci\u00f3n DO UNTIL .","title":"DO UNTIL"},{"location":"sas/manejo_variables/#arreglos","text":"Sup\u00f3ngase que se desea tener informaci\u00f3n de ventas acomodada en columnas, donde cada una represente un trimestre. Una forma de introducir esta informaci\u00f3n es mediante el uso de arreglos o arrays , los arreglos nos ayudan a crear variables de forma f\u00e1cil ya que sus elementos ser\u00e1n usados como nombres de variables. El siguiente ejemplo muestra c\u00f3mo definir un arreglo. 1 2 3 4 5 6 7 8 9 10 11 DATA ventas; ARRAY Tri{ 4 } T1 - T4; INFILE datalines ; INPUT periodo T1--T4; DATALINES; 2018 1718 1755 1777 2100 2019 1760 1769 1799 2195 2020 1790 1230 1300 1685 2021 1375 1420 1498 1965 ; RUN; En la l\u00ednea 2 se define un arreglo de nombre Tri cuyos elementos son T1 , T2 , T3 y T4 , estos elementos son usados en la l\u00ednea 4 en la sentencia INPUT . No confundir con otros lenguajes A pesar de que tienen un nombre id\u00e9ntico, los arreglos no son iguales a los objetos de otros lenguajes de programaci\u00f3n. Los arreglos tambien son \u00fatiles para crear variables de forma iterativa y pueden ser usadas dentro de un ciclo. 1 2 3 4 5 6 7 8 9 DATA DATOS; ARRAY vector{ 3 } x1 - x3 ( 0 0 0 ); DO i = 1 TO 5 ; DO j = 1 TO 3 ; vector{j} = j*i; OUTPUT ; END ; END ; RUN; En el ejemplo anterior,en la l\u00ednea 2 se define un vector con 3 elementos y sus valores iniciales son cero. Se ha usado un doble ciclo y el valor calculado en la l\u00ednea 5 se guarda en la variable correspondiente de acuerdo a los \u00edndices i y j . El resultado se muestra a continuaci\u00f3n Para conocer m\u00e1s acerca del uso de arreglos visite la ayuda de SAS sobre arreglos .","title":"Arreglos"},{"location":"sas/manejo_variables/#manipulacion-y-transformacion-de-bases","text":"Cuando se tiene la informaci\u00f3n almacenada, en ocasiones es necesario modificarla seg\u00fan las necesidades, por ejemplo para segmentarla, agruparla o realizar ciertas operaciones para an\u00e1lisis posteriores. En esta secci\u00f3n se estudiar\u00e1n las formas de transformar las bases de datos, tales como ordenar una base, transponerla, unir una base a otras y modificar una base.","title":"Manipulaci\u00f3n y transformaci\u00f3n de bases"},{"location":"sas/manejo_variables/#ordenando-una-base","text":"SAS posee un procedimiento especializado en ordenar bases por una o m\u00e1s variables. El procedimiento SORT, permite entre otras cosas, ordenar una base por una o m\u00e1s variables ya sea num\u00e9rica o de tipo caracter. La sintaxis b\u00e1sica es la siguiente: PROC SORT < collating-sequence-option > < other options >; BY < DESCENDING > variable-1 << DESCENDING > variable-2 \u2026>; Consulte secuencia de cotejado para conocer m\u00e1s acerca de c\u00f3mo SAS ordena las variables. Por ejemplo, sup\u00f3ngase que se tiene la tabla calificaciones y se desea ordenar la base por el nombre y grupo del estudiante. Nombre Grupo Puntaje ANG\u00c9LICA A 10 BRENDA A 9 MARCO B 8 LILIANA B 8 FABI\u00c1N C 9 MAURICIO C 7 \u00c1LVARO A 8 \u00d3SCAR B 9 BEL\u00c9N C 10 1 2 3 PROC SORT data=calificaciones; BY nombre grupo ; RUN; El resultado del c\u00f3digo anterior se presenta a continucaci\u00f3n. Sin embargo se puede observar que los nombres no est\u00e1n ordenados correctamente, debido a que los nombres acentuados est\u00e1n al final. Para solucionar eso, se puede usar otra opci\u00f3n de secuencia de cotejado para que se ordene de manera correcta, en este caso se usar\u00e1 la opci\u00f3n SORTSEQ = LINGUISTIC para que SAS ordene los nombres correctamente. 1 2 3 PROC SORT SORTSEQ = LINGUISTIC data=calificaciones; BY nombre grupo ; RUN; Ordenamiento en espa\u00f1ol Al usar la opci\u00f3n de secuencia de cotejado SORTSEQ = SPANISH , las letras con acento se ordenar\u00edan primero y no seguir\u00edan un \u00f3rden l\u00f3gico. El resultado se presenta a continuaci\u00f3n.","title":"Ordenando una base"},{"location":"sas/manejo_variables/#eliminacion-de-datos-duplicados","text":"Cuando se tiene informaci\u00f3n en donde cada individuo posee un identificador o clave \u00fanica, es importante quitar duplicados con el fin de evitar informaci\u00f3n redundate. El procedimiento SORT , no solo ordena, sino que tambi\u00e9n permite eliminar datos duplicados. Considere esta tabla con informaci\u00f3n de clientes de una compa\u00f1ia Number GivenName Surname Birthday Age Occupation 1 Ezio Vanegas 04/06/1942 79 Labor economist 2 Katharina Res\u00e9ndez 12/08/1967 53 Support clerk 3 Tamara Monroy 02/01/1948 73 Analytical chemist 4 Dunstano Armend\u00e1riz 05/07/1985 36 Specification inspector 5 Baldo Ayala 04/10/1952 69 Sportscaster 6 Adri\u00e1n Rosales 8/28/1992 29 Gas appliance repairer 7 Helvia Viera 12/16/1994 26 Hostler 8 Astor Cortez 12/04/1965 55 Adult secondary education teacher 9 Giusto Carvajal 5/27/1986 35 Fish and game warden 10 Baal Alcal\u00e1 1/15/1961 60 Conciliator 1 Ezio Vanegas 04/06/1942 79 Labor economist 4 Dunstano Armend\u00e1riz 05/07/1985 36 Specification inspector 5 Baldo Ayala 04/10/1952 69 Sportscaster 10 Baal Alcal\u00e1 1/15/1961 60 Conciliator 10 Baal Alcal\u00e1 1/15/1961 60 Conciliator El siguiente ejemplo muestra como desduplicar los clientes de la tabla anterior y la informaci\u00f3n de los clientes duplicados se guardar\u00e1 en un tabla para un an\u00e1lisis posterior. 1 2 3 PROC SORT data=clientes dupout=repetidos NODUPKEY; BY number ; RUN; La tabla ordenada y sin duplicados se muestra a continuaci\u00f3n. Por otro lado, la tabla con los clientes duplicados se ha guardo y podr\u00eda servir para un otro an\u00e1lisis del por qu\u00e9 hay informaci\u00f3n duplicada.","title":"Eliminaci\u00f3n de datos duplicados"},{"location":"sas/reportes/","text":"Creaci\u00f3n de reportes \u00b6 SAS es una herramienta muy \u00fatil para crear reportes de datos, algunos de ellos se pueden personalizar o adaptarlos a distintas necesidades. Formatos \u00b6 Anteriormente ya hab\u00edamos hablado de los formatos. Reportes b\u00e1sicos \u00b6 El reporte m\u00e1s simple que se puede crear, es mostrar el conjunto de datos usando el procedimiento PROC PRINT . Sin embargo, para datasets muy grandes, esto no ser\u00eda una buena opci\u00f3n debido a que SAS gastar\u00eda muchos recursos en imprimir toda la tabla. Se pueden usar ciertas configuraciones para que SAS solo procece cierta cantidad de observaciones de un dataset. La primera de ellas es mediante las opciones generales , la cual afectar\u00eda a todos los procedimientos durante la sesi\u00f3n o mediante las opciones de dataset la cual solo aplica durante ese procedimiento. Para una referencia completa sobre las opciones generales, visite el diccionario de opciones del sistema y para las opciones de dataset vea el diccionario de opciones de datasets . El siguiente ejemplo muestra las primeras diez observaciones del conjunto de datos de baseball, pero solo pedimos que muestre ciertas variables. 1 2 3 PROC PRINT DATA = SASHELP . BASEBALL(OBS= 10 ); VAR NAME TEAM NHOME SALARY ; RUN; Produce el siguiente resultado Un reporte con seleccionando casos con total \u00b6 PROC PRINT tambien tiene diversas sentencias para hacer reportes m\u00e1s completos o espec\u00edficos. 1 2 3 4 5 6 7 8 9 10 11 12 13 TITLE \"Reporte del equipo San Francisco\" ; PROC PRINT DATA = SASHELP . BASEBALL NOOBS; VAR NAME NHOME SALARY; WHERE TEAM EQ \"San Francisco\" ; FORMAT SALARY DOLLAR12.; LABEL NAME = \"Nombre del jugador\" NHOME = \"N\u00famero de Home Runs en 1986\" SALARY = \"Salario en 1987 (Miles de d\u00f3lares)\" ; SUM NHOME SALARY ; RUN; TITLE ; El anterior ejemplo muestra un reporte que incluye el nombre de todos los jugadores del equipo San Francisco , n\u00famero de home run ysu salario; al final del reporte se presenta el gran total de estas variables. En este ejemplo se modificaron las etiquetas y los formatos, pero s\u00f3lo para el reporte mediante las sentencias LABEL y FORMAT y se seleccionaron las observaciones que cumplieran cierto criterio. La opci\u00f3n NOOBS en la sentencia DATA pide no imprimir el n\u00famero de observaci\u00f3n del dataset y con la opci\u00f3n LABEL se mostrar\u00e1n las etiquetas de las variables. La sentencia VAR especifica las variables a mostrar. La sentencia WHERE selecciona las observaciones que cumplan la condici\u00f3n de que el equipo sea igual a San Francisco . La sentencia FORMAT le asigna a la variable SALARY el formato DOLLAR12. . LABEL especifica las etiquetas de las variables en el reporte. En caso de que las variables del dataset ya tengan etiquetas, estas etiquetas definidas prevalecen en el reporte. La sentencia SUM es la que especifica las variables que mostrar\u00e1n el gran total. Finalmente se agrega la opci\u00f3n TITLE para que se le ponga un t\u00edtulo al reporte y se vuelve a llamar al final para que vuelva a su valor inicial. Reporte con subtotales \u00b6 Es posible mostrar los reportes con subtotales por grupos de variables. Datos agrupados Los datos se deber\u00edan ordenar por la variables que se desee hacer el agrupamiento para evitar posibles errores en los c\u00e1lculos. SAS considera valores iguales de la variable de agrupamiento como un bloque. Si SAS encontrara una observaci\u00f3n con un valor que ya proces\u00f3, se generar\u00e1 un error. Se puede usar el procedimiento SORT para ordenar una dataset por las variables que se deseen y posteriormente realizar el reporte. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 PROC SORT DATA = SASHELP . BASEBALL OUT = BASEBALL; BY DIVISION TEAM ; RUN; PROC PRINT DATA = BASEBALL NOOBS LABEL ; VAR NAME POSITION NHOME SALARY; FORMAT SALARY DOLLAR12.; LABEL DIVISION = \"Divisi\u00f3n\" NAME = \"Nombre del jugador\" TEAM = \"Equipo\" POSITION = \"Posici\u00f3n\" NHOME = \"N\u00famero de Home Runs en 1986\" SALARY = \"Salario en 1987 (Miles de d\u00f3lares)\" ; SUM NHOME SALARY; BY DIVISION TEAM ; RUN; El procedimiento SORT especifica que se ordene por las variables division y luego por team y se pide que se guarde una copia temporal, con el fin de no modificar el dataset original. En el procedimiento PRINT se usa la sentencia BY para que crear el reporte por combinaciones de valores de division y team . La imagen anterior muestra el ultimo grupo de variables (Divisi\u00f3n = West y Equipo = Texas). N\u00f3tese que este grupo contiene los subtotales tanto de las variables team y division as\u00ed como el gran total. Cada grupo contiene como t\u00edtulo el valor de las variables division y team . Personalizar etiquetas Se pueden agregar en la sentencia PROC PRINT las opciones SUMLABEL = y GRANDTOTAL_LABEL = para personalizar las etiquetas de subtotales y el gran total. Si se desea mostrar un reporte con otro estilo resaltando las variables de agrupamiento, se puede agregar la sentencia. ID DIVISION TEAM; El resultado es el siguente.","title":"Elaboraci\u00f3n de reportes"},{"location":"sas/reportes/#creacion-de-reportes","text":"SAS es una herramienta muy \u00fatil para crear reportes de datos, algunos de ellos se pueden personalizar o adaptarlos a distintas necesidades.","title":"Creaci\u00f3n de reportes"},{"location":"sas/reportes/#formatos","text":"Anteriormente ya hab\u00edamos hablado de los formatos.","title":"Formatos"},{"location":"sas/reportes/#reportes-basicos","text":"El reporte m\u00e1s simple que se puede crear, es mostrar el conjunto de datos usando el procedimiento PROC PRINT . Sin embargo, para datasets muy grandes, esto no ser\u00eda una buena opci\u00f3n debido a que SAS gastar\u00eda muchos recursos en imprimir toda la tabla. Se pueden usar ciertas configuraciones para que SAS solo procece cierta cantidad de observaciones de un dataset. La primera de ellas es mediante las opciones generales , la cual afectar\u00eda a todos los procedimientos durante la sesi\u00f3n o mediante las opciones de dataset la cual solo aplica durante ese procedimiento. Para una referencia completa sobre las opciones generales, visite el diccionario de opciones del sistema y para las opciones de dataset vea el diccionario de opciones de datasets . El siguiente ejemplo muestra las primeras diez observaciones del conjunto de datos de baseball, pero solo pedimos que muestre ciertas variables. 1 2 3 PROC PRINT DATA = SASHELP . BASEBALL(OBS= 10 ); VAR NAME TEAM NHOME SALARY ; RUN; Produce el siguiente resultado","title":"Reportes b\u00e1sicos"},{"location":"sas/reportes/#un-reporte-con-seleccionando-casos-con-total","text":"PROC PRINT tambien tiene diversas sentencias para hacer reportes m\u00e1s completos o espec\u00edficos. 1 2 3 4 5 6 7 8 9 10 11 12 13 TITLE \"Reporte del equipo San Francisco\" ; PROC PRINT DATA = SASHELP . BASEBALL NOOBS; VAR NAME NHOME SALARY; WHERE TEAM EQ \"San Francisco\" ; FORMAT SALARY DOLLAR12.; LABEL NAME = \"Nombre del jugador\" NHOME = \"N\u00famero de Home Runs en 1986\" SALARY = \"Salario en 1987 (Miles de d\u00f3lares)\" ; SUM NHOME SALARY ; RUN; TITLE ; El anterior ejemplo muestra un reporte que incluye el nombre de todos los jugadores del equipo San Francisco , n\u00famero de home run ysu salario; al final del reporte se presenta el gran total de estas variables. En este ejemplo se modificaron las etiquetas y los formatos, pero s\u00f3lo para el reporte mediante las sentencias LABEL y FORMAT y se seleccionaron las observaciones que cumplieran cierto criterio. La opci\u00f3n NOOBS en la sentencia DATA pide no imprimir el n\u00famero de observaci\u00f3n del dataset y con la opci\u00f3n LABEL se mostrar\u00e1n las etiquetas de las variables. La sentencia VAR especifica las variables a mostrar. La sentencia WHERE selecciona las observaciones que cumplan la condici\u00f3n de que el equipo sea igual a San Francisco . La sentencia FORMAT le asigna a la variable SALARY el formato DOLLAR12. . LABEL especifica las etiquetas de las variables en el reporte. En caso de que las variables del dataset ya tengan etiquetas, estas etiquetas definidas prevalecen en el reporte. La sentencia SUM es la que especifica las variables que mostrar\u00e1n el gran total. Finalmente se agrega la opci\u00f3n TITLE para que se le ponga un t\u00edtulo al reporte y se vuelve a llamar al final para que vuelva a su valor inicial.","title":"Un reporte con seleccionando casos con total"},{"location":"sas/reportes/#reporte-con-subtotales","text":"Es posible mostrar los reportes con subtotales por grupos de variables. Datos agrupados Los datos se deber\u00edan ordenar por la variables que se desee hacer el agrupamiento para evitar posibles errores en los c\u00e1lculos. SAS considera valores iguales de la variable de agrupamiento como un bloque. Si SAS encontrara una observaci\u00f3n con un valor que ya proces\u00f3, se generar\u00e1 un error. Se puede usar el procedimiento SORT para ordenar una dataset por las variables que se deseen y posteriormente realizar el reporte. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 PROC SORT DATA = SASHELP . BASEBALL OUT = BASEBALL; BY DIVISION TEAM ; RUN; PROC PRINT DATA = BASEBALL NOOBS LABEL ; VAR NAME POSITION NHOME SALARY; FORMAT SALARY DOLLAR12.; LABEL DIVISION = \"Divisi\u00f3n\" NAME = \"Nombre del jugador\" TEAM = \"Equipo\" POSITION = \"Posici\u00f3n\" NHOME = \"N\u00famero de Home Runs en 1986\" SALARY = \"Salario en 1987 (Miles de d\u00f3lares)\" ; SUM NHOME SALARY; BY DIVISION TEAM ; RUN; El procedimiento SORT especifica que se ordene por las variables division y luego por team y se pide que se guarde una copia temporal, con el fin de no modificar el dataset original. En el procedimiento PRINT se usa la sentencia BY para que crear el reporte por combinaciones de valores de division y team . La imagen anterior muestra el ultimo grupo de variables (Divisi\u00f3n = West y Equipo = Texas). N\u00f3tese que este grupo contiene los subtotales tanto de las variables team y division as\u00ed como el gran total. Cada grupo contiene como t\u00edtulo el valor de las variables division y team . Personalizar etiquetas Se pueden agregar en la sentencia PROC PRINT las opciones SUMLABEL = y GRANDTOTAL_LABEL = para personalizar las etiquetas de subtotales y el gran total. Si se desea mostrar un reporte con otro estilo resaltando las variables de agrupamiento, se puede agregar la sentencia. ID DIVISION TEAM; El resultado es el siguente.","title":"Reporte con subtotales"}]}